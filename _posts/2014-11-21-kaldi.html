---
title:  Kaldi学习笔记
category:  note
---
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Kaldi学习笔记</title>
<!-- 2015-03-11 三 11:52 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="robin1001" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="/css/worg.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Kaldi学习笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. kaldi timit脚本解析</a>
<ul>
<li><a href="#sec-1-1">1.1. keynotes</a></li>
<li><a href="#sec-1-2">1.2. 数据准备</a>
<ul>
<li><a href="#sec-1-2-1">1.2.1. timit_data_prepare.sh</a></li>
<li><a href="#sec-1-2-2">1.2.2. timit_prepare_dict.sh</a></li>
<li><a href="#sec-1-2-3">1.2.3. utils/prepare_lang.sh</a></li>
<li><a href="#sec-1-2-4">1.2.4. timit_format_data.sh</a></li>
</ul>
</li>
<li><a href="#sec-1-3">1.3. 特征提取</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1. make_mfcc.sh</a></li>
<li><a href="#sec-1-3-2">1.3.2. compute_cmvn_stats.sh</a></li>
</ul>
</li>
<li><a href="#sec-1-4">1.4. MonoPhone Training &amp; Decoding</a>
<ul>
<li><a href="#sec-1-4-1">1.4.1. steps/train_mono.sh</a></li>
<li><a href="#sec-1-4-2">1.4.2. utils/mkgraph.sh</a></li>
<li><a href="#sec-1-4-3">1.4.3. steps/decode.sh</a></li>
</ul>
</li>
<li><a href="#sec-1-5">1.5. tri1: Deltas + Delta-Deltas Training &amp; Decoding</a>
<ul>
<li><a href="#sec-1-5-1">1.5.1. steps/align_si.sh</a></li>
<li><a href="#sec-1-5-2">1.5.2. steps/train_deltas.sh</a></li>
</ul>
</li>
<li><a href="#sec-1-6">1.6. tri2 : LDA + MLLT Training &amp; Decoding</a>
<ul>
<li><a href="#sec-1-6-1">1.6.1. steps/train_lda_mllt.sh</a></li>
</ul>
</li>
<li><a href="#sec-1-7">1.7. karel's dnn</a>
<ul>
<li><a href="#sec-1-7-1">1.7.1. feature</a></li>
</ul>
</li>
<li><a href="#sec-1-8">1.8. DNN Hybrid Training &amp; Decoding</a>
<ul>
<li><a href="#sec-1-8-1">1.8.1. 网络结构(输入、输出、隐层）</a></li>
<li><a href="#sec-1-8-2">1.8.2. get_lda.sh</a></li>
<li><a href="#sec-1-8-3">1.8.3. get_egs.sh</a></li>
<li><a href="#sec-1-8-4">1.8.4. 训练</a></li>
</ul>
</li>
<li><a href="#sec-1-9">1.9. Getting Results</a></li>
</ul>
</li>
<li><a href="#sec-2">2. kaldi中的数据文件及其作用</a>
<ul>
<li><a href="#sec-2-1">2.1. 数据准备(其中大部分文件均需要排序)</a>
<ul>
<li><a href="#sec-2-1-1">2.1.1. Required(Must provide)</a></li>
<li><a href="#sec-2-1-2">2.1.2. Timit Required</a></li>
</ul>
</li>
<li><a href="#sec-2-2">2.2. 字典准备</a></li>
<li><a href="#sec-2-3">2.3. lang(此处有个中间文件utils/apply_map.pl phone_map）</a></li>
<li><a href="#sec-2-4">2.4. format_data</a></li>
<li><a href="#sec-2-5">2.5. 特征提取</a></li>
<li><a href="#sec-2-6">2.6. 决策树</a></li>
<li><a href="#sec-2-7">2.7. 训练</a></li>
</ul>
</li>
<li><a href="#sec-3">3. kaldi doc</a>
<ul>
<li><a href="#sec-3-1">3.1. kaldi tutorial</a>
<ul>
<li><a href="#sec-3-1-1">3.1.1. Reading and modifying the code</a></li>
</ul>
</li>
<li><a href="#sec-3-2">3.2. Kaldi I/O mechanisms</a></li>
<li><a href="#sec-3-3">3.3. The Kaldi Matrix library</a>
<ul>
<li><a href="#sec-3-3-1">3.3.1. Matrix &amp; Vector</a></li>
<li><a href="#sec-3-3-2">3.3.2. Sub-vectors &amp; Sub-matrices</a></li>
<li><a href="#sec-3-3-3">3.3.3. Copy</a></li>
</ul>
</li>
<li><a href="#sec-3-4">3.4. The build process(how Kaldi is compiled)</a>
<ul>
<li><a href="#sec-3-4-1">3.4.1. kaldi.mk</a></li>
<li><a href="#sec-3-4-2">3.4.2. Makefile</a></li>
</ul>
</li>
<li><a href="#sec-3-5">3.5. Parsing command-line Options</a>
<ul>
<li><a href="#sec-3-5-1">3.5.1. parse-option(util, ParseOption类)</a></li>
</ul>
</li>
<li><a href="#sec-3-6">3.6. Decoders used in the Kaldi toolkit</a></li>
<li><a href="#sec-3-7">3.7. HMM topology and transition modeling</a>
<ul>
<li><a href="#sec-3-7-1">3.7.1. HMM topology</a></li>
<li><a href="#sec-3-7-2">3.7.2. Pdf-classes</a></li>
<li><a href="#sec-3-7-3">3.7.3. Transition models (the TransitionModel object)</a></li>
</ul>
</li>
<li><a href="#sec-3-8">3.8. How decision trees are used in Kaldi</a></li>
<li><a href="#sec-3-9">3.9. Decoding-graph creation recipe(training time)</a></li>
<li><a href="#sec-3-10">3.10. Other kaldi utilities</a>
<ul>
<li><a href="#sec-3-10-1">3.10.1. hash-list(util/hash-list.h)</a></li>
<li><a href="#sec-3-10-2">3.10.2. kaldi-table(util/kaldi-table)</a></li>
</ul>
</li>
<li><a href="#sec-3-11">3.11. Clustering mechanisms in Kaldi</a></li>
<li><a href="#sec-3-12">3.12. Acoustic modeling code</a></li>
<li><a href="#sec-3-13">3.13. Deep Neural Networks in Kaldi</a>
<ul>
<li><a href="#sec-3-13-1">3.13.1. 两种不同实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">4. kaldi cuda</a></li>
<li><a href="#sec-5">5. kaldi 部分代码解析</a>
<ul>
<li><a href="#sec-5-1">5.1. 解码</a>
<ul>
<li><a href="#sec-5-1-1">5.1.1. DecodableInterface</a></li>
<li><a href="#sec-5-1-2">5.1.2. SimpleDecoder</a></li>
</ul>
</li>
<li><a href="#sec-5-2">5.2. 三音素决策树</a>
<ul>
<li><a href="#sec-5-2-1">5.2.1. 数据结构</a></li>
<li><a href="#sec-5-2-2">5.2.2. Clusterable</a></li>
<li><a href="#sec-5-2-3">5.2.3. 计算似然和似然增益</a></li>
<li><a href="#sec-5-2-4">5.2.4. tools &amp; core code</a></li>
</ul>
</li>
<li><a href="#sec-5-3">5.3. DNN</a>
<ul>
<li><a href="#sec-5-3-1">5.3.1. component</a></li>
<li><a href="#sec-5-3-2">5.3.2. nnet</a></li>
<li><a href="#sec-5-3-3">5.3.3. nnet-train-frmshuff</a></li>
</ul>
</li>
<li><a href="#sec-5-4">5.4. CNN</a>
<ul>
<li><a href="#sec-5-4-1">5.4.1. keypoint</a></li>
<li><a href="#sec-5-4-2">5.4.2. 代码解析</a></li>
</ul>
</li>
<li><a href="#sec-5-5">5.5. 一些工具解析</a>
<ul>
<li><a href="#sec-5-5-1">5.5.1. ali-to-post: make_pair&lt;alignment, 1.0&gt;, Convert alignments to viterbi style posteriors</a></li>
<li><a href="#sec-5-5-2">5.5.2. kaldi log(base/kaldi-error.h)</a></li>
<li><a href="#sec-5-5-3">5.5.3. kaldi中的并行run.pl</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-6">6. Kaldi Keypoint</a>
<ul>
<li><a href="#sec-6-1">6.1. GMM</a>
<ul>
<li><a href="#sec-6-1-1">6.1.1. <span class="todo TODO">TODO</span> 如何加高斯，gmm split &amp; merge</a></li>
<li><a href="#sec-6-1-2">6.1.2. 训练时每个模型的高斯数不一定相等，有意思哈！</a></li>
<li><a href="#sec-6-1-3">6.1.3. AmGMM.Split()</a></li>
</ul>
</li>
<li><a href="#sec-6-2">6.2. 训练方式</a>
<ul>
<li><a href="#sec-6-2-1">6.2.1. lda(Linear Discriminant Analysis)</a></li>
<li><a href="#sec-6-2-2">6.2.2. mllt(Maximum Likelihood Linear Transformation)</a></li>
<li><a href="#sec-6-2-3">6.2.3. sat</a></li>
<li><a href="#sec-6-2-4">6.2.4. sgmm(subspace gmm)</a></li>
<li><a href="#sec-6-2-5">6.2.5. mmi</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-7">7. Kaldi二进制文件查看</a></li>
<li><a href="#sec-8">8. fst</a>
<ul>
<li><a href="#sec-8-1">8.1. 定义</a></li>
<li><a href="#sec-8-2">8.2. 空转移</a></li>
<li><a href="#sec-8-3">8.3. A &amp; T</a></li>
<li><a href="#sec-8-4">8.4. 运算</a></li>
<li><a href="#sec-8-5">8.5. 确定化</a>
<ul>
<li><a href="#sec-8-5-1">8.5.1. 何为确定化</a></li>
<li><a href="#sec-8-5-2">8.5.2. 确定化算法</a></li>
</ul>
</li>
<li><a href="#sec-8-6">8.6. 最小化</a></li>
<li><a href="#sec-8-7">8.7. Weight Pushing</a></li>
<li><a href="#sec-8-8">8.8. Epsilon消除</a></li>
<li><a href="#sec-8-9">8.9. linux fst 程序编译</a></li>
<li><a href="#sec-8-10">8.10. 数据结构</a>
<ul>
<li><a href="#sec-8-10-1">8.10.1. StdArc</a></li>
<li><a href="#sec-8-10-2">8.10.2. fst</a></li>
</ul>
</li>
<li><a href="#sec-8-11">8.11. 半环</a>
<ul>
<li><a href="#sec-8-11-1">8.11.1. 幺半群</a></li>
<li><a href="#sec-8-11-2">8.11.2. 半环</a></li>
<li><a href="#sec-8-11-3">8.11.3. Moore &amp; Mealy</a></li>
</ul>
</li>
<li><a href="#sec-8-12">8.12. openfst</a></li>
</ul>
</li>
<li><a href="#sec-9">9. Google C++ Style Guide</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> kaldi timit脚本解析</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> keynotes</h3>
<div class="outline-text-3" id="text-1-1">
<pre class="example">
1. train_cmd在cmd.sh中定义，训练方式选择
2. 所有日志记录文件保存exp目录下
3. utils/parse_option.sh
   + config参数及文件是否存在
4. ark, archive, data all in one file
5. rspecifier, wspecifier
6. $dir一般输出哈 
7. cmd=run.pl
8. timit中仅用到音素级标注.PHN, 并未用到词级.txt
</pre>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 数据准备</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> timit_data_prepare.sh</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>wav.scp:文件列表
</li>
<li>uttids：文件id
</li>
<li>text：抄本
</li>
<li>utt2spk spk2utt:语音&#x2013;&gt;说话人
</li>
<li>duration calc, mean, min, max,在别的任务中不是必须的
</li>
<li>stm, gtm等文件，在别的人物中也不是必须的
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> timit_prepare_dict.sh</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>phone
</li>
<li>lm：音素级bigram，build-lm.sh compile-lm
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> utils/prepare_lang.sh</h4>
<div class="outline-text-4" id="text-1-2-3">
<pre class="example">
参数:
1. --position-dependent-phones false, 音素是否设置为与在词中的位置相关
  (B)egin, (E)nd, (I)nternal and (S)ingleton，设置相关后，单个音素会扩展为4个。
a_B 6
a_E 7
a_I 8
a_S 9
2. "sil" "!SIL" "&lt;UNK&gt;" 写入到oov.txt
</pre>
<ul class="org-ul">
<li>sets.txt音素 sets.int 整数
</li>
<li>roots.txt "shared split aa" roots.int
</li>
<li>silence.txt nonsilence.txt context_indep.txt extra_questions.txt
</li>
<li>disambig.txt: 辅助符号
</li>
<li>phones.txt(silence.txt nosilence.txt disambig.txt)
</li>
<li>words.txt（esp 0, #0)  phones.txt(增加silence和#0,#1）
</li>
<li>align_lexicon.txt 
</li>
<li>fstcompile &#x2013;isymbols=$dir/phones.txt &#x2013;osymbols=$dir/words.txt
</li>
<li>为什么构造这样一个L.fst 0.693147180559945(log 0.5)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4"><span class="section-number-4">1.2.4</span> timit_format_data.sh</h4>
<div class="outline-text-4" id="text-1-2-4">
<ul class="org-ul">
<li>将data lang数据分类归整到data\train test文件夹下，标准命令，例如原train.text修改为data/train/text文件
</li>
<li>utils/validate_data_dir.sh &#x2013;no-feats data/$x || exit 1, 这个很重要，检查数据准备是否有序，kaldi中要求有序，便于随机读取
</li>
<li>准备了G.fst
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 特征提取</h3>
<div class="outline-text-3" id="text-1-3">
</div><div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> make_mfcc.sh</h4>
<div class="outline-text-4" id="text-1-3-1">
<ol class="org-ol">
<li>conf/mfcc.conf: &#x2013;user-energy=false
</li>
<li>.parse_option.sh 得看看
</li>
<li>分割scp题特征，并行提特征ark，再连接特征列表至feats.scp
</li>
<li>log文件夹exp
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> compute_cmvn_stats.sh</h4>
<div class="outline-text-4" id="text-1-3-2">
<ol class="org-ol">
<li>生成文件目录同mfcc
</li>
<li>cmvn使用到spk2utt，做什么用？
</li>
<li>cmvn是对每一个说话人做的
</li>
<li>compute-cmvn-stats: ????
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> MonoPhone Training &amp; Decoding</h3>
<div class="outline-text-3" id="text-1-4">
</div><div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> steps/train_mono.sh</h4>
<div class="outline-text-4" id="text-1-4-1">
<ol class="org-ol">
<li>totgauss=1000
</li>
<li>compile-train-graphs 
</li>
<li>stage=-4, |-3|-2|-1
</li>
<li>feat-to-dim: 获得特征维度39
</li>
<li>gmm-init-mono 输出模型0.mdl和tree单音素树
</li>
<li>计算特征全局均值方差
</li>
<li>所有单音素表示成为一棵树
</li>
<li>data/lang/topo 初始hmm模型参数, left-right-hmm
</li>
<li>compile-train-graph 为每个训练语句构造一个解码的fst
</li>
<li>align-equal-compiled:对特征等分对齐进行初始化
</li>
<li>gmm-est: 根据对齐结果对模型进行更新，每个状态的高斯数不等
</li>
</ol>
<p>
10.gmm-align-compiled: 在fst上识别，输出对齐 
</p>
<ol class="org-ol">
<li>loop: gmm-align-compiled gmm-acc-stats-ali gmm-est
</li>
<li>add-deltas, 使用2阶和3阶差分mfcc，此时39
</li>
<li>compute-cmvn-stats计算cmvn, apply-cmvn对特征文件使用cmvn
</li>
</ol>
</div>
<ol class="org-ol"><li><a id="sec-1-4-1-1" name="sec-1-4-1-1"></a>TrainingGraphCompiler<br  /><div class="outline-text-5" id="text-1-4-1-1">
<ul class="org-ul">
<li>CompileGraphFromText
</li>
<li>MakeLinearAcceptor: 为每个语句生成一个acceptor，(ilabel, olabel, 1), 其中label为抄本当前音素
</li>
<li>compose acceptor &amp; lex_fst
</li>
<li>make cfst ContextFst
</li>
<li>ctx2word_fst
</li>
<li>trans2word_fst
</li>
</ul>
</div>
</li></ol>
</div>
<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><span class="section-number-4">1.4.2</span> utils/mkgraph.sh</h4>
<div class="outline-text-4" id="text-1-4-2">
</div><ol class="org-ol"><li><a id="sec-1-4-2-1" name="sec-1-4-2-1"></a>fst操作<br  /><div class="outline-text-5" id="text-1-4-2-1">
<ol class="org-ol">
<li>fsttablecompose: compose
</li>
<li>fstminmizeencode: min
</li>
<li>fstdeterminizestart: det
</li>
<li>fstcomposecontext: context expend
</li>
<li>fstisstochastic: ????
</li>
<li>make-h-transducer: 生成HMM的fst,Ha.fst
</li>
<li>主要实现：H*det(C*det(L * G))
</li>
<li>add-self-loops: 可能是hmm自身跳转
</li>
</ol>
</div>
</li></ol>
</div>
<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3"><span class="section-number-4">1.4.3</span> steps/decode.sh</h4>
<div class="outline-text-4" id="text-1-4-3">
<ol class="org-ol">
<li>feat_type: lda | delta
</li>
<li>mono input: exp/mono/graph(model) data/dev(source) 
</li>
<li>gmm-latgen-faster:解码
</li>
<li>local/score.sh
</li>
<li>JOB=1:$nj
</li>
<li>output:lat.n.gz
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> tri1: Deltas + Delta-Deltas Training &amp; Decoding</h3>
<div class="outline-text-3" id="text-1-5">
</div><div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> steps/align_si.sh</h4>
<div class="outline-text-4" id="text-1-5-1">
<ol class="org-ol">
<li>output: mono_ali
</li>
<li>gmm-align-complied
</li>
<li>compile-train-graphs
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2"><span class="section-number-4">1.5.2</span> steps/train_deltas.sh</h4>
<div class="outline-text-4" id="text-1-5-2">
<ul class="org-ul">
<li>acc-tree-stats
</li>
</ul>
<p>
SplitToPhones()
end_points: 检测一个状态结束位置
AccumulateTreeStats
输出map&lt;EventType, ClusterableInterface&gt;，
假设为单音素&lt;{(-1,66), (0, 22)}, I&gt;的map结构
ClusterableInterface保存特征个数，并提供Add方法对特征进行累加，可以计算均值和方差。
</p>
<ul class="org-ul">
<li>sum-tree-stats: 统计三音素上下文特征
</li>
<li>cluster-phones：根据单音素聚类，生成所有可能的问题集, TreeCluster &amp; KMeans
</li>
<li>compile-questions:生成qst文件,为EventType设置问题集，key=-1问题集为[0 ] [0 1], key=0, 1, 2问题集为questions.txt
</li>
<li>build-tree: 建立决策树
</li>
<li>gmm-init-model
</li>
<li>gmm-mixup
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> tri2 : LDA + MLLT Training &amp; Decoding</h3>
<div class="outline-text-3" id="text-1-6">
</div><div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1"><span class="section-number-4">1.6.1</span> steps/train_lda_mllt.sh</h4>
<div class="outline-text-4" id="text-1-6-1">
<ol class="org-ol">
<li>拼接特征 splice-feats, 前后7帧
</li>
<li>weight-silence-post: 将post中silence的weight*silence_weight = 0.0
</li>
</ol>
<div class="org-src-container">

<pre class="src src-cpp">silence_scale=0.0
<span style="color: #228b22;">void</span> WeightSilencePost(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">TransitionModel</span> &amp;<span style="color: #a0522d;">trans_model</span>,
                       <span style="color: #a020f0;">const</span> <span style="color: #228b22;">ConstIntegerSet</span>&lt;int32&gt; &amp;<span style="color: #a0522d;">silence_set</span>,
                       <span style="color: #228b22;">BaseFloat</span> <span style="color: #a0522d;">silence_scale</span>,
                       Posterior *post) {
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i &lt; post-&gt;size(); i++) {
    <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">pair</span>&lt;int32, <span style="color: #228b22;">BaseFloat</span>&gt; &gt; <span style="color: #a0522d;">this_post</span>;
    this_post.reserve((*post)[i].size());
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span> = 0; j &lt; (*post)[i].size(); j++) {
      <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">tid</span> = (*post)[i][j].first,
          <span style="color: #a0522d;">phone</span> = trans_model.TransitionIdToPhone(tid);
      <span style="color: #228b22;">BaseFloat</span> <span style="color: #a0522d;">weight</span> = (*post)[i][j].second;
      <span style="color: #a020f0;">if</span> (silence_set.count(phone) != 0) {  <span style="color: #b22222;">// </span><span style="color: #b22222;">is a silence.</span>
        <span style="color: #a020f0;">if</span> (silence_scale != 0.0)
          this_post.push_back(<span style="color: #008b8b;">std</span>::make_pair(tid, weight*silence_scale));
      } <span style="color: #a020f0;">else</span> {
        this_post.push_back(<span style="color: #008b8b;">std</span>::make_pair(tid, weight));
      }
    }
    (*post)[i].swap(this_post);
  }
}
</pre>
</div>
<ol class="org-ol">
<li>acc-lda: 按照pdf id进行统计
</li>
</ol>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #228b22;">Posterior</span> <span style="color: #a0522d;">pdf_post</span>;
ConvertPosteriorToPdfs(trans_model, post, &amp;pdf_post);
<span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">i</span> = 0; i &lt; feats.NumRows(); i++) {
  <span style="color: #228b22;">SubVector</span>&lt;BaseFloat&gt; <span style="color: #a0522d;">feat</span>(<span style="color: #228b22;">feats</span>, i);
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">j</span> = 0; j &lt; pdf_post[i].size(); j++) {
    <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">pdf_id</span> = pdf_post[i][j].first;
    <span style="color: #228b22;">BaseFloat</span> <span style="color: #a0522d;">weight</span> = RandPrune(pdf_post[i][j].second, rand_prune);
    <span style="color: #a020f0;">if</span> (weight != 0.0) {
      lda.Accumulate(feat, pdf_id, weight);
    }
  }
}
</pre>
</div>
<ol class="org-ol">
<li>est_lda
</li>
<li>dim=40
</li>
</ol>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #228b22;">void</span> <span style="color: #008b8b;">LdaEstimate</span>::<span style="color: #0000ff;">Estimate</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">LdaEstimateOptions</span> &amp;<span style="color: #a0522d;">opts</span>,
                           <span style="color: #228b22;">Matrix</span>&lt;BaseFloat&gt; *<span style="color: #a0522d;">m</span>,
                           <span style="color: #228b22;">Matrix</span>&lt;BaseFloat&gt; *<span style="color: #a0522d;">mfull</span>) <span style="color: #a020f0;">const</span> {
  <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">target_dim</span> = opts.dim;
  KALDI_ASSERT(target_dim &gt; 0);
  <span style="color: #b22222;">// </span><span style="color: #b22222;">between-class covar is of most rank C-1</span>
  KALDI_ASSERT(target_dim &lt;= Dim() &amp;&amp; (target_dim &lt; NumClasses() || opts.allow_large_dim));
  <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">dim</span> = Dim();

  <span style="color: #228b22;">double</span> <span style="color: #a0522d;">count</span>;
  <span style="color: #228b22;">SpMatrix</span>&lt;<span style="color: #228b22;">double</span>&gt; <span style="color: #a0522d;">total_covar</span>, <span style="color: #a0522d;">bc_covar</span>;
  <span style="color: #228b22;">Vector</span>&lt;<span style="color: #228b22;">double</span>&gt; <span style="color: #a0522d;">total_mean</span>;
  GetStats(&amp;total_covar, &amp;bc_covar, &amp;total_mean, &amp;count);

  <span style="color: #b22222;">// </span><span style="color: #b22222;">within-class covariance</span>
  <span style="color: #228b22;">SpMatrix</span>&lt;<span style="color: #228b22;">double</span>&gt; <span style="color: #a0522d;">wc_covar</span>(total_covar);
  wc_covar.AddSp(-1.0, bc_covar);
  <span style="color: #228b22;">TpMatrix</span>&lt;<span style="color: #228b22;">double</span>&gt; <span style="color: #a0522d;">wc_covar_sqrt</span>(dim);
  <span style="color: #a020f0;">try</span> {
    wc_covar_sqrt.Cholesky(wc_covar);
  } <span style="color: #a020f0;">catch</span> (...) {
    <span style="color: #228b22;">BaseFloat</span> <span style="color: #a0522d;">smooth</span> = 1.0e-03 * wc_covar.Trace() / wc_covar.NumRows();
    KALDI_LOG &lt;&lt; <span style="color: #8b2252;">"Cholesky failed (possibly not +ve definite), so adding "</span> &lt;&lt; smooth
              &lt;&lt; <span style="color: #8b2252;">" to diagonal and trying again.\n"</span>;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">i</span> = 0; i &lt; wc_covar.NumRows(); i++)
      <span style="color: #a0522d;">wc_covar</span>(i, i) += smooth;
    wc_covar_sqrt.Cholesky(wc_covar);    
  }
  <span style="color: #228b22;">Matrix</span>&lt;<span style="color: #228b22;">double</span>&gt; <span style="color: #a0522d;">wc_covar_sqrt_mat</span>(wc_covar_sqrt);
  <span style="color: #b22222;">// </span><span style="color: #b22222;">copy wc_covar_sqrt to Matrix, because it facilitates further use</span>
  wc_covar_sqrt_mat.Invert();

  <span style="color: #228b22;">SpMatrix</span>&lt;<span style="color: #228b22;">double</span>&gt; <span style="color: #a0522d;">tmp_sp</span>(dim);
  tmp_sp.AddMat2Sp(1.0, wc_covar_sqrt_mat, kNoTrans, bc_covar, 0.0);
  <span style="color: #228b22;">Matrix</span>&lt;<span style="color: #228b22;">double</span>&gt; <span style="color: #a0522d;">tmp_mat</span>(tmp_sp);

  <span style="color: #228b22;">Matrix</span>&lt;<span style="color: #228b22;">double</span>&gt; <span style="color: #a0522d;">svd_u</span>(dim, dim), <span style="color: #a0522d;">svd_vt</span>(dim, dim);
  <span style="color: #228b22;">Vector</span>&lt;<span style="color: #228b22;">double</span>&gt; <span style="color: #a0522d;">svd_d</span>(dim);
  tmp_mat.Svd(&amp;svd_d, &amp;svd_u, &amp;svd_vt);
  SortSvd(&amp;svd_d, &amp;svd_u);

  KALDI_LOG &lt;&lt; <span style="color: #8b2252;">"Data count is "</span> &lt;&lt; count;
  KALDI_LOG &lt;&lt; <span style="color: #8b2252;">"LDA singular values are "</span> &lt;&lt; svd_d;

  KALDI_LOG &lt;&lt; <span style="color: #8b2252;">"Sum of all singular values is "</span> &lt;&lt; svd_d.Sum();
  KALDI_LOG &lt;&lt; <span style="color: #8b2252;">"Sum of selected singular values is "</span> &lt;&lt;
      <span style="color: #228b22;">SubVector</span>&lt;<span style="color: #228b22;">double</span>&gt;(svd_d, 0, target_dim).Sum();

  <span style="color: #228b22;">Matrix</span>&lt;<span style="color: #228b22;">double</span>&gt; <span style="color: #a0522d;">lda_mat</span>(dim, dim);
  lda_mat.AddMatMat(1.0, svd_u, kTrans, wc_covar_sqrt_mat, kNoTrans, 0.0);

  <span style="color: #b22222;">// </span><span style="color: #b22222;">finally, copy first target_dim rows to m</span>
  m-&gt;Resize(target_dim, dim);
  m-&gt;CopyFromMat(lda_mat.Range(0, target_dim, 0, dim));

  <span style="color: #a020f0;">if</span> (mfull != <span style="color: #008b8b;">NULL</span>) {
    mfull-&gt;Resize(dim, dim);
    mfull-&gt;CopyFromMat(lda_mat);
  }

  <span style="color: #a020f0;">if</span> (opts.within_class_factor != 1.0) { <span style="color: #b22222;">// </span><span style="color: #b22222;">This is not the normal code path;</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">it's intended for use in neural net inputs.</span>
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">i</span> = 0; i &lt; svd_d.Dim(); i++) {
      <span style="color: #228b22;">BaseFloat</span> <span style="color: #a0522d;">old_var</span> = 1.0 + svd_d(i), <span style="color: #b22222;">// </span><span style="color: #b22222;">the total variance of that dim..</span>
          <span style="color: #a0522d;">new_var</span> = opts.within_class_factor + svd_d(i), <span style="color: #b22222;">// </span><span style="color: #b22222;">the variance we want..</span>
          <span style="color: #a0522d;">scale</span> = sqrt(new_var / old_var);
      <span style="color: #a020f0;">if</span> (i &lt; m-&gt;NumRows())
        m-&gt;Row(i).Scale(scale);
      <span style="color: #a020f0;">if</span> (mfull != <span style="color: #008b8b;">NULL</span>)
        mfull-&gt;Row(i).Scale(scale);
    }
  }

  <span style="color: #a020f0;">if</span> (opts.remove_offset) {
    AddMeanOffset(total_mean, m);
    <span style="color: #a020f0;">if</span> (mfull != <span style="color: #008b8b;">NULL</span>)
      AddMeanOffset(total_mean, mfull);
  }  
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> karel's dnn</h3>
<div class="outline-text-3" id="text-1-7">
</div><div id="outline-container-sec-1-7-1" class="outline-4">
<h4 id="sec-1-7-1"><span class="section-number-4">1.7.1</span> feature</h4>
<div class="outline-text-4" id="text-1-7-1">
<pre class="example">
#zss splice feature
feats_cv="ark,s,cs:utils/filter_scp.pl $dir/valid_uttlist $data/feats.scp | apply-cmvn --norm-vars=$norm_vars $data/norm_global_mv.ark scp:- ark:- | splice-feats ark:- ark:-|"
#dnn Generate the splice transform
echo "Using splice +/- $splice , step $splice_step"
feature_transform=$dir/tr_splice$splice-$splice_step.nnet
utils/nnet/gen_splice.py --fea-dim=$feat_dim --splice=$splice --splice-step=$splice_step &gt; $feature_transform
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> DNN Hybrid Training &amp; Decoding</h3>
<div class="outline-text-3" id="text-1-8">
</div><div id="outline-container-sec-1-8-1" class="outline-4">
<h4 id="sec-1-8-1"><span class="section-number-4">1.8.1</span> 网络结构(输入、输出、隐层）</h4>
<div class="outline-text-4" id="text-1-8-1">
<ul class="org-ul">
<li>num_epochs=15, numjobs_nnet = 16, hidden_layer_dim=300, minibatch_size=128, shuffle_buffer_size
</li>
<li>num_hidden_layers=3
</li>
<li>输入特征 lda, feat, get_lda, (egs空暂不考虑)
</li>
<li>输出的是什么 num_leaves，状态
</li>
<li>nnet.config
</li>
<li>hidden.config
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8-2" class="outline-4">
<h4 id="sec-1-8-2"><span class="section-number-4">1.8.2</span> get_lda.sh</h4>
<div class="outline-text-4" id="text-1-8-2">
<ul class="org-ul">
<li>输出lda.mat
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8-3" class="outline-4">
<h4 id="sec-1-8-3"><span class="section-number-4">1.8.3</span> get_egs.sh</h4>
<div class="outline-text-4" id="text-1-8-3">
<ol class="org-ol">
<li>transform_dir=$alidir
</li>
<li>shuffle_list, 随机从训练语句中抽取300
</li>
</ol>
<div class="org-src-container">

<pre class="src src-bash">awk '{print $1}' $data/utt2spk | utils/shuffle_list.pl | head -$num_utts_subset \
	&gt; $dir/valid_uttlist || exit 1;
</pre>
</div>
<ol class="org-ol">
<li>valid_uttlist, train_subset_uttlist 两个互补
</li>
<li>samples_per_iter
</li>
<li>num_frame:  1124823, samples_per_iter: 200000
</li>
<li>nnet-get-egs: 准备网络输入格式的数据，上下文特征,pdf标签
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-8-4" class="outline-4">
<h4 id="sec-1-8-4"><span class="section-number-4">1.8.4</span> 训练</h4>
<div class="outline-text-4" id="text-1-8-4">
</div><ol class="org-ol"><li><a id="sec-1-8-4-1" name="sec-1-8-4-1"></a>问题<br  /><ol class="org-ol"><li><a id="sec-1-8-4-1-1" name="sec-1-8-4-1-1"></a><span class="todo TODO">TODO</span> shuffle是什么？<br  /></li>
<li><a id="sec-1-8-4-1-2" name="sec-1-8-4-1-2"></a><span class="todo TODO">TODO</span> 如何利用hmm初始化,feature is not equal dimension<br  /></li>
<li><a id="sec-1-8-4-1-3" name="sec-1-8-4-1-3"></a><span class="todo TODO">TODO</span> 如何使用nnet的priors_<br  /><div class="outline-text-6" id="text-1-8-4-1-3">
<p>
给网络加上先验，训练时并没有用，用于识别时。
</p>
</div>
</li>
<li><a id="sec-1-8-4-1-4" name="sec-1-8-4-1-4"></a><span class="todo TODO">TODO</span> dropout, bottleneck如何使用<br  /><div class="outline-text-6" id="text-1-8-4-1-4">
<p>
Dropout Component
</p>
</div>
</li></ol>
</li>
<li><a id="sec-1-8-4-2" name="sec-1-8-4-2"></a>数据结构<br  /><div class="outline-text-5" id="text-1-8-4-2">
<ul class="org-ul">
<li>Example
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">NnetExample</span> {
<span style="color: #b22222;">/// </span><span style="color: #b22222;">The label(s) for this frame; in the normal case, this will be a vector of</span>
<span style="color: #b22222;">/// </span><span style="color: #b22222;">length one, containing (the pdf-id, 1.0)</span>
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">pair</span>&lt;int32, BaseFloat&gt; &gt; <span style="color: #a0522d;">labels</span>;
<span style="color: #b22222;">/// </span><span style="color: #b22222;">The input data-- typically with NumRows() more than</span>
<span style="color: #b22222;">/// </span><span style="color: #b22222;">labels.size(), it includes features to the left and</span>
<span style="color: #b22222;">/// </span><span style="color: #b22222;">right as needed for the temporal context of the network.</span>
<span style="color: #b22222;">/// </span><span style="color: #b22222;">(see the left_context variable).</span>
<span style="color: #228b22;">CompressedMatrix</span> <span style="color: #a0522d;">input_frames</span>;
<span style="color: #b22222;">/// </span><span style="color: #b22222;">The number of frames of left context (we can work out the #frames</span>
<span style="color: #b22222;">/// </span><span style="color: #b22222;">of right context from input_frames.NumRows(), labels.size(), and this).</span>
<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">left_context</span>;
<span style="color: #b22222;">/// </span><span style="color: #b22222;">The speaker-specific input, if any, or an empty vector if</span>
<span style="color: #b22222;">/// </span><span style="color: #b22222;">we're not using this features. We'll append this to each of the</span>
<span style="color: #228b22;">Vector</span>&lt;BaseFloat&gt; <span style="color: #a0522d;">spk_info</span>; 
<span style="color: #b22222;">/// </span><span style="color: #b22222;">Set the label of this example to the specified pdf_id </span>
<span style="color: #b22222;">/// </span><span style="color: #b22222;">with the specified weight.</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">SetLabelSingle</span>(<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">pdf_id</span>, <span style="color: #228b22;">BaseFloat</span> <span style="color: #a0522d;">weight</span> = 1.0);
<span style="color: #b22222;">/// </span><span style="color: #b22222;">Get the maximum weight label (pdf_id and weight) of this example. </span>
<span style="color: #228b22;">int32</span> <span style="color: #0000ff;">GetLabelSingle</span>(<span style="color: #228b22;">BaseFloat</span> *<span style="color: #a0522d;">weight</span> = <span style="color: #008b8b;">NULL</span>);
};
</pre>
</div>
<ul class="org-ul">
<li>Component
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b22222;">// </span><span style="color: #b22222;">nnet/nnet-activation.h</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Softmax</span> : <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Component</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">BlockSoftmax</span> : <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Component</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Sigmoid</span> : <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Component</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Tanh</span> : <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Component</span> 
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Dropout</span> : <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Component</span>
</pre>
</div>
<ul class="org-ul">
<li>NnetSimpleTrainer
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b22222;">//</span><span style="color: #b22222;">&#37324;&#38754;&#27809;&#26377;prior_&#30340;&#20449;&#24687;, &#37027;&#20040;prior&#22312;&#37027;&#37324;&#29992;&#65311;</span>
<span style="color: #228b22;">void</span> <span style="color: #008b8b;">NnetSimpleTrainer</span>::<span style="color: #0000ff;">TrainOnExample</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">NnetExample</span> &amp;<span style="color: #a0522d;">value</span>) {
buffer_.push_back(value);
<span style="color: #a020f0;">if</span> (<span style="color: #a020f0;">static_cast</span>&lt;int32&gt;(buffer_.size()) == config_.minibatch_size)
TrainOneMinibatch();
}
<span style="color: #228b22;">void</span> <span style="color: #008b8b;">NnetSimpleTrainer</span>::<span style="color: #0000ff;">TrainOneMinibatch</span>() {

KALDI_ASSERT(!buffer_.empty());
<span style="color: #b22222;">// </span><span style="color: #b22222;">The following function is declared in nnet-update.h.</span>
logprob_this_phase_ += DoBackprop(*nnet_,
buffer_,
nnet_);
weight_this_phase_ += TotalNnetTrainingWeight(buffer_);
buffer_.clear();
minibatches_seen_this_phase_++;
<span style="color: #a020f0;">if</span> (minibatches_seen_this_phase_ == config_.minibatches_per_phase) {
<span style="color: #228b22;">bool</span> <span style="color: #a0522d;">first_time</span> = <span style="color: #008b8b;">false</span>;
BeginNewPhase(first_time);
}
}
</pre>
</div>
<ul class="org-ul">
<li>AmNnet
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b22222;">//</span><span style="color: #b22222;">Amnet</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">AmNnet</span> {
  <span style="color: #228b22;">Nnet</span> <span style="color: #a0522d;">nnet_</span>;
  <span style="color: #228b22;">Vector</span>&lt;BaseFloat&gt; <span style="color: #a0522d;">priors_</span>; 
};
</pre>
</div>
</div>
</li>
<li><a id="sec-1-8-4-3" name="sec-1-8-4-3"></a>训练工具<br  /><div class="outline-text-5" id="text-1-8-4-3">
<ul class="org-ul">
<li>nnet-init: Initialize the neural network from a config file with a line for each component
</li>
<li>nnet-am-init: 好像只把nnet,tree, topo写到一个文件了
</li>
<li>nnet-get-egs: 生成examples(准备网络输入格式的数据，上下文特征,pdf标签)
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp">ProcessFile(feats, pdf_post, key, left_context, right_context, const_feat_dim,
keep_proportion, &amp;num_frames_written, &amp;example_writer)
<span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">i</span> = 0; i &lt; feats.NumRows(); i++) {
<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">count</span> = GetCount(keep_proportion); <span style="color: #b22222;">// </span><span style="color: #b22222;">number of times</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">we'll write this out (1 by default).</span>
<span style="color: #a020f0;">if</span> (count &gt; 0) {
<span style="color: #b22222;">// </span><span style="color: #b22222;">Set up "input_frames".</span>
<span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">j</span> = -left_context; j &lt;= right_context; j++) {
<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">j2</span> = j + i;
<span style="color: #a020f0;">if</span> (j2 &lt; 0) j2 = 0;
<span style="color: #a020f0;">if</span> (j2 &gt;= feats.NumRows()) j2 = feats.NumRows() - 1;
<span style="color: #228b22;">SubVector</span>&lt;BaseFloat&gt; <span style="color: #a0522d;">src</span>(feats.Row(j2), 0, basic_feat_dim),
<span style="color: #a0522d;">dest</span>(input_frames, j + left_context);
dest.CopyFromVec(src);
}
eg.labels = pdf_post[i];
eg.input_frames = input_frames;
<span style="color: #a020f0;">if</span> (const_feat_dim &gt; 0) {
<span style="color: #b22222;">// </span><span style="color: #b22222;">we'll normally reach here if we're using online-estimated iVectors.</span>
<span style="color: #228b22;">SubVector</span>&lt;BaseFloat&gt; <span style="color: #a0522d;">const_part</span>(feats.Row(i),
basic_feat_dim, const_feat_dim);
eg.spk_info.CopyFromVec(const_part);
}
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">ostringstream</span> <span style="color: #a0522d;">os</span>;
os &lt;&lt; utt_id &lt;&lt; <span style="color: #8b2252;">"-"</span> &lt;&lt; i;


<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">string</span> <span style="color: #a0522d;">key</span> = os.str(); <span style="color: #b22222;">// </span><span style="color: #b22222;">key is &lt;utt_id&gt;-&lt;frame_id&gt;</span>


<span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">c</span> = 0; c &lt; count; c++)
example_writer-&gt;Write(key, eg);
}
}
</pre>
</div>
<ul class="org-ul">
<li>nnet-shuffle-egs: from the input to output, but randomly shuffle the order
</li>
<li>nnet-subset-egs: Creates a random subset of the input examples, of a specified size
</li>
<li>nnet-train-transitions
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">SetPriors</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">TransitionModel</span> &amp;<span style="color: #a0522d;">tmodel</span>,
               <span style="color: #a020f0;">const</span> <span style="color: #228b22;">Vector</span>&lt;<span style="color: #228b22;">double</span>&gt; &amp;<span style="color: #a0522d;">transition_accs</span>,
               <span style="color: #228b22;">double</span> <span style="color: #a0522d;">prior_floor</span>,
               <span style="color: #228b22;">AmNnet</span> *<span style="color: #a0522d;">am_nnet</span>) {
  KALDI_ASSERT(tmodel.NumPdfs() == am_nnet-&gt;NumPdfs());
  <span style="color: #228b22;">Vector</span>&lt;BaseFloat&gt; <span style="color: #a0522d;">pdf_counts</span>(tmodel.NumPdfs());
  KALDI_ASSERT(transition_accs(0) == 0.0); <span style="color: #b22222;">// </span><span style="color: #b22222;">There is</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">no zero transition-id.</span>
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">tid</span> = 1; tid &lt; transition_accs.Dim(); tid++) {
    <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">pdf</span> = tmodel.TransitionIdToPdf(tid);
    pdf_counts(pdf) += transition_accs(tid);
  }
  <span style="color: #228b22;">BaseFloat</span> <span style="color: #a0522d;">sum</span> = pdf_counts.Sum();
  KALDI_ASSERT(sum != 0.0);
  KALDI_ASSERT(prior_floor &gt; 0.0 &amp;&amp; prior_floor &lt; 1.0);
  <span style="color: #b22222;">//</span><span style="color: #b22222;">&#24402;&#19968;&#21270;</span>
  pdf_counts.Scale(1.0 / sum);
  pdf_counts.ApplyFloor(prior_floor);
  pdf_counts.Scale(1.0 / pdf_counts.Sum()); <span style="color: #b22222;">// </span><span style="color: #b22222;">normalize again.</span>
  am_nnet-&gt;SetPriors(pdf_counts);
}
</pre>
</div>
<ul class="org-ul">
<li>nnet-train-simple
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b22222;">//</span><span style="color: #b22222;">&#40664;&#35748;minibatch(1024)&#65292;&#36798;&#21040;minibatch-size&#26102;&#22788;&#29702;</span>
<span style="color: #228b22;">NnetSimpleTrainer</span> <span style="color: #0000ff;">trainer</span>(train_config,&amp;(am_nnet.GetNnet())); 
<span style="color: #228b22;">SequentialNnetExampleReader</span> <span style="color: #0000ff;">example_reader</span>(examples_rspecifier); 
<span style="color: #a020f0;">for</span> (; !example_reader.Done(); example_reader.Next(), num_examples++) 
    trainer.TrainOnExample(example_reader.Value()); <span style="color: #b22222;">// </span><span style="color: #b22222;">It all happens here!</span>
</pre>
</div>
<ul class="org-ul">
<li>nnet-train-parallel
</li>
</ul>
</div>
</li>
<li><a id="sec-1-8-4-4" name="sec-1-8-4-4"></a>解码<br  /><ol class="org-ol"><li><a id="sec-1-8-4-4-1" name="sec-1-8-4-4-1"></a>nnet2/decode.sh<br  /><div class="outline-text-6" id="text-1-8-4-4-1">
<ul class="org-ul">
<li>nnet-latgen-faste
</li>
</ul>
</div>
</li></ol>
</li></ol>
</div>
</div>
<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> Getting Results</h3>
<div class="outline-text-3" id="text-1-9">
<p>
运行RESULTS文件， RESULTS中含有统计识别率脚本和标准测试结果
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> kaldi中的数据文件及其作用</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 数据准备(其中大部分文件均需要排序)</h3>
<div class="outline-text-3" id="text-2-1">
</div><div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> Required(Must provide)</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
在数据准备过程中，必须准备并在以后训练过程中必须存在的有以下文件，注意啦
</p>
<ul class="org-ul">
<li>train.uttid test.uttid (data/local/data)
</li>
</ul>
<pre class="example">
作用: 文件唯一标识符
格式: 
FAEM0_SI1392
FAEM0_SI2022
</pre>
<ul class="org-ul">
<li>train_wav.scp test_wav.scp dev_wav.scp(data/local/data)
</li>
</ul>
<pre class="example">
作用: 数据文件列表
格式: FBMJ0_SI815 /home/robin1001/kaldi/kaldi-trunk/egs/timit/s5/../../../tools/sph2pipe_v2.5/sph2pipe -f wav /home/robin1001/data/timit/TIMIT/TRAIN/DR4/FBMJ0/SI815.WAV |
</pre>
<ul class="org-ul">
<li>train.text test.text dev.text(data/local/data)
</li>
</ul>
<pre class="example">
作用: 抄本, 注意sil扩展
格式: FAEM0_SI1392 sil ax s uw m f ao r ix vcl z ae m cl p uh l ax s n vcl d f iy l vcl s sil
</pre>
<ul class="org-ul">
<li>train.utt2spk train.spk2utt(data/local/data)
</li>
</ul>
<pre class="example">
作用: 说话人信息到uttid
使用: 1. 计算cmvn时, compute-cmvn-stats使用spk2uut
格式: 
utt2spk: FAEM0 FAEM0_SI1392 FAEM0_SI2022 FAEM0_SI762 FAEM0_SX132 FAEM0_SX222 FAEM0_SX312 FAEM0_SX402 FAEM0_SX42
spk2utt: FAEM0_SI1392 FAEM0
</pre>
<p>
<b>以上内容在format_data时会被分类整理在data/train, data/test, data/dev目录下,整理时名称可能会有改变</b>
</p>
</div>
</div>

<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> Timit Required</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
以下文件timit也准备了，对于其他任务不一定必须，在此仅列出
</p>
<ul class="org-ul">
<li>train.spk2gender(data/local/data)
</li>
</ul>
<pre class="example">
作用: 说话人到性别信息
使用: 没有看到
格式: 
FAEM0 f
FAJW0 f
</pre>
<ul class="org-ul">
<li>train_dur.ark(data/local/data)
</li>
</ul>
<pre class="example">
作用: 训练数据时长信息
使用: 没有看到
格式: 
FAEM0_SI1392 4.761625 
FAEM0_SI2022 2.252812
</pre>
<ul class="org-ul">
<li>train.stm(data/local/data)
</li>
</ul>
<pre class="example">
作用: 扩展形式的超本，加入说话人，性别，时长信息
使用: stm和gtm这玩意儿timit独有，和解码时还有关系
格式: 
;; LABEL "O" "Overall" "Overall"
;; LABEL "F" "Female" "Female speakers"
;; LABEL "M" "Male" "Male speakers"
FAEM0_SI1392 1 FAEM0 0.0 4.761625 &lt;O,M&gt;  sil ax s uw m f ae n vcl d f iy l vcl s sil
</pre>
<ul class="org-ul">
<li>train.glm(data/local/data)
</li>
</ul>
<pre class="example">
作用: 这是啥？
格式: 所有内容都在这儿
;; empty.glm
  [FAKE]     =&gt;  %HESITATION     / [ ] __ [ ] ;; hesitation token
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 字典准备</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>silence_phones.txt nonsilence_phones.txt(data/local/dict)
</li>
</ul>
<pre class="example">
作用: 静音音素和非静音音素，两个互斥的集合 
格式:
sil
----------------
aa
bb
</pre>
<ul class="org-ul">
<li>phones.txt(data/local/dict)
</li>
</ul>
<pre class="example">
使用: silence_phones.txt (U) nonsilence_phones.txt
格式:
aa
ae
...
sil
...
zh
</pre>
<ul class="org-ul">
<li>optinal_silence.txt
</li>
</ul>
<pre class="example">
作用: 可选静音列表，在发音字典fst中，可选的让该phone出现在每段发音段首或者词尾
      根据任务而定，可选的sil, spn
格式:
sil
----------------
aa
bb
</pre>
<ul class="org-ul">
<li>lexicon.txt(data/local/dict)
</li>
</ul>
<pre class="example">
作用: 词典
格式: 此处因为timit是音素级的抄本，所以lexicon长这样
aa	aa
ae	ae
ah	ah
----------------
阿爸 a1 ba4
</pre>
<ul class="org-ul">
<li>extra_questions.txt(data/local/dict)
</li>
</ul>
<pre class="example">
作用: 初始的问题集，分为sil和其他两类
使用: cat $lang/phones/extra_questions.int &gt;&gt; $dir/questions.int
格式: 
sil 
aa ae ah ao aw ax ay b ch cl d dh dx eh el en epi er ey f g hh ih ix iy jh k l m n ng ow oy p r s sh t th uh uw v vcl w y z zh
</pre>
<ul class="org-ul">
<li>lm_train.text(data/local/data)
</li>
</ul>
<pre class="example">
作用: 格式化抄本，添加语言模型的&lt;s&gt;&amp;&lt;/s&gt;
格式: 
&lt;s&gt; sil w ah dx aw f ix cl d uh sh iy vcl d r ay v f ao sil &lt;/s&gt;
&lt;s&gt; sil f ih l s epi m ao l hh ow l ix n vcl b ow l w ih th cl k l ey sil &lt;/s&gt;
使用: 去除uutid，作为build-lm.sh输入
</pre>
<ul class="org-ul">
<li>lm_phone_bg.arpa.gz(data/local/nist_lm)
</li>
</ul>
<pre class="example">
作用:编译并压缩后的语言模型
格式：
\data\
ngram  1=        51
ngram  2=      1694 

\1-grams:
-4.8574 &lt;s&gt; -2.96614
-1.24019    sil -2.27704
-1.56815    ax  -2.02608
...
\2-grams:
-0.000442966    &lt;s&gt; sil
-3.37261    sil sil
-1.83346    sil ax
-1.62848    sil s
-3.71728    sil uw
使用: format_data生成G.fst
</pre>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> lang(此处有个中间文件utils/apply_map.pl phone_map）</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>sets.txt sets.int(data/lang/phones)
</li>
</ul>
<pre class="example">
使用: 1. shared_phones_opt=set.int, gmm-init-mono
格式: 
sil
aa
...
------------
1
2
...
</pre>
<ul class="org-ul">
<li>root.txt (data/lang/phones)
</li>
</ul>
<pre class="example">
作用: 哪些音素共享根 
格式:
shared split sil
shared split aa
shared split ae
-----------------
shared split 1
shared split 2
shared split 3
</pre>
<ul class="org-ul">
<li>oov.txt oov.int(data/lang)
</li>
</ul>
<pre class="example">
作用: 将词汇表以外词映射到该词，所以其在也仅在compile-train-graphs作为输入
格式:
sil
------------
38
</pre>
<ul class="org-ul">
<li>silence.txt,nonsilence.txt, silence.int, nonsilence.int(data/lang/phones)
</li>
</ul>
<pre class="example">
作用: 
格式: 估计你都猜到了，不粘了
silence.csl
1
nonsilencs.csl
2:3:4:5:6:7:8:9:10:11:12:13:14:15:16:17:18:19:20:21:22:23:24:25:26:27:28:29:30:31:32:33:34:35:36:37:38:39:40:41:42:43:44:45:46:47:48
</pre>
<ul class="org-ul">
<li>disambig.txt(data/lang/phones)
</li>
</ul>
<pre class="example">
作用: fst的两个辅助消歧符号
格式: 
#0
#1
</pre>
<ul class="org-ul">
<li>phones.txt(data/lang/phones.txt)
</li>
</ul>
<pre class="example">
作用: openfst形式isymbol-map
格式: 
&lt;eps&gt; 0
sil 1
aa 2
ae 3
...
#0 49
#1 50
</pre>
<ul class="org-ul">
<li>word_boundary.txt(没有用到)
</li>
<li>words.txt
</li>
</ul>
<pre class="example">
作用: openfst形式isymbol-map
使用: 解码时--word-symbol-table=words.txt
格式: 
&lt;eps&gt; 0
aa 1
ae 2
ah 3
...
#0 49
</pre>
<ul class="org-ul">
<li>context_indep.txt
</li>
</ul>
<pre class="example">
包含一个音素列表，用于建立文本无关模型，即不会建立上下文决策树。
一般有静音SIL，口语噪音SPN，非口语噪音NSN，笑声LAU
经验：把噪声和发声噪声都列为静音音素，而把其他传统音素列为非静音因素
</pre>
<ul class="org-ul">
<li>lexiconp.txt(data/local/dict)
</li>
</ul>
<pre class="example">
作用: 
格式: 
aa	1.0	aa
ae	1.0	ae
ah	1.0	ah
</pre>
<ul class="org-ul">
<li>L.fst L.disambig.fst(data/lang)
</li>
</ul>
<div class="org-src-container">

<pre class="src src-sh">utils/make_lexicon_fst.pl --pron-probs $<span style="color: #a0522d;">tmpdir</span>/lexiconp.txt $<span style="color: #a0522d;">sil_prob</span> $<span style="color: #a0522d;">silphone</span> | <span style="color: #8b2252;">\</span>
  fstcompile --isymbols=$<span style="color: #a0522d;">dir</span>/phones.txt --osymbols=$<span style="color: #a0522d;">dir</span>/words.txt <span style="color: #8b2252;">\</span>
  --keep_isymbols=false --keep_osymbols=false | <span style="color: #8b2252;">\</span>
   fstarcsort --sort_type=olabel &gt; $<span style="color: #a0522d;">dir</span>/L.fst || <span style="color: #a020f0;">exit</span> 1;
</pre>
</div>
<pre class="example">
使用: 1. compile-train-graph，为训练语句编译fst, 如exp/x/fsts.JOB.gz
      2. 解码时生成HCLG.fst, 使用的是L.disambig.fst
fst状态转换
0	1	&lt;eps&gt;	&lt;eps&gt;	0.693147180559945
0	1	sil	&lt;eps&gt;	0.693147180559945
2	1	sil	&lt;eps&gt;
1	1	aa	aa	0.693147180559945
1	2	aa	aa	0.693147180559945
1	1	ae	ae	0.693147180559945
1	2	ae	ae	0.693147180559945
1	1	ah	ah	0.693147180559945
1	2	ah	ah	0.693147180559945
1	1	ao	ao	0.693147180559945
1	2	ao	ao	0.693147180559945
1	1	aw	aw	0.693147180559945
1	2	aw	aw	0.693147180559945
1	1	ax	ax	0.693147180559945
1	2	ax	ax	0.693147180559945
1	1	ay	ay	0.693147180559945
1	2	ay	ay	0.693147180559945
1	1	b	b	0.693147180559945
...
1	1	zh	zh	0.693147180559945
1	2	zh	zh	0.693147180559945
1	0
</pre>
<ul class="org-ul">
<li>topo(data/lang)
</li>
</ul>
<pre class="example">
作用: HMM集合及其拓扑结构
使用: 1. 训练过程中模型的初始化，如gmm-init-mono
      2. 获取问题集compile-questions
格式:
&lt;Topology&gt;
&lt;TopologyEntry&gt;
&lt;ForPhones&gt;
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48
&lt;/ForPhones&gt;
&lt;State&gt; 0 &lt;PdfClass&gt; 0 &lt;Transition&gt; 0 0.75 &lt;Transition&gt; 1 0.25 &lt;/State&gt;
&lt;State&gt; 1 &lt;PdfClass&gt; 1 &lt;Transition&gt; 1 0.75 &lt;Transition&gt; 2 0.25 &lt;/State&gt;
&lt;State&gt; 2 &lt;PdfClass&gt; 2 &lt;Transition&gt; 2 0.75 &lt;Transition&gt; 3 0.25 &lt;/State&gt;
&lt;State&gt; 3 &lt;/State&gt;
&lt;/TopologyEntry&gt;
&lt;TopologyEntry&gt;
&lt;ForPhones&gt;
1
&lt;/ForPhones&gt;
&lt;State&gt; 0 &lt;PdfClass&gt; 0 &lt;Transition&gt; 0 0.5 &lt;Transition&gt; 1 0.5 &lt;/State&gt;
&lt;State&gt; 1 &lt;PdfClass&gt; 1 &lt;Transition&gt; 1 0.5 &lt;Transition&gt; 2 0.5 &lt;/State&gt;
&lt;State&gt; 2 &lt;PdfClass&gt; 2 &lt;Transition&gt; 2 0.75 &lt;Transition&gt; 3 0.25 &lt;/State&gt;
&lt;State&gt; 3 &lt;/State&gt;
&lt;/TopologyEntry&gt;
&lt;/Topology&gt;
</pre>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> format_data</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>format
</li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="right">id</td>
<td class="left">src</td>
<td class="left">dest</td>
</tr>

<tr>
<td class="right">1</td>
<td class="left">train_wav.scp</td>
<td class="left">train/wav.scp</td>
</tr>

<tr>
<td class="right">2</td>
<td class="left">train.text</td>
<td class="left">train/text</td>
</tr>

<tr>
<td class="right">3</td>
<td class="left">train.spk2utt</td>
<td class="left">train/spk2uut</td>
</tr>

<tr>
<td class="right">4</td>
<td class="left">train.spk2gen</td>
<td class="left">train/spk2gender</td>
</tr>

<tr>
<td class="right">5</td>
<td class="left">train.stm</td>
<td class="left">train/stm</td>
</tr>

<tr>
<td class="right">6</td>
<td class="left">train.glm</td>
<td class="left">train/glm</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>G.fst
</li>
</ul>
<pre class="example">
格式:
0   1   &lt;s&gt; &lt;s&gt;
1   2   &lt;eps&gt;   &lt;eps&gt;   6.82978964
1   3   sil sil 0.00101996691
2   3   sil sil 2.85564303
2   4   ax  ax  3.61079884
2   5   s   s   3.14913034
2   6   uw  uw  4.3006072
2   7   m   m   3.69825077
2   8   f   f   4.17426443
2   9   ao  ao  4.34617519
2   10  r   r   3.42624664
2   11  ix  ix  2.97240686
2   12  vcl vcl 2.99313045
2   13  z   z   3.66624475
2   14  ae  ae  4.14011717
2   15  cl  cl  2.44272041
2   16  p   p   4.01870155
</pre>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> 特征提取</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>raw_mfcc_train.1.scp raw_mfcc_train.1.ark(mfcc)
</li>
</ul>
<pre class="example">
格式: scp
FADG0_SI1279 /home/robin1001/kaldi/kaldi-trunk/egs/timit/s5/mfcc/raw_mfcc_dev.1.ark:13
FADG0_SI1909 /home/robin1001/kaldi/kaldi-trunk/egs/timit/s5/mfcc/raw_mfcc_dev.1.ark:2491
</pre>
<ul class="org-ul">
<li>feats.scp(data/{train, test, dev})
</li>
</ul>
<pre class="example">
作用: 由并行提到特征文件合成所有的特征列表
</pre>
<ul class="org-ul">
<li>cmvn_train.scp cmvn_train.ark
</li>
</ul>
<div class="org-src-container">

<pre class="src src-sh">compute-cmvn-stats --spk2utt=ark:$<span style="color: #a0522d;">data</span>/spk2utt scp:$<span style="color: #a0522d;">data</span>/feats.scp ark,scp:$<span style="color: #a0522d;">cmvndir</span>/cmvn_$<span style="color: #a0522d;">name</span>.ark,$<span style="color: #a0522d;">cmvndir</span>/cmvn_$<span style="color: #a0522d;">name</span>.scp
</pre>
</div>
<pre class="example">
作用: 统计每个说话人的cmvn信息
格式:
FAPB0 /home/robin1001/kaldi/kaldi-trunk/egs/timit/s5/mfcc/cmvn_train.ark:986
FBAS0 /home/robin1001/kaldi/kaldi-trunk/egs/timit/s5/mfcc/cmvn_train.ark:1231
</pre>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> 决策树</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>question.int question.txt
</li>
</ul>
<pre class="example">
sil 
sil b ch cl d dh dx epi f g hh jh k p s sh t th v vcl z zh 
sil ch f s sh z 
aa 
aa ae ah ao aw ax ay eh el en er ey ih ix iy l m n ng ow oy r uh uw w y 
aa ae ao aw ay eh ey ih iy ow y 
aa ae ao aw ay ow 
aa ao 
aa ao ow 
ae 
ae aw 
ae aw ay 
ah 
ah ax el en er ix l m n ng oy r uh uw w 
ah ax er ix oy r uh uw 
ah ax ix uh 
ah ax ix uh uw 
ah ax uh
</pre>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7"><span class="section-number-3">2.7</span> 训练</h3>
<div class="outline-text-3" id="text-2-7">
<ul class="org-ul">
<li>x.mdl find.mdl(exp/x/)
</li>
</ul>
<pre class="example">
格式:
&lt;TransitionModel&gt; 
&lt;Topology&gt; 
&lt;TopologyEntry&gt; 
&lt;ForPhones&gt; 
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 
&lt;/ForPhones&gt; 
&lt;State&gt; 0 &lt;PdfClass&gt; 0 &lt;Transition&gt; 0 0.75 &lt;Transition&gt; 1 0.25 &lt;/State&gt; 
&lt;State&gt; 1 &lt;PdfClass&gt; 1 &lt;Transition&gt; 1 0.75 &lt;Transition&gt; 2 0.25 &lt;/State&gt; 
&lt;State&gt; 2 &lt;PdfClass&gt; 2 &lt;Transition&gt; 2 0.75 &lt;Transition&gt; 3 0.25 &lt;/State&gt; 
&lt;State&gt; 3 &lt;/State&gt; 
&lt;/TopologyEntry&gt; 
&lt;TopologyEntry&gt; 
&lt;ForPhones&gt; 
1 
&lt;/ForPhones&gt; 
&lt;State&gt; 0 &lt;PdfClass&gt; 0 &lt;Transition&gt; 0 0.5 &lt;Transition&gt; 1 0.5 &lt;/State&gt; 
&lt;State&gt; 1 &lt;PdfClass&gt; 1 &lt;Transition&gt; 1 0.5 &lt;Transition&gt; 2 0.5 &lt;/State&gt; 
&lt;State&gt; 2 &lt;PdfClass&gt; 2 &lt;Transition&gt; 2 0.75 &lt;Transition&gt; 3 0.25 &lt;/State&gt; 
&lt;State&gt; 3 &lt;/State&gt; 
&lt;/TopologyEntry&gt; 
&lt;/Topology&gt; 
&lt;Triples&gt; 1967 
1 0 0 
1 1 51 
1 2 48 
2 0 1 
2 0 169 
2 0 286 
...
&lt;/LogProbs&gt; 
&lt;/TransitionModel&gt; 
&lt;DIMENSION&gt; 39 &lt;NUMPDFS&gt; 1921 &lt;DiagGMM&gt; 
&lt;GCONSTS&gt;  [ -95.17706 -81.32135 -151.1496 -92.49072 -76.49657 -73.69149 -125.8088 -83.51283 -104.7302 -87.7104 -85.27476 -84.29331 -74.78059 -115.8744 -80.226
36 -93.32332 -95.39783 -128.1057 -80.69289 -94.86904 -77.14107 -125.0487 -85.18453 -80.24683 -80.09453 -115.6893 ]
&lt;WEIGHTS&gt;  [ 0.0376287 0.03753155 0.03834436 0.04315818 0.05027013 0.04145537 0.03278675 0.04632599 0.04273623 0.03133279 0.04082224 0.04645732 0.03122336 0.02
904686 0.03832259 0.04545283 0.04021866 0.041621 0.04777169 0.03450852 0.04088681 0.03478571 0.03945986 0.03233045 0.0284235 0.02709854 ]
&lt;MEANS_INVVARS&gt;  [
  -0.2801608 -0.07388612 0.05452524 -0.0001664911 0.1077678 0.09175234 0.08498141 0.09413936 0.020672 0.02511335 0.006077958 -0.0216168 0.008959025 -0.5031475 
-0.41583 -0.2404581 -0.1
...
</pre>
<ul class="org-ul">
<li>tree(exp/x)
</li>
</ul>
<pre class="example">
作用: 三音素决策树
格式:
ContextDependency 3 1 ToPdf TE 1 49 ( NULL SE -1 [ 0 1 ]
{ SE -1 [ 0 ]
{ CE 0 CE 51 } 
CE 48 } 
SE -1 [ 0 ]
{ SE 0 [ 1 9 10 11 12 13 14 18 21 22 23 27 28 35 37 38 39 40 43 44 47 48 ]
{ SE 0 [ 1 ]
{ CE 1 SE 2 [ 19 34 36 ]
{ SE 0 [ 21 ]
{ CE 1268 SE 0 [ 9 12 13 23 35 ]
{ SE 0 [ 9 12 13 ]
</pre>
<ul class="org-ul">
<li>exp/x/fsts.JOB.gz
</li>
</ul>
<pre class="example">
作用: 为每个训练语句由L.fst编译fst
</pre>
<ul class="org-ul">
<li>exp/x/i.JOB.acc
</li>
</ul>
<pre class="example">
作用: 对齐信息
格式:
trn_adg04_sr249 285 283 283 283 283 283 283 283 283 291 292 292 292 292 292 292
290 300 299 266 265 265 265 268 267 270 269 269 269 14 16 18 230 229 232 231 234
146 145 145 145 148 147 150 149 149 149 149 149 104 103 106 108 107 107 107 194
196 195 195 198 197 32 31 34 33 36 35 44 43 43 43 46 45 48 128 130 129 129 132
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> kaldi doc</h2>
<div class="outline-text-2" id="text-3">
<p>
这里主要是kaldi官网上的重点摘记。
</p>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> kaldi tutorial</h3>
<div class="outline-text-3" id="text-3-1">
</div><div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1"><span class="section-number-4">3.1.1</span> Reading and modifying the code</h4>
<div class="outline-text-4" id="text-3-1-1">
<ul class="org-ul">
<li>kaldi中使用-O0,调试可以使用gdb调试
</li>
<li>可以在Makefile TESTFILES中添加自己的test，然后make test
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Kaldi I/O mechanisms</h3>
<div class="outline-text-3" id="text-3-2">
<ol class="org-ol">
<li>binary vs text: binary start '\0B'
</li>
<li>ark,t: t in text format
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> The Kaldi Matrix library</h3>
<div class="outline-text-3" id="text-3-3">
<p>
kaldi的Matrix库为BLAS &amp; LAPACK线性代数库的包装。
</p>
</div>
<div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1"><span class="section-number-4">3.3.1</span> Matrix &amp; Vector</h4>
<div class="outline-text-4" id="text-3-3-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #228b22;">Vector</span>&lt;<span style="color: #228b22;">float</span>&gt; <span style="color: #0000ff;">v</span>(10), <span style="color: #0000ff;">w</span>(9);
<span style="color: #a020f0;">for</span>(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span>=0; i &lt; 9; i++) {
   v(i) = i; 
   w(i) = i+1;
}
<span style="color: #228b22;">Matrix</span>&lt;<span style="color: #228b22;">float</span>&gt; <span style="color: #0000ff;">M</span>(10,9);
M.AddVecVec(1.0, v, w);
<span style="color: #b22222;">//</span><span style="color: #b22222;">A = beta * A + alpha * B * C; B,C&#26159;&#21542;&#36716;&#32622;&#30001;kNoTrans&#21644;kTrans&#20915;&#23450;</span>
A.AddMatMat(alpha, B, kNoTrans, C, kTrans, beta);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2"><span class="section-number-4">3.3.2</span> Sub-vectors &amp; Sub-matrices</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
子向量和矩阵，类似matlab或python中的矩阵切片, SubVector和SubMatrix不能Resize。
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #228b22;">Vector</span>&lt;<span style="color: #228b22;">float</span>&gt; <span style="color: #0000ff;">v</span>(10), <span style="color: #0000ff;">w</span>(10);
<span style="color: #228b22;">Matrix</span>&lt;<span style="color: #228b22;">float</span>&gt; <span style="color: #0000ff;">M</span>(10, 10);
<span style="color: #228b22;">SubVector</span>&lt;<span style="color: #228b22;">float</span>&gt; <span style="color: #0000ff;">vs</span>(v, 1, 9), <span style="color: #0000ff;">ws</span>(w, 1, 9);
<span style="color: #228b22;">SubMatrix</span>&lt;<span style="color: #228b22;">float</span>&gt; <span style="color: #0000ff;">Ms</span>(M, 1, 9, 1, 9);
<span style="color: #b22222;">// </span><span style="color: #b22222;">next line would be v(2:10) += M(2:10,2:10)*w(2:10) in some</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">matrix multiply &amp; add</span>
vs.AddMatVec(1.0, Ms, kNoTrans, ws); vs = 1.0 * Ms * ws

<span style="color: #b22222;">//</span><span style="color: #b22222;">&#20999;&#29255;&#25805;&#20316;</span>
SubVector row_of_m(M, 0); <span style="color: #b22222;">// </span><span style="color: #b22222;">M.Row(3), return SubVector</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">get a sub-vector of length 5 starting from position 0; zero it.</span>
v.Range(0, 5).SetZero();
<span style="color: #b22222;">// </span><span style="color: #b22222;">get a sub-matrix of size 2x2 starting from position (5,5); zero it.</span>
M.Range(5, 2, 5, 2).SetZero();
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-3" class="outline-4">
<h4 id="sec-3-3-3"><span class="section-number-4">3.3.3</span> Copy</h4>
<div class="outline-text-4" id="text-3-3-3">
<p>
The simplest ones are the CopyFrom functions, for instance Matrix::CopyFromMat, Vector::CopyFromVec.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> The build process(how Kaldi is compiled)</h3>
<div class="outline-text-3" id="text-3-4">
</div><div id="outline-container-sec-3-4-1" class="outline-4">
<h4 id="sec-3-4-1"><span class="section-number-4">3.4.1</span> kaldi.mk</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>默认编译选项：-g -O0 -DKALDI_PARANOID
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4-2" class="outline-4">
<h4 id="sec-3-4-2"><span class="section-number-4">3.4.2</span> Makefile</h4>
<div class="outline-text-4" id="text-3-4-2">
<ul class="org-ul">
<li>make test 
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> Parsing command-line Options</h3>
<div class="outline-text-3" id="text-3-5">
</div><div id="outline-container-sec-3-5-1" class="outline-4">
<h4 id="sec-3-5-1"><span class="section-number-4">3.5.1</span> parse-option(util, ParseOption类)</h4>
<div class="outline-text-4" id="text-3-5-1">
<ul class="org-ul">
<li>Read()
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> Decoders used in the Kaldi toolkit</h3>
<div class="outline-text-3" id="text-3-6">
<p>
详见kaldi部分代码解析之解码。
</p>
</div>
</div>
<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7"><span class="section-number-3">3.7</span> HMM topology and transition modeling</h3>
<div class="outline-text-3" id="text-3-7">
</div><div id="outline-container-sec-3-7-1" class="outline-4">
<h4 id="sec-3-7-1"><span class="section-number-4">3.7.1</span> HMM topology</h4>
<div class="outline-text-4" id="text-3-7-1">
<pre class="example">
&lt;Topology&gt;
&lt;TopologyEntry&gt;
&lt;ForPhones&gt; 1 2 3 4 5 6 7 8 &lt;/ForPhones&gt;
&lt;State&gt; 0 &lt;PdfClass&gt; 0
&lt;Transition&gt; 0 0.5
&lt;Transition&gt; 1 0.5
&lt;/State&gt; 
&lt;State&gt; 1 &lt;PdfClass&gt; 1 
&lt;Transition&gt; 1 0.5
&lt;Transition&gt; 2 0.5
&lt;/State&gt;  
&lt;State&gt; 2 &lt;PdfClass&gt; 2
&lt;Transition&gt; 2 0.5
&lt;Transition&gt; 3 0.5
&lt;/State&gt;   
&lt;State&gt; 3
&lt;/State&gt;   
&lt;/TopologyEntry&gt;
&lt;/Topology&gt;
</pre>
<ul class="org-ul">
<li>pdfclass index
</li>
<li>状态3无pdf
</li>
<li>code
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">HmmState</span> {
    <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">pdf_class</span>;
    <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">pair</span>&lt;<span style="color: #228b22;">int32</span>, BaseFloat&gt; &gt; <span style="color: #a0522d;">transitions</span>;
};
<span style="color: #a020f0;">typedef</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">HmmState</span>&gt; <span style="color: #228b22;">TopologyEntry</span>;
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">HmmTopology</span>{
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">int32</span>&gt; <span style="color: #a0522d;">phones_</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#25490;&#24207;&#30340;&#38899;&#32032;topo&#38598;&#21512;</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">int32</span>&gt; <span style="color: #a0522d;">phone2idx_</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#38899;&#32032;&#21040;hmm topo&#32467;&#26500;&#30340;&#26144;&#23556;</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">TopologyEntry</span>&gt; <span style="color: #a0522d;">entries_</span>; <span style="color: #b22222;">//</span><span style="color: #b22222;">topo</span>
};
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-7-2" class="outline-4">
<h4 id="sec-3-7-2"><span class="section-number-4">3.7.2</span> Pdf-classes</h4>
</div>
<div id="outline-container-sec-3-7-3" class="outline-4">
<h4 id="sec-3-7-3"><span class="section-number-4">3.7.3</span> Transition models (the TransitionModel object)</h4>
<div class="outline-text-4" id="text-3-7-3">
<pre class="example">
//             (phone, HMM-state, pdf-id) -&gt; transition-state
//   (transition-state, transition-index) -&gt; transition-id
 The most "natural" FST-based setups would have what we call pdf-ids on
 the input labels. However, bearing in mind that given our tree-building
 algorithms it will not always be possible to map uniquely from a pdf-id
 to a phone, this would make it hard to map from an input-label sequence
 to a phone sequence, and this is inconvenient for a number of reasons;
 it would also make it hard in general to train the transition probabilities
 using the information in the FST alone. For this reason we put identifiers
 called transition-ids on the input labels of the FST, and these can be mapped
 to the pdf-id but also to the phone and to a particular transition in a
 prototype HMM (as given in the HmmTopology object).
</pre>
<p>
why???
</p>
<ul class="org-ul">
<li>将HMM和GMMS(am-diag-gmm)连接起来
</li>
<li>The most "natural" FST-based setups would have what we call pdf-ids on the input labels.
</li>
</ul>
</div>

<ol class="org-ol"><li><a id="sec-3-7-3-0-1" name="sec-3-7-3-0-1"></a>Integer identifiers used by TransitionModel<br  /><div class="outline-text-6" id="text-3-7-3-0-1">
<ol class="org-ol">
<li>phone: 1-based
</li>
<li>hmm-state: 0-based
</li>
<li>transition-state: 1-based
</li>
<li>transition-index 0-based
</li>
<li>transition-id: 1-based
</li>
</ol>
</div>
</li>
<li><a id="sec-3-7-3-0-2" name="sec-3-7-3-0-2"></a>transition-id as input label<br  /></li>
<li><a id="sec-3-7-3-0-3" name="sec-3-7-3-0-3"></a>Alignments in Kaldi<br  /><div class="outline-text-6" id="text-3-7-3-0-3">
<ul class="org-ul">
<li>vector&lt;int32&gt;, which contains a sequence of transition-ids
</li>
</ul>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-3-8" class="outline-3">
<h3 id="sec-3-8"><span class="section-number-3">3.8</span> How decision trees are used in Kaldi</h3>
<div class="outline-text-3" id="text-3-8">
<pre class="example">
we have a number of ways we can split the data by asking about, say, the left phone, 
the right phone, the central phone, the state we're in, and so on.
</pre>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="right" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="left">Name in code</td>
<td class="left">Name in command-line arguments</td>
<td class="right">Value (triphone)</td>
<td class="right">Value (monophone)</td>
</tr>

<tr>
<td class="left">N</td>
<td class="left">–context-width=?</td>
<td class="right">3</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">P</td>
<td class="left">–central-position=?</td>
<td class="right">1</td>
<td class="right">0</td>
</tr>
</tbody>
</table>
<pre class="example">
vector&lt;int32&gt; ctx_window = { 12, 15, 21 }; 三音素树 12-15+21， 0代表没有音素
kPdfClass=-1,一个音素生成TableEventMap(kPdfClass, map)
一个音素的所有状态生成一个table，每个状态生成一个ConstEventMap,id作为key
</pre>
</div>
</div>
<div id="outline-container-sec-3-9" class="outline-3">
<h3 id="sec-3-9"><span class="section-number-3">3.9</span> Decoding-graph creation recipe(training time)</h3>
<div class="outline-text-3" id="text-3-9">
<pre class="example">
compile-train-graphs: 为每个语句训练一个wfst,即H*C*L*G，其中G为根据每条语句
生成的一个acceptor，利用这个fst在这个语句mfcc特征上进行解码，然后反向得到对齐
信息。
gmm-align-compiled：
具体步骤可参考：Internals of graph creation
</pre>
</div>
</div>

<div id="outline-container-sec-3-10" class="outline-3">
<h3 id="sec-3-10"><span class="section-number-3">3.10</span> Other kaldi utilities</h3>
<div class="outline-text-3" id="text-3-10">
</div><div id="outline-container-sec-3-10-1" class="outline-4">
<h4 id="sec-3-10-1"><span class="section-number-4">3.10.1</span> hash-list(util/hash-list.h)</h4>
</div>
<div id="outline-container-sec-3-10-2" class="outline-4">
<h4 id="sec-3-10-2"><span class="section-number-4">3.10.2</span> kaldi-table(util/kaldi-table)</h4>
<div class="outline-text-4" id="text-3-10-2">
<p>
实现w和r的参数解析
make valgrind
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-11" class="outline-3">
<h3 id="sec-3-11"><span class="section-number-3">3.11</span> Clustering mechanisms in Kaldi</h3>
<div class="outline-text-3" id="text-3-11">
<ul class="org-ul">
<li>Clusterable接口
</li>
<li>Clustering algorithms
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-12" class="outline-3">
<h3 id="sec-3-12"><span class="section-number-3">3.12</span> Acoustic modeling code</h3>
<div class="outline-text-3" id="text-3-12">
<ul class="org-ul">
<li>DiagGmmNormal
</li>
<li>DiagGmm 一个对角混合高斯模型
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #228b22;">Vector</span>&lt;BaseFloat&gt; <span style="color: #a0522d;">weights_</span>;        <span style="color: #b22222;">///</span><span style="color: #b22222;">&lt; weights (not log).</span>
<span style="color: #228b22;">Matrix</span>&lt;BaseFloat&gt; <span style="color: #a0522d;">inv_vars_</span>;       <span style="color: #b22222;">///</span><span style="color: #b22222;">&lt; Inverted (diagonal) variances</span>
<span style="color: #228b22;">Matrix</span>&lt;BaseFloat&gt; <span style="color: #a0522d;">means_invvars_</span>;  <span style="color: #b22222;">///</span><span style="color: #b22222;">&lt; Means times inverted variance</span>
</pre>
</div>
<p>
Merge &amp; MergeKMeans ???
</p>
<ul class="org-ul">
<li>AmDiagGmm
</li>
<li>std::vector&lt;DiagGmm*&gt; densities_;
</li>
<li>num_pdfs个混合高斯模型
</li>
<li>pdf_index混合高斯索引
</li>
<li>LogLikelihood(pdf_index): 返回某个高斯的对数似然 
</li>
<li>You can think of AmDiagGmm as a vector of type DiagGmm
</li>
<li>FullGmm: Full-covariance GMMs
</li>
<li>AmSgmm: Subspace Gaussian Mixture Models (SGMMs)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-13" class="outline-3">
<h3 id="sec-3-13"><span class="section-number-3">3.13</span> Deep Neural Networks in Kaldi</h3>
<div class="outline-text-3" id="text-3-13">
</div><div id="outline-container-sec-3-13-1" class="outline-4">
<h4 id="sec-3-13-1"><span class="section-number-4">3.13.1</span> 两种不同实现</h4>
<div class="outline-text-4" id="text-3-13-1">
<ul class="org-ul">
<li>Karel's:效果好，不并行，使用预训练和交叉验证集。
</li>
<li>Dan's: 并行，无预训练，使用固定训练轮数
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> kaldi cuda</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>是否使用cuda编译
</li>
</ul>
<pre class="example">
ldd nnet2bin/nnet-train-simple | grep cu
</pre>
<ul class="org-ul">
<li>nnet2使用cuda
</li>
</ul>
<pre class="example">
steps/nnet2/train_tanh.sh
--num-threads 1 --parallel-opts "-l gpu=1"
</pre>
<ul class="org-ul">
<li>训练时间统计
</li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">cpu/gpu</td>
<td class="left">time</td>
</tr>

<tr>
<td class="left">nnet2 cpu 16 thread</td>
<td class="left">45m</td>
</tr>

<tr>
<td class="left">nnet2 gpu</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> kaldi 部分代码解析</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 解码</h3>
<div class="outline-text-3" id="text-5-1">
</div><div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1"><span class="section-number-4">5.1.1</span> DecodableInterface</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
virtual BaseFloat LogLikelihood(int32 frame, int32 index);
virtual bool IsLastFrame(int32 frame);
virtual int32 NumIndices();
</p>
</div>
</div>

<div id="outline-container-sec-5-1-2" class="outline-4">
<h4 id="sec-5-1-2"><span class="section-number-4">5.1.2</span> SimpleDecoder</h4>
<div class="outline-text-4" id="text-5-1-2">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">Token</span> {
   <span style="color: #a020f0;">public</span>:
    <span style="color: #228b22;">Arc</span> <span style="color: #a0522d;">arc_</span>;
    <span style="color: #228b22;">Token</span> *<span style="color: #a0522d;">prev_</span>;
    <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">ref_count_</span>;
    <span style="color: #228b22;">Weight</span> <span style="color: #a0522d;">weight_</span>;
    ...
};

<span style="color: #228b22;">bool</span> <span style="color: #008b8b;">LatticeFasterDecoder</span>::<span style="color: #0000ff;">Decode</span>(<span style="color: #228b22;">DecodableInterface</span> *<span style="color: #a0522d;">decodable</span>) {
    <span style="color: #a020f0;">for</span>(<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">frame</span> = 0; !decodable.IsLastFrame(frame-1); frame++) {
        ClearToks(prev_toks_);
        <span style="color: #008b8b;">std</span>::swap(cur_toks_, prev_toks_);
        ProcessEmitting(decodable, frame);
        ProcessNonemitting();
        PruneToks(cur_toks_, beam_);
     }
}

<span style="color: #b22222;">// </span><span style="color: #b22222;">Outputs an FST corresponding to the raw, state-level</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">tracebacks.</span>
<span style="color: #228b22;">bool</span> <span style="color: #008b8b;">LatticeFasterDecoder</span>::<span style="color: #0000ff;">GetRawLattice</span>(<span style="color: #008b8b;">fst</span>::<span style="color: #228b22;">MutableFst</span>&lt;LatticeArc&gt; *<span style="color: #a0522d;">ofst</span>) <span style="color: #a020f0;">const</span> {
  <span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">LatticeArc</span> <span style="color: #228b22;">Arc</span>;
  <span style="color: #a020f0;">typedef</span> <span style="color: #008b8b;">Arc</span>::<span style="color: #228b22;">StateId</span> <span style="color: #228b22;">StateId</span>;
  <span style="color: #a020f0;">typedef</span> <span style="color: #008b8b;">Arc</span>::<span style="color: #228b22;">Weight</span> <span style="color: #228b22;">Weight</span>;
  <span style="color: #a020f0;">typedef</span> <span style="color: #008b8b;">Arc</span>::<span style="color: #228b22;">Label</span> <span style="color: #228b22;">Label</span>;
  ofst-&gt;DeleteStates();
  <span style="color: #b22222;">// </span><span style="color: #b22222;">num-frames plus one (since frames are one-based, and we have</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">an extra frame for the start-state).</span>
  <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">num_frames</span> = active_toks_.size() - 1;
  KALDI_ASSERT(num_frames &gt; 0);
  <span style="color: #b22222;">//</span><span style="color: #b22222;">&#29983;&#25104;token&#21040;id&#30340;&#26144;&#23556;&#65292; &#27599;&#19968;&#24103;&#19978;&#37117;&#26377;active token list&#65292;&#39034;&#24207;&#35775;&#38382;&#32534;&#21495;</span>
  <span style="color: #228b22;">unordered_map</span>&lt;<span style="color: #228b22;">Token</span>*, <span style="color: #228b22;">StateId</span>&gt; <span style="color: #a0522d;">tok_map</span>(num_toks_/2 + 3); <span style="color: #b22222;">// </span><span style="color: #b22222;">bucket count</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">First create all states.</span>
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">f</span> = 0; f &lt;= num_frames; f++) {
    <span style="color: #a020f0;">if</span> (active_toks_[f].toks == <span style="color: #008b8b;">NULL</span>) {
      KALDI_WARN &lt;&lt; <span style="color: #8b2252;">"GetRawLattice: no tokens active on frame "</span> &lt;&lt; f
                 &lt;&lt; <span style="color: #8b2252;">": not producing lattice.\n"</span>;
      <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
    }
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">Token</span> *<span style="color: #a0522d;">tok</span> = active_toks_[f].toks; tok != <span style="color: #008b8b;">NULL</span>; tok = tok-&gt;next)
      tok_map[tok] = ofst-&gt;AddState();
  }
  <span style="color: #b22222;">// </span><span style="color: #b22222;">Now create all arcs&#65292;&#25353;&#29031;token&#20043;&#38388;&#36339;&#36716;&#20851;&#31995;&#21152;&#19978;&#24359;Arc&#65292;&#26377;&#27809;&#26377;&#36229;&#32423;&#31616;&#21333;&#21834;&#65292;fst&#23601;&#26159;&#22909;</span>
  <span style="color: #228b22;">StateId</span> <span style="color: #a0522d;">cur_state</span> = 0; <span style="color: #b22222;">// </span><span style="color: #b22222;">we rely on the fact that we numbered these</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">consecutively (AddState() returns the numbers in order..)</span>
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">f</span> = 0; f &lt;= num_frames; f++) {
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">Token</span> *<span style="color: #a0522d;">tok</span> = active_toks_[f].toks; tok != <span style="color: #008b8b;">NULL</span>; tok = tok-&gt;next,
             cur_state++) {
      <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">ForwardLink</span> *<span style="color: #a0522d;">l</span> = tok-&gt;links;
           l != <span style="color: #008b8b;">NULL</span>;
           l = l-&gt;next) {
        <span style="color: #008b8b;">unordered_map</span>&lt;<span style="color: #228b22;">Token</span>*, <span style="color: #228b22;">StateId</span>&gt;::<span style="color: #228b22;">const_iterator</span> <span style="color: #a0522d;">iter</span> =
            tok_map.find(l-&gt;next_tok);
        <span style="color: #228b22;">StateId</span> <span style="color: #a0522d;">nextstate</span> = iter-&gt;second;
        KALDI_ASSERT(iter != tok_map.end());
        <span style="color: #228b22;">BaseFloat</span> <span style="color: #a0522d;">cost_offset</span> = 0.0;
        <span style="color: #a020f0;">if</span> (l-&gt;ilabel != 0) { <span style="color: #b22222;">// </span><span style="color: #b22222;">emitting..</span>
          KALDI_ASSERT(f &gt;= 0 &amp;&amp; f &lt; cost_offsets_.size());
          cost_offset = cost_offsets_[f];
        }
        <span style="color: #228b22;">Arc</span> <span style="color: #a0522d;">arc</span>(l-&gt;ilabel, l-&gt;olabel,
                Weight(l-&gt;graph_cost, l-&gt;acoustic_cost - cost_offset),
                nextstate);
        ofst-&gt;AddArc(cur_state, arc);
      }
      <span style="color: #a020f0;">if</span> (f == num_frames) {
        <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">map</span>&lt;<span style="color: #228b22;">Token</span>*, <span style="color: #228b22;">BaseFloat</span>&gt;::<span style="color: #228b22;">const_iterator</span> <span style="color: #a0522d;">iter</span> =
            final_costs_.find(tok);
        <span style="color: #a020f0;">if</span> (iter != final_costs_.end())
          ofst-&gt;SetFinal(cur_state, LatticeWeight(iter-&gt;second, 0));
      }
    }
  }
  KALDI_ASSERT(cur_state == ofst-&gt;NumStates());
  <span style="color: #a020f0;">return</span> (cur_state != 0);
}

<span style="color: #b22222;">//</span><span style="color: #b22222;">&#20808;&#35745;&#31639;raw lattice&#65292;&#28982;&#21518;&#29983;&#25104;&#26368;&#30701;&#36335;&#24452;&#30340;lattice</span>
<span style="color: #228b22;">bool</span> <span style="color: #008b8b;">LatticeFasterDecoder</span>::<span style="color: #0000ff;">GetBestPath</span>(<span style="color: #008b8b;">fst</span>::<span style="color: #228b22;">MutableFst</span>&lt;<span style="color: #228b22;">LatticeArc</span>&gt; *<span style="color: #a0522d;">ofst</span>) <span style="color: #a020f0;">const</span> {
  <span style="color: #008b8b;">fst</span>::<span style="color: #228b22;">VectorFst</span>&lt;<span style="color: #228b22;">LatticeArc</span>&gt; <span style="color: #a0522d;">fst</span>;
  <span style="color: #a020f0;">if</span> (!GetRawLattice(&amp;fst)) <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
  <span style="color: #b22222;">// </span><span style="color: #b22222;">std::cout &lt;&lt; "Raw lattice is:\n";</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">fst::FstPrinter&lt;LatticeArc&gt; fstprinter(fst, NULL, NULL, NULL, false, true);</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">fstprinter.Print(&amp;std::cout, "standard output");</span>
  ShortestPath(fst, ofst);
  <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
}
<span style="color: #b22222;">//</span><span style="color: #b22222;">&#30001;&#26368;&#30701;&#36335;&#24452;&#24471;&#21040;&#30340;fst&#65292;&#20854;ilabel&#23601;&#26159;alignment&#65292; &#20854;olabel&#23601;&#26159;words</span>
<span style="color: #228b22;">bool</span> <span style="color: #0000ff;">GetLinearSymbolSequence</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">Fst</span>&lt;<span style="color: #228b22;">Arc</span>&gt; &amp;<span style="color: #a0522d;">fst</span>,
                             <span style="color: #228b22;">vector</span>&lt;I&gt; *<span style="color: #a0522d;">isymbols_out</span>,
                             <span style="color: #228b22;">vector</span>&lt;I&gt; *<span style="color: #a0522d;">osymbols_out</span>,
                             <span style="color: #a020f0;">typename</span> <span style="color: #008b8b;">Arc</span>::<span style="color: #228b22;">Weight</span> *<span style="color: #a0522d;">tot_weight_out</span>) {
  <span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">typename</span> <span style="color: #008b8b;">Arc</span>::<span style="color: #228b22;">Label</span> <span style="color: #228b22;">Label</span>;
  <span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">typename</span> <span style="color: #008b8b;">Arc</span>::<span style="color: #228b22;">StateId</span> <span style="color: #228b22;">StateId</span>;
  <span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">typename</span> <span style="color: #008b8b;">Arc</span>::<span style="color: #228b22;">Weight</span> <span style="color: #228b22;">Weight</span>;

  <span style="color: #228b22;">Weight</span> <span style="color: #a0522d;">tot_weight</span> = <span style="color: #008b8b;">Weight</span>::One();
  <span style="color: #228b22;">vector</span>&lt;I&gt; <span style="color: #a0522d;">ilabel_seq</span>;
  <span style="color: #228b22;">vector</span>&lt;I&gt; <span style="color: #a0522d;">olabel_seq</span>;

  <span style="color: #228b22;">StateId</span> <span style="color: #a0522d;">cur_state</span> = fst.Start();
  <span style="color: #a020f0;">if</span> (cur_state == kNoStateId) {  <span style="color: #b22222;">// </span><span style="color: #b22222;">empty sequence.</span>
    <span style="color: #a020f0;">if</span> (isymbols_out != <span style="color: #008b8b;">NULL</span>) isymbols_out-&gt;clear();
    <span style="color: #a020f0;">if</span> (osymbols_out != <span style="color: #008b8b;">NULL</span>) osymbols_out-&gt;clear();
    <span style="color: #a020f0;">if</span> (tot_weight_out != <span style="color: #008b8b;">NULL</span>) *tot_weight_out = <span style="color: #008b8b;">Weight</span>::Zero();
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
  }
  <span style="color: #a020f0;">while</span> (1) {
    <span style="color: #228b22;">Weight</span> <span style="color: #a0522d;">w</span> = fst.Final(cur_state);
    <span style="color: #a020f0;">if</span> (w != <span style="color: #008b8b;">Weight</span>::Zero()) {  <span style="color: #b22222;">// </span><span style="color: #b22222;">is final..</span>
      tot_weight = Times(w, tot_weight);
      <span style="color: #a020f0;">if</span> (fst.NumArcs(cur_state) != 0) <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
      <span style="color: #a020f0;">if</span> (isymbols_out != <span style="color: #008b8b;">NULL</span>) *isymbols_out = ilabel_seq;
      <span style="color: #a020f0;">if</span> (osymbols_out != <span style="color: #008b8b;">NULL</span>) *osymbols_out = olabel_seq;
      <span style="color: #a020f0;">if</span> (tot_weight_out != <span style="color: #008b8b;">NULL</span>) *tot_weight_out = tot_weight;
      <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
    } <span style="color: #a020f0;">else</span> {
      <span style="color: #a020f0;">if</span> (fst.NumArcs(cur_state) != 1) <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>; <span style="color: #b22222;">//</span><span style="color: #b22222;">&#20160;&#20040;&#24847;&#24605;&#65292;&#22240;&#20026;&#36825;&#26159;&#26368;&#30701;&#36335;&#24452;&#30340;lattice</span>

      <span style="color: #228b22;">ArcIterator</span>&lt;<span style="color: #228b22;">Fst</span>&lt;<span style="color: #228b22;">Arc</span>&gt; &gt; <span style="color: #a0522d;">iter</span>(fst, cur_state);  <span style="color: #b22222;">// </span><span style="color: #b22222;">get the only arc.</span>
      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">Arc</span> &amp;<span style="color: #a0522d;">arc</span> = iter.Value();
      tot_weight = Times(arc.weight, tot_weight);
      <span style="color: #a020f0;">if</span> (arc.ilabel != 0) ilabel_seq.push_back(arc.ilabel);
      <span style="color: #a020f0;">if</span> (arc.olabel != 0) olabel_seq.push_back(arc.olabel);
      cur_state = arc.nextstate;
    }
  }
}
</pre>
</div>
<ol class="org-ol">
<li>同htk的两轮传播，词内传播和词间传播
</li>
<li>Token中ref_count_, 引用计数，类似htk中collected path, new path, old path
</li>
<li>garbage collected
</li>
<li>ProcessNonemitting: 空弧跳转, 队列实现，htk中递归实现
</li>
<li>ProcessEmitting:
</li>
<li>在解码处理上算法简单化，数据结构更加抽象
</li>
<li>代码看起来很清晰哈
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> 三音素决策树</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>An event is just a set of (key,value) pairs, with no key repeated
</li>
</ul>
</div>
<div id="outline-container-sec-5-2-1" class="outline-4">
<h4 id="sec-5-2-1"><span class="section-number-4">5.2.1</span> 数据结构</h4>
<div class="outline-text-4" id="text-5-2-1">
</div><ol class="org-ol"><li><a id="sec-5-2-1-0-1" name="sec-5-2-1-0-1"></a>EventMap<br  /><div class="outline-text-6" id="text-5-2-1-0-1">
<ul class="org-ul">
<li>EventKeyType: int
</li>
<li>EventValueType: int
</li>
<li>EventAnswerType: int
</li>
<li>typedef std::vector&lt;std::pair&lt;EventKeyType,EventValueType&gt; &gt; EventType; 
</li>
<li>ConstantEventMap: 叶子节点
</li>
</ul>
<p>
answer_: 节点id，mono-tree中就是hmm-state的编号
</p>
<ul class="org-ul">
<li>TableEventMap:
</li>
</ul>
<pre class="example">
EventKeyType key_: key, -1时子树为叶节点， P时为hmm_sets
std::vector&lt;EventMap*&gt; table_: 各个子树
Lookup: 二分查找，event中查找key，返回id
MultiMap: 空查找所有，否则查找ans
MaxResult: 共多少个节点，返回最大节点编号
</pre>
</div>
</li>
<li><a id="sec-5-2-1-0-2" name="sec-5-2-1-0-2"></a>ContextDependency<br  /><div class="outline-text-6" id="text-5-2-1-0-2">
<ul class="org-ul">
<li>gmm-init-mono中如何构建一颗树
</li>
<li>GetPdfInfo: 返回每个pdf对应的音素状态
</li>
<li>to_pdf_
</li>
</ul>
</div>
</li>
<li><a id="sec-5-2-1-0-3" name="sec-5-2-1-0-3"></a>TransitionModel<br  /><div class="outline-text-6" id="text-5-2-1-0-3">
<ul class="org-ul">
<li>state2id_
</li>
<li>id2state_
</li>
<li>triples_
</li>
<li>ComputeTriples: 计算triples_
</li>
<li>ConputeDerived: 计算state2id_, id2state_
</li>
<li>InitializeProbs: 计算trans_id的log prob
</li>
<li>exp/mono/tree 格式： CE TE SE
</li>
</ul>
</div>
</li></ol>
</div>

<div id="outline-container-sec-5-2-2" class="outline-4">
<h4 id="sec-5-2-2"><span class="section-number-4">5.2.2</span> Clusterable</h4>
<div class="outline-text-4" id="text-5-2-2">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">GaussClusterable</span>: <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Clusterable</span> {
<span style="color: #a020f0;">public</span>:
<span style="color: #a020f0;">virtual</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">Add</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">Clusterable</span> &amp;<span style="color: #a0522d;">other_in</span>);
<span style="color: #a020f0;">virtual</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">Sub</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">Clusterable</span> &amp;<span style="color: #a0522d;">other_in</span>);
<span style="color: #a020f0;">virtual</span> <span style="color: #228b22;">BaseFloat</span> <span style="color: #0000ff;">Normalizer</span>() <span style="color: #a020f0;">const</span> { <span style="color: #a020f0;">return</span> count_; }
<span style="color: #a020f0;">virtual</span> <span style="color: #228b22;">Clusterable</span> *<span style="color: #0000ff;">Copy</span>() <span style="color: #a020f0;">const</span>;
<span style="color: #228b22;">double</span> <span style="color: #a0522d;">count_</span>;
<span style="color: #228b22;">Matrix</span>&lt;<span style="color: #228b22;">double</span>&gt; <span style="color: #a0522d;">stats_</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">two rows: sum, then sum-squared.</span>
<span style="color: #228b22;">double</span> <span style="color: #a0522d;">var_floor_</span>; <span style="color: #b22222;">// </span><span style="color: #b22222;">should be common for all objects created.</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2-3" class="outline-4">
<h4 id="sec-5-2-3"><span class="section-number-4">5.2.3</span> 计算似然和似然增益</h4>
<div class="outline-text-4" id="text-5-2-3">

<div class="figure">
<p><img src="/img/kaldi/tree_objf.png" alt="tree_objf.png" width="80%" />
</p>
</div>

<div class="figure">
<p><img src="/img/kaldi/tree_1.png" alt="tree_1.png" width="80%" />
</p>
</div>

<div class="figure">
<p><img src="/img/kaldi/tree_2.png" alt="tree_2.png" width="80%" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5-2-4" class="outline-4">
<h4 id="sec-5-2-4"><span class="section-number-4">5.2.4</span> tools &amp; core code</h4>
<div class="outline-text-4" id="text-5-2-4">
</div><ol class="org-ol"><li><a id="sec-5-2-4-0-1" name="sec-5-2-4-0-1"></a>acc-tree-stats<br  /><div class="outline-text-6" id="text-5-2-4-0-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = -N; <span style="color: #228b22;">i</span> &lt; <span style="color: #a020f0;">static_cast</span>&lt;<span style="color: #228b22;">int</span>&gt;(split_alignment.size()); i++) {
  <span style="color: #b22222;">// </span><span style="color: #b22222;">consider window starting at i, only if i+P is within</span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">list of phones.</span>
  <span style="color: #a020f0;">if</span> (i + P &gt;= 0 &amp;&amp; i + <span style="color: #228b22;">P</span> &lt; <span style="color: #a020f0;">static_cast</span>&lt;<span style="color: #228b22;">int</span>&gt;(split_alignment.size())) {
    <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">central_phone</span> =
        MapPhone(phone_map,
                 trans_model.TransitionIdToPhone(split_alignment[i+P][0]));
    <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">is_ctx_dep</span> = ! <span style="color: #008b8b;">std</span>::binary_search(ci_phones.begin(),
                                           ci_phones.end(),
                                           central_phone);
    <span style="color: #228b22;">EventType</span> <span style="color: #a0522d;">evec</span>;
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">j</span> = 0; j &lt; N; j++) {
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">phone</span>;
      <span style="color: #a020f0;">if</span> (i + j &gt;= 0 &amp;&amp; i + <span style="color: #228b22;">j</span> &lt; <span style="color: #a020f0;">static_cast</span>&lt;<span style="color: #228b22;">int</span>&gt;(split_alignment.size()))
        phone =
            MapPhone(phone_map,
                     trans_model.TransitionIdToPhone(split_alignment[i+j][0]));
      <span style="color: #a020f0;">else</span>
        phone = 0;  <span style="color: #b22222;">// </span><span style="color: #b22222;">ContextDependency class uses 0 to mean "out of window";</span>
      <span style="color: #b22222;">// </span><span style="color: #b22222;">we also set the phone arbitrarily to 0</span>

      <span style="color: #b22222;">// </span><span style="color: #b22222;">Don't add stuff to the event that we don't "allow" to be asked, due</span>
      <span style="color: #b22222;">// </span><span style="color: #b22222;">to the central phone being context-independent: check "is_ctx_dep".</span>
      <span style="color: #b22222;">// </span><span style="color: #b22222;">Why not just set the value to zero in this</span>
      <span style="color: #b22222;">// </span><span style="color: #b22222;">case?  It's for safety.  By omitting the key from the event, we</span>
      <span style="color: #b22222;">// </span><span style="color: #b22222;">ensure that there is no way a question can ever be asked that might</span>
      <span style="color: #b22222;">// </span><span style="color: #b22222;">give an inconsistent answer in tree-training versus graph-building.</span>
      <span style="color: #b22222;">// </span><span style="color: #b22222;">[setting it to zero would have the same effect given the "normal"</span>
      <span style="color: #b22222;">// </span><span style="color: #b22222;">recipe but might be less robust to changes in tree-building recipe].</span>
      <span style="color: #a020f0;">if</span> (is_ctx_dep || j == P)
        evec.push_back(<span style="color: #008b8b;">std</span>::make_pair(<span style="color: #a020f0;">static_cast</span>&lt;EventKeyType&gt;(j), <span style="color: #a020f0;">static_cast</span>&lt;EventValueType&gt;(phone)));
    }
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">j</span> = 0; <span style="color: #228b22;">j</span> &lt; <span style="color: #a020f0;">static_cast</span>&lt;<span style="color: #228b22;">int</span>&gt;(split_alignment[i+P].size());j++) {
      <span style="color: #b22222;">// </span><span style="color: #b22222;">for central phone of this window...</span>
      <span style="color: #228b22;">EventType</span> <span style="color: #a0522d;">evec_more</span>(evec);
      <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">pdf_class</span> = trans_model.TransitionIdToPdfClass(split_alignment[i+P][j]);
      <span style="color: #b22222;">// </span><span style="color: #b22222;">pdf_class will normally by 0, 1 or 2 for 3-state HMM.</span>
      <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">pair</span>&lt;EventKeyType, EventValueType&gt; <span style="color: #a0522d;">pr</span>(kPdfClass, pdf_class);
      evec_more.push_back(pr);
      <span style="color: #008b8b;">std</span>::sort(evec_more.begin(), evec_more.end());  <span style="color: #b22222;">// </span><span style="color: #b22222;">these must be sorted!</span>
      <span style="color: #a020f0;">if</span> (stats-&gt;count(evec_more) == 0)
        (*stats)[evec_more] = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">GaussClusterable</span>(dim, var_floor);

      <span style="color: #228b22;">BaseFloat</span> <span style="color: #a0522d;">weight</span> = 1.0;
      (*stats)[evec_more]-&gt;AddStats(features.Row(cur_pos), weight);
      cur_pos++;
    }
  }
}
</pre>
</div>
</div>
</li>
<li><a id="sec-5-2-4-0-2" name="sec-5-2-4-0-2"></a>cluster-phones<br  /><div class="outline-text-6" id="text-5-2-4-0-2">
<div class="org-src-container">

<pre class="src src-cpp">  <span style="color: #b22222;">// </span><span style="color: #b22222;">split by phone,&#26681;&#25454;&#20013;&#38388;&#38899;&#32032;&#20998;&#31867;&#65292;&#24182;&#32479;&#35745;</span>
  SplitStatsByKey(retained_stats, P, &amp;split_stats);
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">Clusterable</span>*&gt; <span style="color: #a0522d;">summed_stats</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">summed up by phone.</span>
  SumStatsVec(split_stats, &amp;summed_stats);
  <span style="color: #b22222;">// </span><span style="color: #b22222;">&#26641;&#32858;&#31867;</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;int32&gt; <span style="color: #a0522d;">assignments</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">assignment of phones to clusters. dim == summed_stats.size().</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;int32&gt; <span style="color: #a0522d;">clust_assignments</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">Parent of each cluster.  Dim == #clusters.</span>
  <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">num_leaves</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">number of leaf-level clusters.</span>
  TreeCluster(summed_stats_per_set,
              summed_stats_per_set.size(),  <span style="color: #b22222;">// </span><span style="color: #b22222;">max-#clust is all of the points.</span>
              <span style="color: #008b8b;">NULL</span>,  <span style="color: #b22222;">// </span><span style="color: #b22222;">don't need the clusters out.</span>
              &amp;assignments,
              &amp;clust_assignments,
              &amp;num_leaves,
              topts);
  <span style="color: #b22222;">//</span><span style="color: #b22222;">&#35843;&#29992;</span>
  <span style="color: #228b22;">TreeClusterer</span> <span style="color: #0000ff;">tc</span>(points, max_clust, cfg);
  <span style="color: #228b22;">BaseFloat</span> <span style="color: #a0522d;">ans</span> = tc.Cluster(clusters_out, assignments_out, clust_assignments_out, num_leaves_out);
  <span style="color: #b22222;">//</span><span style="color: #b22222;">&#31867;TreeCluster</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">TreeClusterer</span> {
  <span style="color: #b22222;">//</span><span style="color: #b22222;">&#26641;&#32858;&#31867;</span>
  <span style="color: #228b22;">BaseFloat</span> <span style="color: #0000ff;">Cluster</span>(<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">Clusterable</span>*&gt; *<span style="color: #a0522d;">clusters_out</span>,
                    <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">int32</span>&gt; *<span style="color: #a0522d;">assignments_out</span>,
                    <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">int32</span>&gt; *<span style="color: #a0522d;">clust_assignments_out</span>,
                    <span style="color: #a0522d;">int32</span> *num_leaves_out) {
    <span style="color: #a020f0;">while</span> (<span style="color: #a020f0;">static_cast</span>&lt;int32&gt;(leaf_nodes_.size()) &lt; max_clust_ &amp;&amp; !queue_.empty()) {
      <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">pair</span>&lt;<span style="color: #228b22;">BaseFloat</span>, <span style="color: #228b22;">Node</span>*&gt; <span style="color: #a0522d;">pr</span> = queue_.top();
      queue_.pop();
      ans_ += pr.first;
      DoSplit(pr.second);
    }
    CreateOutput(clusters_out, assignments_out, clust_assignments_out,
                 num_leaves_out);
    <span style="color: #a020f0;">return</span> ans_;
  }
  <span style="color: #b22222;">//</span><span style="color: #b22222;">&#23545;&#19968;&#20010;&#33410;&#28857;&#36827;&#34892;&#20998;&#21106;</span>
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">DoSplit</span>(<span style="color: #228b22;">Node</span> *<span style="color: #a0522d;">node</span>) {}
  <span style="color: #b22222;">//</span><span style="color: #b22222;">&#23558;&#19968;&#20010;&#33410;&#28857;&#36827;&#34892;kmeans&#32858;&#31867;, &#27492;&#22788;kmeans&#32858;&#31867;&#27604;&#36739;&#29305;&#27530;&#65292;&#20026;&#20445;&#35777;&#32467;&#26524;&#36739;&#20248;&#65292;&#36827;&#34892;&#20102;&#22810;&#27425;&#19981;&#21516;&#21021;&#22987;&#21270;&#65292;&#24182;&#36873;&#25321;&#25928;&#26524;&#22909;&#30340;&#12290;</span>
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">FindBestSplit</span>(<span style="color: #228b22;">Node</span> *<span style="color: #a0522d;">node</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">takes a leaf node that has just been set up, and does ClusterKMeans with k = cfg_branch_factor.</span>
    KALDI_ASSERT(node-&gt;is_leaf);
    <span style="color: #a020f0;">if</span> (node-&gt;leaf.points.size() == 0) {
      KALDI_WARN &lt;&lt; <span style="color: #8b2252;">"Warning: tree clustering: leaf with no data\n"</span>;
      node-&gt;leaf.best_split = 0; <span style="color: #a020f0;">return</span>;
    }
    <span style="color: #a020f0;">if</span> (node-&gt;leaf.points.size()&lt;=1) { node-&gt;leaf.best_split = 0; <span style="color: #a020f0;">return</span>; }
    <span style="color: #a020f0;">else</span> {
      <span style="color: #b22222;">// </span><span style="color: #b22222;">use kmeans.</span>
      <span style="color: #228b22;">BaseFloat</span> <span style="color: #a0522d;">impr</span> = ClusterKMeans(node-&gt;leaf.points,
                                     cfg_.branch_factor,
                                     &amp;node-&gt;leaf.clusters,
                                     &amp;node-&gt;leaf.assignments,
                                     cfg_.kmeans_cfg);
      node-&gt;leaf.best_split = impr;
      <span style="color: #a020f0;">if</span> (impr &gt; cfg_.thresh)
        queue_.push(<span style="color: #008b8b;">std</span>::make_pair(impr, node));
    }
  }
}
</pre>
</div>
</div>
</li>
<li><a id="sec-5-2-4-0-3" name="sec-5-2-4-0-3"></a>compile-questions<br  /><div class="outline-text-6" id="text-5-2-4-0-3">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #228b22;">Questions</span> <span style="color: #a0522d;">qo</span>;
<span style="color: #228b22;">QuestionsForKey</span> <span style="color: #0000ff;">phone_opts</span>(num_iters_refine);
<span style="color: #b22222;">// </span><span style="color: #b22222;">the questions-options corresponding to keys 0, 1, .. N-1 which</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">represent the phonetic context positions (including the central phone).</span>
phone_opts.initial_questions = questions;
<span style="color: #b22222;">//</span><span style="color: #b22222;">&#23545;&#27599;&#20010;&#20301;&#32622;&#24314;&#31435;&#38382;&#39064;&#38598;</span>
<span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">n</span> = 0; n &lt; N; n++) {
  KALDI_LOG &lt;&lt; <span style="color: #8b2252;">"Setting questions for phonetic-context position "</span>&lt;&lt; n;
  qo.SetQuestionsOf(n, phone_opts);
}
<span style="color: #228b22;">QuestionsForKey</span> <span style="color: #0000ff;">pdfclass_opts</span>(num_iters_refine);
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">int32</span>&gt; &gt; <span style="color: #0000ff;">pdfclass_questions</span>(max_num_pdfclasses-1);
<span style="color: #b22222;">//</span><span style="color: #b22222;">&#23545;kPdfClass=-1&#38382;&#39064;&#38598;[ [0], [0, 1] ]</span>
<span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">i</span> = 0; i &lt; max_num_pdfclasses - 1; i++)
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">j</span> = 0; j &lt;= i; j++)
    pdfclass_questions[i].push_back(j);
<span style="color: #b22222;">// </span><span style="color: #b22222;">E.g. if max_num_pdfclasses == 3,  pdfclass_questions is now [ [0], [0, 1] ].</span>
pdfclass_opts.initial_questions = pdfclass_questions;
KALDI_LOG &lt;&lt; <span style="color: #8b2252;">"Setting questions for hmm-position [hmm-position ranges from 0 to "</span>&lt;&lt; (max_num_pdfclasses-1) &lt;&lt;<span style="color: #8b2252;">"]"</span>;
qo.SetQuestionsOf(kPdfClass, pdfclass_opts);
</pre>
</div>
</div>
</li>

<li><a id="sec-5-2-4-0-4" name="sec-5-2-4-0-4"></a>build-tree<br  /><div class="outline-text-6" id="text-5-2-4-0-4">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #228b22;">EventMap</span> *<span style="color: #0000ff;">SplitDecisionTree</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">EventMap</span> &amp;<span style="color: #a0522d;">input_map</span>,
                            <span style="color: #a020f0;">const</span> <span style="color: #228b22;">BuildTreeStatsType</span> &amp;<span style="color: #a0522d;">stats</span>,
                            <span style="color: #228b22;">Questions</span> &amp;<span style="color: #a0522d;">q_opts</span>,
                            <span style="color: #228b22;">BaseFloat</span> <span style="color: #a0522d;">thresh</span>,
                            <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">max_leaves</span>,  <span style="color: #b22222;">// </span><span style="color: #b22222;">max_leaves&lt;=0 -&gt; no maximum.</span>
                            <span style="color: #228b22;">int32</span> *<span style="color: #a0522d;">num_leaves</span>,
                            <span style="color: #228b22;">BaseFloat</span> *<span style="color: #a0522d;">obj_impr_out</span>,
                            <span style="color: #228b22;">BaseFloat</span> *<span style="color: #a0522d;">smallest_split_change_out</span>) {
  {  <span style="color: #b22222;">// </span><span style="color: #b22222;">Do the splitting.</span>
    <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">count</span> = 0;
    <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">priority_queue</span>&lt;<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">pair</span>&lt;<span style="color: #228b22;">BaseFloat</span>, <span style="color: #228b22;">size_t</span>&gt; &gt; <span style="color: #a0522d;">queue</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">use size_t because logically these</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">are just indexes into the array, not leaf-ids (after splitting they are no longer leaf id's).</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">Initialize queue.</span>
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i &lt; builders.size(); i++)
      queue.push(<span style="color: #008b8b;">std</span>::make_pair(builders[i]-&gt;BestSplit(), i));
    <span style="color: #b22222;">// </span><span style="color: #b22222;">Note-- queue's size never changes from now.  All the alternatives leaves to split are</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">inside the "DecisionTreeSplitter*" objects, in a tree structure.</span>
    <span style="color: #b22222;">//</span><span style="color: #b22222;">&#27492;&#22788;&#20026;&#37325;&#28857;&#65292;&#20248;&#20808;&#38431;&#21015;&#30340;&#20351;&#29992;&#65292;&#21450;&#20915;&#31574;&#26641;&#32456;&#27490;&#30340;&#20004;&#20010;&#26465;&#20214;</span>
    <span style="color: #a020f0;">while</span> (queue.top().first &gt; thresh
          &amp;&amp; (max_leaves&lt;=0 || *num_leaves &lt; max_leaves)) {
      smallest_split_change = <span style="color: #008b8b;">std</span>::min(smallest_split_change, queue.top().first);
      <span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = queue.top().second;
      like_impr += queue.top().first;
      builders[i]-&gt;DoSplit(num_leaves);
      queue.pop();
      queue.push(<span style="color: #008b8b;">std</span>::make_pair(builders[i]-&gt;BestSplit(), i));
      count++;
    }
    KALDI_LOG &lt;&lt; <span style="color: #8b2252;">"DoDecisionTreeSplit: split "</span>&lt;&lt; count &lt;&lt; <span style="color: #8b2252;">" times, #leaves now "</span> &lt;&lt; (*num_leaves);
  }
  ...
}
&#23547;&#25214;&#26368;&#20248;&#38382;&#39064;&#38598;&#31867;
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">DecisionTreeSplitter</span> {
  <span style="color: #b22222;">//</span><span style="color: #b22222;">&#36820;&#22238;&#26368;&#20248;&#30340;&#19968;&#20010;&#20998;&#21106;&#22686;&#30410;</span>
  <span style="color: #228b22;">BaseFloat</span> <span style="color: #0000ff;">BestSplit</span>() { <span style="color: #a020f0;">return</span> best_split_impr_; } <span style="color: #b22222;">// </span><span style="color: #b22222;">returns objf improvement (&gt;=0) of best possible split.</span>
  <span style="color: #b22222;">//</span><span style="color: #b22222;">&#26500;&#36896;&#20989;&#25968;&#20013;&#21363;&#20174;&#38382;&#39064;&#38598;&#20013;&#23547;&#25214;&#26368;&#20248;&#38382;&#39064;</span>
  <span style="color: #0000ff;">DecisionTreeSplitter</span>(<span style="color: #228b22;">EventAnswerType</span> <span style="color: #a0522d;">leaf</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">BuildTreeStatsType</span> &amp;<span style="color: #a0522d;">stats</span>,
                      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">Questions</span> &amp;<span style="color: #a0522d;">q_opts</span>): q_opts_(q_opts), yes_(<span style="color: #008b8b;">NULL</span>), no_(<span style="color: #008b8b;">NULL</span>), <span style="color: #228b22;">leaf_</span>(<span style="color: #a0522d;">leaf</span>), <span style="color: #228b22;">stats_</span>(<span style="color: #a0522d;">stats</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">not, this must work when stats is empty too. [just gives zero improvement, non-splittable].</span>
    FindBestSplit();
  }
   <span style="color: #b22222;">//</span><span style="color: #b22222;">&#22312;all_keys&#20013;&#25214;&#26368;&#20248;</span>
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">FindBestSplit</span>() {}
};

<span style="color: #228b22;">BaseFloat</span> <span style="color: #0000ff;">ComputeInitialSplit</span>(<span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">Clusterable</span>*&gt; &amp;<span style="color: #a0522d;">summed_stats</span>,
                              <span style="color: #a020f0;">const</span> <span style="color: #228b22;">Questions</span> &amp;<span style="color: #a0522d;">q_opts</span>, <span style="color: #a0522d;">EventKeyType</span> key,
                              <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;EventValueType&gt; *<span style="color: #a0522d;">yes_set</span>) {
  ...
  <span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;EventValueType&gt; &gt; &amp;<span style="color: #a0522d;">questions_of_this_key</span> = key_opts.initial_questions;

  <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">best_idx</span> = -1;
  <span style="color: #228b22;">BaseFloat</span> <span style="color: #a0522d;">best_objf_change</span> = 0;
  <span style="color: #b22222;">//</span><span style="color: #b22222;">&#22312;&#38382;&#39064;&#38598;&#20013;&#23547;&#25214;&#20284;&#28982;&#22686;&#30410;&#26368;&#22823;&#30340;&#38382;&#39064;</span>
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i &lt; questions_of_this_key.size(); i++) {
    <span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;EventValueType&gt; &amp;<span style="color: #a0522d;">yes_set</span> = questions_of_this_key[i];
    <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">int32</span>&gt; <span style="color: #a0522d;">assignments</span>(summed_stats.size(), 0);  <span style="color: #b22222;">// </span><span style="color: #b22222;">0 is index of "no".</span>
    <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">Clusterable</span>*&gt; <span style="color: #a0522d;">clusters</span>(2);  <span style="color: #b22222;">// </span><span style="color: #b22222;">no and yes clusters.</span>
    <span style="color: #a020f0;">for</span> (<span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">vector</span>&lt;EventValueType&gt;::<span style="color: #228b22;">const_iterator</span> <span style="color: #a0522d;">iter</span> = yes_set.begin(); iter != yes_set.end(); iter++) {
      KALDI_ASSERT(*iter&gt;=0);
      <span style="color: #a020f0;">if</span> (*iter &lt; (<span style="color: #228b22;">EventValueType</span>)assignments.size()) assignments[*iter] = 1;
    }
    <span style="color: #008b8b;">kaldi</span>::AddToClustersOptimized(summed_stats, assignments, *total, &amp;clusters);
    <span style="color: #228b22;">BaseFloat</span> <span style="color: #a0522d;">this_objf</span> = SumClusterableObjf(clusters);

    <span style="color: #a020f0;">if</span> (this_objf &lt; unsplit_objf- 0.001*<span style="color: #008b8b;">std</span>::abs(unsplit_objf)) {  <span style="color: #b22222;">// </span><span style="color: #b22222;">got worse; should never happen.</span>
      <span style="color: #b22222;">// </span><span style="color: #b22222;">of course small differences can be caused by roundoff.</span>
      KALDI_WARN &lt;&lt; <span style="color: #8b2252;">"Objective function got worse when building tree: "</span>&lt;&lt; this_objf &lt;&lt; <span style="color: #8b2252;">" &lt; "</span> &lt;&lt; unsplit_objf;
      KALDI_ASSERT(!(this_objf &lt; unsplit_objf - 0.01*(200 + <span style="color: #008b8b;">std</span>::abs(unsplit_objf))));  <span style="color: #b22222;">// </span><span style="color: #b22222;">do assert on more stringent check.</span>
    }

    <span style="color: #228b22;">BaseFloat</span> <span style="color: #a0522d;">this_objf_change</span> = this_objf - unsplit_objf;
    <span style="color: #a020f0;">if</span> (this_objf_change &gt; best_objf_change) {
      best_objf_change = this_objf_change;
      best_idx = i;
    }
    DeletePointers(&amp;clusters);
  }
  <span style="color: #a020f0;">delete</span> total;
  <span style="color: #a020f0;">if</span> (best_idx != -1)
    *yes_set = questions_of_this_key[best_idx];
  <span style="color: #a020f0;">return</span> best_objf_change;
}
</pre>
</div>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> DNN</h3>
<div class="outline-text-3" id="text-5-3">
</div><div id="outline-container-sec-5-3-1" class="outline-4">
<h4 id="sec-5-3-1"><span class="section-number-4">5.3.1</span> component</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
神经网络由多层的Component拼接而成，即Component为其基本组件。Component中引申出UpdatableComponent，即含有连接权值的Component，如：
</p>
<ol class="org-ol">
<li>Component: Sigmoid, Softmax, Tanh, max-pooling等
</li>
<li>UpdatableComponent: AffineTransform, LinearTransform, ConvolutionalComponent等。
</li>
<li>loss: Mse, Xent（交叉熵）
</li>
</ol>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b22222;">//</span><span style="color: #b22222;">Componet&#23376;&#31867;&#38656;&#23454;&#29616;PropagateFnc&#21644;BackpropagateFnc&#25509;&#21475;</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">Sigmoid</span> : <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Component</span> {
 <span style="color: #a020f0;">public</span>:
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">PropagateFnc</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; &amp;<span style="color: #a0522d;">in</span>, <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; *<span style="color: #a0522d;">out</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">y = 1/(1+e^-x)</span>
    out-&gt;Sigmoid(in);
  }
  <span style="color: #228b22;">void</span> <span style="color: #0000ff;">BackpropagateFnc</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; &amp;<span style="color: #a0522d;">in</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; &amp;<span style="color: #a0522d;">out</span>,
                        <span style="color: #a020f0;">const</span> <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; &amp;<span style="color: #a0522d;">out_diff</span>, <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; *<span style="color: #a0522d;">in_diff</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">ey = y(1-y)ex</span>
    in_diff-&gt;DiffSigmoid(out, out_diff);
  }
};
<span style="color: #b22222;">//</span><span style="color: #b22222;">UpdatableComponent&#36824;&#38656;&#23454;&#29616;Update()&#25509;&#21475;</span>
<span style="color: #a020f0;">class</span> <span style="color: #228b22;">UpdatableComponent</span> : <span style="color: #a020f0;">public</span> <span style="color: #228b22;">Component</span> {
<span style="color: #a020f0;">public</span>:
  <span style="color: #b22222;">//</span><span style="color: #b22222;">updatable</span>
  <span style="color: #228b22;">bool</span> <span style="color: #0000ff;">IsUpdatable</span>() <span style="color: #a020f0;">const</span> {
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
  }
  <span style="color: #b22222;">/// </span><span style="color: #b22222;">Compute gradient and update parameters</span>
  <span style="color: #a020f0;">virtual</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">Update</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; &amp;<span style="color: #a0522d;">input</span>,
                      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; &amp;<span style="color: #a0522d;">diff</span>) = 0;
 <span style="color: #a020f0;">protected</span>:
  <span style="color: #b22222;">/// </span><span style="color: #b22222;">Option-class with training hyper-parameters</span>
  <span style="color: #228b22;">NnetTrainOptions</span> <span style="color: #a0522d;">opts_</span>;
};
<span style="color: #b22222;">//</span><span style="color: #b22222;">UpdatableComponent&#21442;&#25968;&#21021;&#22987;&#21270;</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">InitData</span>(<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">istream</span> &amp;<span style="color: #a0522d;">is</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-3-2" class="outline-4">
<h4 id="sec-5-3-2"><span class="section-number-4">5.3.2</span> nnet</h4>
<div class="outline-text-4" id="text-5-3-2">
<p>
一个神经网络的封装，将components及其前向后向拼接起来。
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #a020f0;">private</span>:
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">Component</span>*&gt; <span style="color: #a0522d;">components_</span>; 
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">CuMatrix</span>&lt;BaseFloat&gt; &gt; <span style="color: #a0522d;">propagate_buf_</span>; <span style="color: #b22222;">///</span><span style="color: #b22222;">&lt; buffers for forward pass</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">CuMatrix</span>&lt;BaseFloat&gt; &gt; <span style="color: #a0522d;">backpropagate_buf_</span>; <span style="color: #b22222;">///</span><span style="color: #b22222;">&lt; buffers for backward pass</span>

<span style="color: #228b22;">void</span> <span style="color: #008b8b;">Nnet</span>::<span style="color: #0000ff;">Propagate</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; &amp;<span style="color: #a0522d;">in</span>, <span style="color: #228b22;">CuMatrix</span>&lt;BaseFloat&gt; *<span style="color: #a0522d;">out</span>) {
  propagate_buf_[0].Resize(in.NumRows(), in.NumCols());
  propagate_buf_[0].CopyFromMat(in);
  <span style="color: #a020f0;">for</span>(<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">i</span>=0; i&lt;(<span style="color: #228b22;">int32</span>)components_.size(); i++) {
    components_[i]-&gt;Propagate(propagate_buf_[i], &amp;propagate_buf_[i+1]);
  }
  (*out) = propagate_buf_[components_.size()];
}
<span style="color: #228b22;">void</span> <span style="color: #008b8b;">Nnet</span>::<span style="color: #0000ff;">Backpropagate</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; &amp;<span style="color: #a0522d;">out_diff</span>, <span style="color: #228b22;">CuMatrix</span>&lt;BaseFloat&gt; *<span style="color: #a0522d;">in_diff</span>) {
  <span style="color: #b22222;">// </span><span style="color: #b22222;">copy out_diff to last buffer</span>
  backpropagate_buf_[NumComponents()] = out_diff;
  <span style="color: #b22222;">// </span><span style="color: #b22222;">backpropagate using buffers</span>
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">i</span> = NumComponents()-1; i &gt;= 0; i--) {
    components_[i]-&gt;Backpropagate(propagate_buf_[i], propagate_buf_[i+1],
                            backpropagate_buf_[i+1], &amp;backpropagate_buf_[i]);
    <span style="color: #a020f0;">if</span> (components_[i]-&gt;IsUpdatable()) {
      <span style="color: #228b22;">UpdatableComponent</span> *<span style="color: #a0522d;">uc</span> = <span style="color: #a020f0;">dynamic_cast</span>&lt;UpdatableComponent*&gt;(components_[i]);
      uc-&gt;Update(propagate_buf_[i], backpropagate_buf_[i+1]);
    }
  }
  <span style="color: #b22222;">// </span><span style="color: #b22222;">eventually export the derivative</span>
  <span style="color: #a020f0;">if</span> (<span style="color: #008b8b;">NULL</span> != in_diff) (*in_diff) = backpropagate_buf_[0];
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-3-3" class="outline-4">
<h4 id="sec-5-3-3"><span class="section-number-4">5.3.3</span> nnet-train-frmshuff</h4>
<div class="outline-text-4" id="text-5-3-3">
<p>
Perform one iteration of Neural Network training by mini-batch Stochastic Gradient Descent
</p>
<ol class="org-ol">
<li>先对特征打乱，并按组分为minibatch大小
</li>
<li>利用suffle的数据训练DNN
</li>
</ol>
<pre class="example">
--cross-validate:  Perform cross-validation (don't backpropagate)
--objective-function: xent or mes
–feature-transform, this can be a Nnet which does on-the-fly feature transformation
--minibatch-size
</pre>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b22222;">//</span><span style="color: #b22222;">minibatch&#22312;&#36825;&#37324;&#38754;</span>
<span style="color: #228b22;">NnetDataRandomizerOptions</span> <span style="color: #a0522d;">rnd_opts</span>;
rnd_opts.Register(&amp;po);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> CNN</h3>
<div class="outline-text-3" id="text-5-4">
</div><div id="outline-container-sec-5-4-1" class="outline-4">
<h4 id="sec-5-4-1"><span class="section-number-4">5.4.1</span> keypoint</h4>
<div class="outline-text-4" id="text-5-4-1">
<ul class="org-ul">
<li>convolution only frequence axis, 卷积窗仅在频域轴上移动
</li>
<li>feature type, 将时域拼接的上下文帧转换为frequency bands特征
</li>
<li>convolution over all axis, 即不使用local filter，在整个频域上使用相同核
</li>
<li>fast implementation, 将二维滤波器（卷积核）拉伸为一维向量
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-4-2" class="outline-4">
<h4 id="sec-5-4-2"><span class="section-number-4">5.4.2</span> 代码解析</h4>
<div class="outline-text-4" id="text-5-4-2">
<p>
因为卷积核移动和不同的卷积核，输入与输出之间是一对多的关系，一般是按输入顺序查找输出。这里的一个技巧是先确定出输出的维度，查找与之相应的输入，前向，后向，卷积和pooling时均使用该技巧。
</p>
</div>
<ol class="org-ol"><li><a id="sec-5-4-2-1" name="sec-5-4-2-1"></a>卷积层 nnet-convolution-component.h<br  /><div class="outline-text-5" id="text-5-4-2-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">PropagateFnc</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; &amp;<span style="color: #a0522d;">in</span>, <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; *<span style="color: #a0522d;">out</span>) {
  <span style="color: #b22222;">// </span><span style="color: #b22222;">useful dims</span>
  <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">num_splice</span> = input_dim_ / patch_stride_; <span style="color: #b22222;">//</span><span style="color: #b22222;">&#24103;&#25968;</span>
  <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">num_patches</span> = 1 + (patch_stride_ - patch_dim_) / patch_step_; <span style="color: #b22222;">//</span><span style="color: #b22222;">patch num</span>
  <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">num_filters</span> = filters_.NumRows(); <span style="color: #b22222;">//</span><span style="color: #b22222;">filter&#25968;&#37327;&#65292;&#19968;&#34892;&#20026;&#19968;&#20010;filter</span>
  <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">num_frames</span> = in.NumRows(); <span style="color: #b22222;">//</span><span style="color: #b22222;">batch&#20013;&#30340;&#25968;&#25454;&#25968;</span>
  <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">filter_dim</span> = filters_.NumCols(); <span style="color: #b22222;">//</span><span style="color: #b22222;">filter&#30340;&#26680;&#22823;&#23567;</span>

  <span style="color: #b22222;">// </span><span style="color: #b22222;">we will need the buffers </span>
  <span style="color: #a020f0;">if</span> (vectorized_feature_patches_.size() == 0) {
    vectorized_feature_patches_.resize(num_patches);
    feature_patch_diffs_.resize(num_patches);
  }

  <span style="color: #b22222;">/* </span><span style="color: #b22222;">Prepare feature patches, the layout is:</span>
<span style="color: #b22222;">   * |----------|----------|----------|---------| (in = spliced frames)</span>
<span style="color: #b22222;">   *   xxx        xxx        xxx        xxx       (x = selected elements)</span>
<span style="color: #b22222;">   *</span>
<span style="color: #b22222;">   *   xxx : patch dim</span>
<span style="color: #b22222;">   *    xxx </span>
<span style="color: #b22222;">   *   ^---: patch step</span>
<span style="color: #b22222;">   * |----------| : patch stride</span>
<span style="color: #b22222;">   *</span>
<span style="color: #b22222;">   *   xxx-xxx-xxx-xxx : filter dim</span>
<span style="color: #b22222;">   *  </span>
<span style="color: #b22222;">   */</span>
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">p</span>=0; p&lt;num_patches; p++) {
    vectorized_feature_patches_[p].Resize(num_frames, filter_dim, kSetZero);
    <span style="color: #b22222;">// </span><span style="color: #b22222;">build-up a column selection mask:</span>
    <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">int32</span>&gt; <span style="color: #a0522d;">column_mask</span>;
    <span style="color: #b22222;">/*</span>
<span style="color: #b22222;">     *|-XXX---------|</span>
<span style="color: #b22222;">     *|-XXX---------|</span>
<span style="color: #b22222;">     *|-XXX---------|</span>
<span style="color: #b22222;">     *|-XXX---------|</span>
<span style="color: #b22222;">     column_mask&#30340;&#20301;&#32622;, p * patch_step + s * patch_stride_ + d</span>
<span style="color: #b22222;">     */</span>
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">s</span>=0; s&lt;num_splice; s++) {
      <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">d</span>=0; d&lt;patch_dim_; d++) {
        column_mask.push_back(p * patch_step_ + s * patch_stride_ + d);
      }
    }
    KALDI_ASSERT(column_mask.size() == filter_dim);
    <span style="color: #b22222;">// </span><span style="color: #b22222;">select the current patch columns, &#19968;&#34892;&#20026;&#19968;&#20010;&#36755;&#20837;&#25968;&#25454;&#12290;</span>
    vectorized_feature_patches_[p].CopyCols(in, column_mask);
  }

  <span style="color: #b22222;">// </span><span style="color: #b22222;">compute filter activations</span>
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">p</span>=0; p&lt;num_patches; p++) {
    <span style="color: #b22222;">//</span><span style="color: #b22222;">patch p &#22312;&#36755;&#20986;&#20013;&#30340;&#20301;&#32622;tgt</span>
    <span style="color: #228b22;">CuSubMatrix</span>&lt;BaseFloat&gt; <span style="color: #a0522d;">tgt</span>(out-&gt;ColRange(<span style="color: #228b22;">p</span> * <span style="color: #a0522d;">num_filters</span>, num_filters));
    tgt.AddVecToRows(1.0, bias_, 0.0); <span style="color: #b22222;">// </span><span style="color: #b22222;">add bias</span>
    <span style="color: #b22222;">// </span><span style="color: #b22222;">apply all filters</span>
    tgt.AddMatMat(1.0, vectorized_feature_patches_[p], kNoTrans, filters_, kTrans, 1.0);
  }
}
<span style="color: #b22222;">//</span><span style="color: #b22222;">&#21518;&#21521;&#31243;&#24207;&#20165;&#26159;&#23545;&#20844;&#24335;&#30340;&#32763;&#35793;</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">BackpropagateFnc</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; &amp;<span style="color: #a0522d;">in</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; &amp;<span style="color: #a0522d;">out</span>,
                      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; &amp;<span style="color: #a0522d;">out_diff</span>, <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; *<span style="color: #a0522d;">in_diff</span>) {
}
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">Update</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; &amp;<span style="color: #a0522d;">input</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; &amp;<span style="color: #a0522d;">diff</span>) {
}
</pre>
</div>
</div>
</li>

<li><a id="sec-5-4-2-2" name="sec-5-4-2-2"></a>pooling层 nnet-max-pooling-component.h<br  /><div class="outline-text-5" id="text-5-4-2-2">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">PropagateFnc</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; &amp;<span style="color: #a0522d;">in</span>, <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; *<span style="color: #a0522d;">out</span>) {                                                                
  <span style="color: #b22222;">// </span><span style="color: #b22222;">useful dims                                                                                                                                    </span>
  <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">num_patches</span> = input_dim_ / pool_stride_;                                                                                                    
  <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">num_pools</span> = 1 + (num_patches - pool_size_) / pool_step_;                                                                                    
  <span style="color: #b22222;">//</span><span style="color: #b22222;">pool_step_ pool&#27493;&#31227;&#65292; pool_size_&#65292;pool&#27493;&#38271;                                                                                                                                                  </span>
  <span style="color: #b22222;">// </span><span style="color: #b22222;">do the max-pooling (pools indexed by q),&#20026;&#27599;&#20010;&#36755;&#20986;q&#36873;&#25321;max                                                                                                        </span>
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">q</span> = 0; q &lt; num_pools; q++) {                                                                                                           
    <span style="color: #b22222;">// </span><span style="color: #b22222;">get output buffer of the pool                                                                                                                </span>
    <span style="color: #228b22;">CuSubMatrix</span>&lt;BaseFloat&gt; <span style="color: #a0522d;">pool</span>(out-&gt;ColRange(<span style="color: #228b22;">q</span>*<span style="color: #a0522d;">pool_stride_</span>, pool_stride_));                                                                       
    pool.Set(-1e20); <span style="color: #b22222;">// </span><span style="color: #b22222;">reset (large negative value)                                                                                                </span>
    <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">r</span> = 0; r &lt; pool_size_; r++) { <span style="color: #b22222;">// </span><span style="color: #b22222;">max                                                                                                 </span>
      <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">p</span> = r + q * pool_step_; <span style="color: #b22222;">// </span><span style="color: #b22222;">p = input patch                                                                                              </span>
      pool.Max(in.ColRange(p*pool_stride_, pool_stride_)); <span style="color: #b22222;">//</span><span style="color: #b22222;">*this = max(*this, A)                                                                                      </span>
    }                                                                                                                                               
  }                                                                                                                                                 
} 
<span style="color: #b22222;">//</span><span style="color: #b22222;">max-pool&#65292;&#33509;&#20854;&#20026;max&#65292;&#21518;&#21521;&#35823;&#24046;&#20056;&#20197;1&#65292;&#21542;&#21017;0&#65292;&#36825;&#37324;&#26377;&#20010;scale&#30340;&#25805;&#20316;</span>
<span style="color: #b22222;">//</span><span style="color: #b22222;">&#22240;&#20026;&#20013;&#38388;&#37096;&#20998;&#21487;&#33021;&#22810;&#27425;&#35745;&#31639;&#65292;&#30456;&#23545;&#30340;&#36793;&#32536;&#37096;&#20998;&#22312;shift&#20013;&#35745;&#31639;&#27425;&#25968;&#36739;&#23569;</span>
<span style="color: #228b22;">void</span> <span style="color: #0000ff;">BackpropagateFnc</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; &amp;<span style="color: #a0522d;">in</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; &amp;<span style="color: #a0522d;">out</span>,
                      <span style="color: #a020f0;">const</span> <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; &amp;<span style="color: #a0522d;">out_diff</span>, <span style="color: #228b22;">CuMatrixBase</span>&lt;BaseFloat&gt; *<span style="color: #a0522d;">in_diff</span>) {
  <span style="color: #b22222;">// </span><span style="color: #b22222;">useful dims</span>
  <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">num_patches</span> = input_dim_ / pool_stride_;
  <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">num_pools</span> = 1 + (num_patches - pool_size_) / pool_step_;
  <span style="color: #b22222;">//</span><span style="color: #b22222;">scale &#25968;&#32452;</span>
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">int32</span>&gt; <span style="color: #a0522d;">patch_summands</span>(num_patches, 0);
  in_diff-&gt;SetZero(); <span style="color: #b22222;">// </span><span style="color: #b22222;">reset</span>
  <span style="color: #b22222;">//</span><span style="color: #b22222;">&#36941;&#21382;&#25152;&#26377;pool&#36755;&#20986;</span>
  <span style="color: #a020f0;">for</span>(<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">q</span>=0; q&lt;num_pools; q++) { <span style="color: #b22222;">// </span><span style="color: #b22222;">sum</span>
    <span style="color: #a020f0;">for</span>(<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">r</span>=0; r&lt;pool_size_; r++) {
      <span style="color: #b22222;">//</span><span style="color: #b22222;">&#23545;&#24212;q&#26102;&#30340;&#36755;&#20837;</span>
      <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">p</span> = r + q * pool_step_; <span style="color: #b22222;">// </span><span style="color: #b22222;">patch number</span>
      <span style="color: #228b22;">CuSubMatrix</span>&lt;BaseFloat&gt; <span style="color: #a0522d;">in_p</span>(in.ColRange(<span style="color: #228b22;">p</span>*<span style="color: #a0522d;">pool_stride_</span>, pool_stride_));
      <span style="color: #228b22;">CuSubMatrix</span>&lt;BaseFloat&gt; <span style="color: #a0522d;">out_q</span>(out.ColRange(<span style="color: #228b22;">q</span>*<span style="color: #a0522d;">pool_stride_</span>, pool_stride_));
      <span style="color: #228b22;">CuSubMatrix</span>&lt;BaseFloat&gt; <span style="color: #a0522d;">tgt</span>(in_diff-&gt;ColRange(<span style="color: #228b22;">p</span>*<span style="color: #a0522d;">pool_stride_</span>, pool_stride_));
      <span style="color: #228b22;">CuMatrix</span>&lt;BaseFloat&gt; <span style="color: #a0522d;">src</span>(out_diff.ColRange(<span style="color: #228b22;">q</span>*<span style="color: #a0522d;">pool_stride_</span>, pool_stride_));
      <span style="color: #b22222;">//</span><span style="color: #b22222;">find max mask</span>
      <span style="color: #228b22;">CuMatrix</span>&lt;BaseFloat&gt; <span style="color: #a0522d;">mask</span>;
      in_p.EqualElementMask(out_q, &amp;mask);
      src.MulElements(mask);
      tgt.AddMat(1.0, src);
      patch_summands[p] += 1;
    }
  }
  <span style="color: #b22222;">//</span><span style="color: #b22222;">scale&#25805;&#20316;</span>
  <span style="color: #a020f0;">for</span>(<span style="color: #228b22;">int32</span> <span style="color: #a0522d;">p</span>=0; p&lt;num_patches; p++) {
    <span style="color: #228b22;">CuSubMatrix</span>&lt;BaseFloat&gt; <span style="color: #a0522d;">tgt</span>(in_diff-&gt;ColRange(<span style="color: #228b22;">p</span>*<span style="color: #a0522d;">pool_stride_</span>, pool_stride_));
    KALDI_ASSERT(patch_summands[p] &gt; 0); <span style="color: #b22222;">// </span><span style="color: #b22222;">patch at least in one pool</span>
    tgt.Scale(1.0/patch_summands[p]);
  }
}
</pre>
</div>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> 一些工具解析</h3>
<div class="outline-text-3" id="text-5-5">
</div><div id="outline-container-sec-5-5-1" class="outline-4">
<h4 id="sec-5-5-1"><span class="section-number-4">5.5.1</span> ali-to-post: make_pair&lt;alignment, 1.0&gt;, Convert alignments to viterbi style posteriors</h4>
<div class="outline-text-4" id="text-5-5-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #228b22;">void</span> <span style="color: #0000ff;">AlignmentToPosterior</span>(<span style="color: #a020f0;">const</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span>&lt;int32&gt; &amp;<span style="color: #a0522d;">ali</span>,
                          <span style="color: #a0522d;">Posterior</span> *post) {
  post-&gt;clear();
  post-&gt;resize(ali.size());
  <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">size_t</span> <span style="color: #a0522d;">i</span> = 0; i &lt; ali.size(); i++) {
    (*post)[i].resize(1);
    (*post)[i][0].first = ali[i];
    (*post)[i][0].second = 1.0;
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-5-2" class="outline-4">
<h4 id="sec-5-5-2"><span class="section-number-4">5.5.2</span> kaldi log(base/kaldi-error.h)</h4>
<div class="outline-text-4" id="text-5-5-2">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #a020f0;">class</span> <span style="color: #228b22;">KaldiLogMessage</span> {
 <span style="color: #a020f0;">public</span>:
  <span style="color: #a020f0;">inline</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">ostream</span> &amp;<span style="color: #0000ff;">stream</span>() { <span style="color: #a020f0;">return</span> ss; }
  <span style="color: #0000ff;">KaldiLogMessage</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">func</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">file</span>, <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">line</span>);
  ~<span style="color: #0000ff;">KaldiLogMessage</span>() { fprintf(stderr, <span style="color: #8b2252;">"%s\n"</span>, ss.str().c_str()); }
 <span style="color: #a020f0;">private</span>:
  <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">ostringstream</span> <span style="color: #a0522d;">ss</span>;
};

<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">KALDI_LOG</span> <span style="color: #008b8b;">kaldi</span>::<span style="color: #0000ff;">KaldiLogMessage</span>(__func__, __FILE__, __LINE__).stream()

<span style="color: #008b8b;">KaldiLogMessage</span>::<span style="color: #0000ff;">KaldiLogMessage</span>(<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">func</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">file</span>,
                                 <span style="color: #228b22;">int32</span> <span style="color: #a0522d;">line</span>) {
  <span style="color: #a020f0;">this</span>-&gt;stream() &lt;&lt; <span style="color: #8b2252;">"LOG ("</span> &lt;&lt; GetProgramName() &lt;&lt; func &lt;&lt; <span style="color: #8b2252;">"():"</span>
                 &lt;&lt; GetShortFileName(file) &lt;&lt; <span style="color: #8b2252;">':'</span> &lt;&lt; line &lt;&lt; <span style="color: #8b2252;">") "</span>;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-5-3" class="outline-4">
<h4 id="sec-5-5-3"><span class="section-number-4">5.5.3</span> kaldi中的并行run.pl</h4>
<div class="outline-text-4" id="text-5-5-3">
</div><ol class="org-ol"><li><a id="sec-5-5-3-1" name="sec-5-5-3-1"></a>主要特点<br  /><div class="outline-text-5" id="text-5-5-3-1">
<ol class="org-ol">
<li>错误日志
</li>
<li>计算时间
</li>
<li>在log文件首行打印所执行命令的实际参数信息
</li>
<li>因此在不并行的时候也能看到使用$cmd
</li>
</ol>
</div>
</li>
<li><a id="sec-5-5-3-2" name="sec-5-5-3-2"></a>示例<br  /><div class="outline-text-5" id="text-5-5-3-2">
<div class="org-src-container">

<pre class="src src-sh">$<span style="color: #a0522d;">cmd</span> <span style="color: #a0522d;">JOB</span>=1:$<span style="color: #a0522d;">nj</span> $<span style="color: #a0522d;">dir</span>/log/acc_tree.JOB.log <span style="color: #8b2252;">\</span>
    acc-tree-stats  --ci-phones=$<span style="color: #a0522d;">ciphonelist</span> $<span style="color: #a0522d;">alidir</span>/final.mdl <span style="color: #8b2252;">"$feats"</span> <span style="color: #8b2252;">\</span>
     <span style="color: #8b2252;">"ark:gunzip -c $alidir/ali.JOB.gz|"</span> $<span style="color: #a0522d;">dir</span>/JOB.treeacc || <span style="color: #a020f0;">exit</span> 1;
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#31561;&#20215;&#20110;&#22914;&#19979;shell</span>
<span style="color: #a020f0;">for</span> ((<span style="color: #a0522d;">i</span>=1; i&lt;=$<span style="color: #a0522d;">JOB</span>; i++));
<span style="color: #a020f0;">do</span>
{
   <span style="color: #b22222;">#</span><span style="color: #b22222;">my operate</span>
}&amp; <span style="color: #b22222;">#</span><span style="color: #b22222;">&#24182;&#34892;</span>
<span style="color: #a020f0;">done</span>
<span style="color: #483d8b;">wait</span> <span style="color: #b22222;">#</span><span style="color: #b22222;">&#31561;&#24453;&#25152;&#26377;&#23376;&#36827;&#31243;&#32467;&#26463;</span>
</pre>
</div>
</div>
</li>
<li><a id="sec-5-5-3-3" name="sec-5-5-3-3"></a>run.pl源码<br  /><div class="outline-text-5" id="text-5-5-3-3">
<div class="org-src-container">

<pre class="src src-perl"><span style="color: #b22222;">#</span><span style="color: #b22222;">JOB</span>
<span style="color: #a020f0;">if</span> ($<span style="color: #a0522d;">ARGV</span>[0] =~ m<span style="color: #8b2252;">/^([\w_][\w\d_]*)+=(\d+):(\d+)$/</span>) { <span style="color: #b22222;"># e.g. JOB=1:10</span>
    $<span style="color: #a0522d;">jobname</span> = $<span style="color: #a0522d;">1</span>;
    $<span style="color: #a0522d;">jobstart</span> = $<span style="color: #a0522d;">2</span>;
    $<span style="color: #a0522d;">jobend</span> = $<span style="color: #a0522d;">3</span>;
}
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#21019;&#24314;&#23376;&#36827;&#31243;</span>
<span style="color: #a020f0;">for</span> ($<span style="color: #a0522d;">jobid</span> = $<span style="color: #a0522d;">jobstart</span>; $<span style="color: #a0522d;">jobid</span> &lt;= $<span style="color: #a0522d;">jobend</span>; $<span style="color: #a0522d;">jobid</span>++) {
  $<span style="color: #a0522d;">childpid</span> = fork();
}
<span style="color: #b22222;">#</span><span style="color: #b22222;">&#31561;&#24453;&#23376;&#36827;&#31243;&#32467;&#26463;</span>
<span style="color: #a020f0;">for</span> ($<span style="color: #a0522d;">jobid</span> = $<span style="color: #a0522d;">jobstart</span>; $<span style="color: #a0522d;">jobid</span> &lt;= $<span style="color: #a0522d;">jobend</span>; $<span style="color: #a0522d;">jobid</span>++) {
  $<span style="color: #a0522d;">r</span> = wait();
  <span style="color: #a020f0;">if</span> ($<span style="color: #a0522d;">r</span> == -1) { <span style="color: #a020f0;">die</span> <span style="color: #8b2252;">"Error waiting for child process"</span>; } <span style="color: #b22222;"># should never happen.</span>
  <span style="color: #a020f0;">if</span> ($? != 0) { $<span style="color: #a0522d;">numfail</span>++; $<span style="color: #a0522d;">ret</span> = 1; } <span style="color: #b22222;"># The child process failed.</span>
}
</pre>
</div>
</div>
</li></ol>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Kaldi Keypoint</h2>
<div class="outline-text-2" id="text-6">
</div><ol class="org-ol"><li><a id="sec-6-0-0-1" name="sec-6-0-0-1"></a><span class="todo TODO">TODO</span> SGMM<br  /></li>
<li><a id="sec-6-0-0-2" name="sec-6-0-0-2"></a><span class="todo TODO">TODO</span> MAP, Mlle<br  /></li>
<li><a id="sec-6-0-0-3" name="sec-6-0-0-3"></a><span class="todo TODO">TODO</span> occ<br  /></li>
<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> GMM</h3>
<div class="outline-text-3" id="text-6-1">
</div><div id="outline-container-sec-6-1-1" class="outline-4">
<h4 id="sec-6-1-1"><span class="section-number-4">6.1.1</span> <span class="todo TODO">TODO</span> 如何加高斯，gmm split &amp; merge</h4>
</div>
<div id="outline-container-sec-6-1-2" class="outline-4">
<h4 id="sec-6-1-2"><span class="section-number-4">6.1.2</span> 训练时每个模型的高斯数不一定相等，有意思哈！</h4>
</div>
<div id="outline-container-sec-6-1-3" class="outline-4">
<h4 id="sec-6-1-3"><span class="section-number-4">6.1.3</span> AmGMM.Split()</h4>
<div class="outline-text-4" id="text-6-1-3">
<p>
$$id=arg max w_{k}$$
$$w_{n}=w_{max}/2$$
$$\mu_{n}=\mu_{id}$$
$$\Sigma_{n}= \Sigma_{id}$$
\(w_{n}\) 为新加入高斯权值，\(\mu\) 均值， \(\Sigma\) 方差
</p>
<pre class="example">
大侠的解释：从EM的角度考虑如何给GMM加高斯，为了增加模型的精度，所以需分割权值最大的Gauss，根据上面的公式计算，
但是这样EM迭代时，新加入Gauss会与原Gauss一样，所以还需加入扰动。
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 训练方式</h3>
<div class="outline-text-3" id="text-6-2">
</div><div id="outline-container-sec-6-2-1" class="outline-4">
<h4 id="sec-6-2-1"><span class="section-number-4">6.2.1</span> lda(Linear Discriminant Analysis)</h4>
<div class="outline-text-4" id="text-6-2-1">
<ul class="org-ul">
<li>降维，且降维后使S_b 类间距要大,类内距离S_w 要小，等价于求WS_b W/WS_w W, 经推导最终
</li>
</ul>
<p>
等价于求S_w 的逆乘S_b 的特征值和特征向量。
</p>
<ul class="org-ul">
<li>经典HMM状态内帧间独立性的假设使得帧间相关的信息在HMM模型中没有得到很好的利用,而帧间
</li>
</ul>
<p>
线性判别分析相关信息对识别率的提高有很重要的作用。
</p>
</div>
</div>

<div id="outline-container-sec-6-2-2" class="outline-4">
<h4 id="sec-6-2-2"><span class="section-number-4">6.2.2</span> mllt(Maximum Likelihood Linear Transformation)</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
目前的语音识别系统大多都采用隐马尔可夫模型(Hidden Markov Model, HMM),但在实际应用中为了减少存
储空间和降低计算量,通常会假设输入HMM的协方差矩阵仅为对角线上有值(其他元素均为 0)。这样,通过PCA和LDA
得到的协方差矩阵不符合应用 HMM 的假设,造成失真从而影响识别率。本文引进最大似然线性转换(Maximum
Likelihood Linear Transformation, MLLT)改进PCA和LDA。与PCA和LDA相似,MLLT也是通过求取一个变换矩阵来
变换矢量空间, MLLT不会对数据进行降维,但可使变换后模式样本的协方差矩阵对角化。这样,通过MLLT后得到的
协方差矩阵就可以满足应用 HMM 的假设了。
</p>
</div>
</div>

<div id="outline-container-sec-6-2-3" class="outline-4">
<h4 id="sec-6-2-3"><span class="section-number-4">6.2.3</span> sat</h4>
<div class="outline-text-4" id="text-6-2-3">
<p>
自适应
</p>
</div>
</div>
<div id="outline-container-sec-6-2-4" class="outline-4">
<h4 id="sec-6-2-4"><span class="section-number-4">6.2.4</span> sgmm(subspace gmm)</h4>
<div class="outline-text-4" id="text-6-2-4">
<p>
这个是什么原理，不懂哈
</p>
</div>
</div>
<div id="outline-container-sec-6-2-5" class="outline-4">
<h4 id="sec-6-2-5"><span class="section-number-4">6.2.5</span> mmi</h4>
<div class="outline-text-4" id="text-6-2-5">
<p>
Maximum Mutual Information(MMI)
</p>

<p>
Minimum Phone Error(MPE)
Minimum Word Error(MWE)
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Kaldi二进制文件查看</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>gmm-copy &#x2013;binary=false exp/mono/0.mdl - | less
</li>
<li>copy-tree &#x2013;binary=false exp/mono/tree - | less
</li>
<li>show-alignments data/lang/phones.txt exp/mono/0.mdl ark:exp/mono/cur.ali | less
</li>
<li>show-transitions data/lang/phones.txt exp/mono/0.mdl
</li>
<li>sum-tree-stats &#x2013;binary=false - exp/tri1/treeacc | less
</li>
<li>utils/int2sym.pl data/lang/phones.txt &lt; exp/tri1/questions.int
</li>
<li>ali-to-phones exp_decode/mono_ali/final.mdl "ark:gunzip -c exp_decode/mono_ali/ali.1.gz|" ark,t:- | less
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> fst</h2>
<div class="outline-text-2" id="text-8">
<p>
Created by:robin1001 <span class="timestamp-wrapper"><span class="timestamp">&lt;2014-08-27 三&gt;</span></span>
</p>
</div>
<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> 定义</h3>
<div class="outline-text-3" id="text-8-1">
<ul class="org-ul">
<li>P(Q1, Q2): Q1到Q2的所有路径
</li>
<li>P(Q1, x, Q2): 接受x的Q1-&gt;Q2 | A
</li>
<li>P(Q1, x, y, Q2): 接受x,输出y的Q1-&gt;Q2 | T
</li>
<li>[A](x): 接受x的所有路径 | A
</li>
<li>[T](x, y) 接受x,输出y的所有路径 | T
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> 空转移</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>算法插入
</li>
<li>一对多的映射（比如&#x2026;)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> A &amp; T</h3>
<div class="outline-text-3" id="text-8-3">
<p>
在Acceptor中使input和output相同即可模拟transducer
</p>
</div>
</div>

<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> 运算</h3>
<div class="outline-text-3" id="text-8-4">
<ul class="org-ul">
<li>union: 或运算
</li>
<li>concate: 连接
</li>
<li>closure: 闭包
</li>
<li>reverse: 反转
</li>
<li>inverse: 逆，input和output对调
</li>
<li>project: T-&gt;A
</li>
<li>composition: 组合，将不同层次的信息组合起来
</li>
<li>含epsilon和不含epsilon两种模型
</li>
<li>组合算法
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5"><span class="section-number-3">8.5</span> 确定化</h3>
<div class="outline-text-3" id="text-8-5">
</div><div id="outline-container-sec-8-5-1" class="outline-4">
<h4 id="sec-8-5-1"><span class="section-number-4">8.5.1</span> 何为确定化</h4>
<div class="outline-text-4" id="text-8-5-1">
<ol class="org-ol">
<li>单一初始状态
</li>
<li>一个状态不存在input相同的两条出弧
</li>
<li>openfst和ATT FSM将epsilon作为一个正常的symbol
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-8-5-2" class="outline-4">
<h4 id="sec-8-5-2"><span class="section-number-4">8.5.2</span> 确定化算法</h4>
<div class="outline-text-4" id="text-8-5-2">
<ul class="org-ul">
<li>算法简单理解：合并公共前缀
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-8-6" class="outline-3">
<h3 id="sec-8-6"><span class="section-number-3">8.6</span> 最小化</h3>
<div class="outline-text-3" id="text-8-6">
<ul class="org-ul">
<li>算法简单理解：合并公共后缀
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-8-7" class="outline-3">
<h3 id="sec-8-7"><span class="section-number-3">8.7</span> Weight Pushing</h3>
<div class="outline-text-3" id="text-8-7">
<ul class="org-ul">
<li>权重可以向init states | final states移动
</li>
<li>应用：arc权重的归一化
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-8-8" class="outline-3">
<h3 id="sec-8-8"><span class="section-number-3">8.8</span> Epsilon消除</h3>
</div>
<div id="outline-container-sec-8-9" class="outline-3">
<h3 id="sec-8-9"><span class="section-number-3">8.9</span> linux fst 程序编译</h3>
<div class="outline-text-3" id="text-8-9">
<p>
g++ -O0 fst.cpp -o fst -I/home/robin1001/kaldi/kaldi-trunk/tools/openfst/include -L/home/robin1001/kaldi/kaldi-trunk/tools/openfst/lib -lfst -Wl,-rpath,/home/robin1001/kaldi/kaldi-trunk/tools/openfst/lib
-Wl,rpath=&lt;your_lib_dir&gt;，使得execute记住链接库的位置
</p>
</div>
</div>
<div id="outline-container-sec-8-10" class="outline-3">
<h3 id="sec-8-10"><span class="section-number-3">8.10</span> 数据结构</h3>
<div class="outline-text-3" id="text-8-10">
</div><div id="outline-container-sec-8-10-1" class="outline-4">
<h4 id="sec-8-10-1"><span class="section-number-4">8.10.1</span> StdArc</h4>
<div class="outline-text-4" id="text-8-10-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">StdArc</span> {
 <span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">int</span> <span style="color: #228b22;">Label</span>;
 <span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">TropicalWeight</span> <span style="color: #228b22;">Weight</span>;  <span style="color: #b22222;">// </span><span style="color: #b22222;">see "FST Weights" below </span>
 <span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">int</span> <span style="color: #228b22;">StateId</span>; 

 <span style="color: #228b22;">Label</span> <span style="color: #a0522d;">ilabel</span>;
 <span style="color: #228b22;">Label</span> <span style="color: #a0522d;">olabel</span>;
 <span style="color: #228b22;">Weight</span> <span style="color: #a0522d;">weight</span>;
 <span style="color: #228b22;">StateId</span> <span style="color: #a0522d;">nextstate</span>;
};
<span style="color: #a020f0;">for</span> (<span style="color: #228b22;">ArcIterator</span>&lt;StdFst&gt; <span style="color: #a0522d;">aiter</span>(fst, i); !aiter.Done(); aiter.Next())
  <span style="color: #a020f0;">const</span> <span style="color: #228b22;">StdArc</span> &amp;<span style="color: #a0522d;">arc</span> = aiter.Value();
<span style="color: #228b22;">Matcher</span>&lt;StdFst&gt; <span style="color: #0000ff;">matcher</span>(fst, MATCH_INPUT);
matcher.SetState(i);
<span style="color: #a020f0;">if</span> (matcher.Find(l)) 
  <span style="color: #a020f0;">for</span> (; !matcher.Done(); matcher.Next())
     <span style="color: #a020f0;">const</span> <span style="color: #228b22;">StdArc</span> &amp;<span style="color: #a0522d;">arc</span> = matcher.Value();
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-10-2" class="outline-4">
<h4 id="sec-8-10-2"><span class="section-number-4">8.10.2</span> fst</h4>
<div class="outline-text-4" id="text-8-10-2">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #b22222;">//</span><span style="color: #b22222;">&#25277;&#35937;&#31867;</span>
<span style="color: #228b22;">Fst</span>&lt;Arc&gt;
<span style="color: #228b22;">ExpandedFst</span>&lt;Arc&gt;: +NumStates();
<span style="color: #228b22;">MutableFst</span>&lt;Arc&gt;: &#21487;&#21464;&#30340;fst&#65292;&#22914;AddStates(), SetStart()

<span style="color: #b22222;">//</span><span style="color: #b22222;">&#23454;&#29616;</span>
<span style="color: #228b22;">VectorFst</span>&lt;Arc&gt;: <span style="color: #a020f0;">mutable</span> fst
<span style="color: #228b22;">ConstFst</span>&lt;Arc&gt;:  immutable fst
<span style="color: #228b22;">ComposeFst</span>&lt;Arc&gt;

<span style="color: #b22222;">//</span><span style="color: #b22222;">StdArc</span>
ilabel, olabel, weight(Weight), <span style="color: #228b22;">nextstate</span>

<span style="color: #b22222;">//</span><span style="color: #b22222;">Weight</span>
<span style="color: #a0522d;">TropicalWeight</span>, LogWeight, ProductWeight

<span style="color: #b22222;">//</span><span style="color: #b22222;">Fst</span>
<span style="color: #228b22;">Start</span>(), Final(), Read(), etc ...

<span style="color: #b22222;">//</span><span style="color: #b22222;">Mutable Fst</span>
<span style="color: #228b22;">SetStart</span>(), SetFinal(), AddState(), AddArc()

<span style="color: #b22222;">//</span><span style="color: #b22222;">StateIterator</span>
Done(), Value(), Next(), Reset()

<span style="color: #b22222;">//</span><span style="color: #b22222;">ArcIterator</span>
Done(), Value(), Next(), Reset()

<span style="color: #b22222;">//</span><span style="color: #b22222;">FstImple: public Fst</span>
type_, isymbols_, osymbols_, <span style="color: #228b22;">ref_count_</span>

<span style="color: #b22222;">//</span><span style="color: #b22222;">SymbolTable Impl: &#21253;&#35013;SymbolTable</span>
<span style="color: #a0522d;">map</span>&lt;<span style="color: #228b22;">int64</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span>*&gt; key_map_;
<span style="color: #228b22;">vector</span>&lt;<span style="color: #a020f0;">const</span> <span style="color: #228b22;">char</span> *&gt; <span style="color: #a0522d;">symbols_</span>;

<span style="color: #b22222;">//</span><span style="color: #b22222;">VectorState</span>
final, <span style="color: #228b22;">Vector</span>&lt;A&gt; <span style="color: #a0522d;">arcs</span>, niepsilon, <span style="color: #228b22;">noepsilon</span>

<span style="color: #b22222;">//</span><span style="color: #b22222;">VectorFstBaseImpl: &#36825;&#20010;&#31867;&#26159;VectorFst&#30340;&#19968;&#31995;&#21015;&#23454;&#29616;</span>
<span style="color: #a0522d;">state_</span>;
<span style="color: #228b22;">vector</span>&lt;<span style="color: #228b22;">State</span> *&gt;<span style="color: #a0522d;">states</span>;
<span style="color: #228b22;">StateId</span> <span style="color: #0000ff;">AddState</span>() { states.push_back(<span style="color: #a020f0;">new</span> <span style="color: #228b22;">State</span>())
etc ...
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-8-11" class="outline-3">
<h3 id="sec-8-11"><span class="section-number-3">8.11</span> 半环</h3>
<div class="outline-text-3" id="text-8-11">
</div><div id="outline-container-sec-8-11-1" class="outline-4">
<h4 id="sec-8-11-1"><span class="section-number-4">8.11.1</span> 幺半群</h4>
<div class="outline-text-4" id="text-8-11-1">
<p>
三元组&lt;A, *, 1&gt;, 其中：
</p>
<ol class="org-ol">
<li>1为恒等元素，1*a=a*1
</li>
<li>a*b=b*a
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-8-11-2" class="outline-4">
<h4 id="sec-8-11-2"><span class="section-number-4">8.11.2</span> 半环</h4>
<div class="outline-text-4" id="text-8-11-2">
<p>
五元组 &lt;A, +, *, 0, 1&gt;, 其中
</p>
<ol class="org-ol">
<li>&lt;A, +, 0&gt; 为交换幺半群
</li>
<li>&lt;A, *, 1&gt; 为幺半群
</li>
<li>a*(b+c) = a*b+a*c
</li>
<li>0*a = a*0 = 0
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-8-11-3" class="outline-4">
<h4 id="sec-8-11-3"><span class="section-number-4">8.11.3</span> Moore &amp; Mealy</h4>
<div class="outline-text-4" id="text-8-11-3">
<ul class="org-ul">
<li>Morre机：每个状态产生输出
</li>
<li>Mealy机：每个移动产生输出
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-8-12" class="outline-3">
<h3 id="sec-8-12"><span class="section-number-3">8.12</span> openfst</h3>
<div class="outline-text-3" id="text-8-12">
<p>
fstcompile &#x2013;isymbols=isyms.txt &#x2013;osymbols=osyms.txt text.fst binary.fst
fstdraw &#x2013;isymbols=isyms.txt &#x2013;osymbols=osyms.txt binary.fst binary.dot
dot -Tps binary.dot &gt;binary.ps
</p>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Google C++ Style Guide</h2>
<div class="outline-text-2" id="text-9">
<ol class="org-ol">
<li>函数超过10行时不要使用內联
</li>
<li>-inl.h內联函数实现文件 | 定义函数模板
</li>
<li>输入：const型，输出参数：指针
</li>
<li>最好给纯接口类加上Interface后缀
</li>
<li>名称为foo_的变量其访问函数为foo()，而其修改器(mutator)则为set_foo()，访问器常在头文件中定义为内联函数。
</li>
<li>请按下面的规则次序来定义类：公共成员位于私有成员前；方法位于数据成员前(变量)等等。
</li>
<li>scoped_ptr | shared_ptr
</li>
<li>使用cpplint.py来检测风格错误
</li>
<li>类型转换(Casting),需要类型转换时请使用static_cast&lt;&gt;()
</li>
<li>类成员以下划线结束 int val_;
</li>
<li>禁止使用异常
</li>
<li>常量命名, 在名称前加k：kDaysInAWeek
</li>
</ol>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #a020f0;">const</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">kDaysInAWeek</span> = 7;
</pre>
</div>
<ol class="org-ol">
<li>函数形式参数位置和花括号位置
</li>
</ol>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #228b22;">ReturnType</span> <span style="color: #008b8b;">ClassName</span>::<span style="color: #0000ff;">ReallyLongFunctionName</span>(<span style="color: #228b22;">Type</span> <span style="color: #a0522d;">par_name1</span>) {
}
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: robin1001</p>
<p class="date">Created: 2015-03-11 三 11:52</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.4.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
