---
title:  Kaldi学习笔记
category:  note
---
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Kaldi学习笔记</title>
<!-- 2014-11-26 三 22:00 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="robin1001" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="/css/worg.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Kaldi学习笔记</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. keynotes</a></li>
<li><a href="#sec-2">2. 问题</a></li>
<li><a href="#sec-3">3. kaldi timit</a>
<ul>
<li><a href="#sec-3-1">3.1. 数据准备</a></li>
<li><a href="#sec-3-2">3.2. 特征提取</a></li>
<li><a href="#sec-3-3">3.3. MonoPhone Training &amp; Decoding</a></li>
<li><a href="#sec-3-4">3.4. tri1: Deltas + Delta-Deltas Training &amp; Decoding</a></li>
<li><a href="#sec-3-5">3.5. tri2 : LDA + MLLT Training &amp; Decoding</a></li>
<li><a href="#sec-3-6">3.6. DNN Hybrid Training &amp; Decoding</a></li>
<li><a href="#sec-3-7">3.7. Getting Results</a></li>
</ul>
</li>
<li><a href="#sec-4">4. kaldi doc</a>
<ul>
<li><a href="#sec-4-1">4.1. kaldi tutorial</a></li>
<li><a href="#sec-4-2">4.2. Kaldi I/O mechanisms</a></li>
<li><a href="#sec-4-3">4.3. The Kaldi Matrix library</a></li>
<li><a href="#sec-4-4">4.4. The build process(how Kaldi is compiled)</a></li>
<li><a href="#sec-4-5">4.5. Parsing command-line Options</a></li>
<li><a href="#sec-4-6">4.6. Kaldi logging and error-reporting</a></li>
<li><a href="#sec-4-7">4.7. Decoders used in the Kaldi toolkit</a></li>
<li><a href="#sec-4-8">4.8. HMM topology and transition modeling</a></li>
<li><a href="#sec-4-9">4.9. How decision trees are used in Kaldi</a></li>
<li><a href="#sec-4-10">4.10. Decision tree internals</a></li>
<li><a href="#sec-4-11">4.11. Decoding graph construction in Kaldi</a></li>
<li><a href="#sec-4-12">4.12. Decoding-graph creation recipe(training time)</a></li>
<li><a href="#sec-4-13">4.13. Other kaldi utilities</a></li>
<li><a href="#sec-4-14">4.14. Clustering mechanisms in Kaldi</a></li>
<li><a href="#sec-4-15">4.15. Acoustic modeling code</a></li>
<li><a href="#sec-4-16">4.16. Deep Neural Networks in Kaldi</a></li>
</ul>
</li>
<li><a href="#sec-5">5. 训练方式</a>
<ul>
<li><a href="#sec-5-1">5.1. lda(Linear Discriminant Analysis)</a></li>
<li><a href="#sec-5-2">5.2. mllt(Maximum Likelihood Linear Transformation)</a></li>
<li><a href="#sec-5-3">5.3. sat</a></li>
<li><a href="#sec-5-4">5.4. sgmm(subspace gmm)</a></li>
<li><a href="#sec-5-5">5.5. mmi</a></li>
</ul>
</li>
<li><a href="#sec-6">6. kaldi中的数据文件及其作用</a>
<ul>
<li><a href="#sec-6-1">6.1. 数据准备(其中大部分文件均需要排序)</a></li>
<li><a href="#sec-6-2">6.2. 字典准备</a></li>
<li><a href="#sec-6-3">6.3. lang(此处有个中间文件utils/apply_map.pl phone_map）</a></li>
<li><a href="#sec-6-4">6.4. format_data</a></li>
<li><a href="#sec-6-5">6.5. 特征提取</a></li>
<li><a href="#sec-6-6">6.6. 决策树</a></li>
<li><a href="#sec-6-7">6.7. 训练</a></li>
</ul>
</li>
<li><a href="#sec-7">7. reading tools</a></li>
<li><a href="#sec-8">8. fst</a>
<ul>
<li><a href="#sec-8-1">8.1. 定义</a></li>
<li><a href="#sec-8-2">8.2. 空转移</a></li>
<li><a href="#sec-8-3">8.3. A &amp; T</a></li>
<li><a href="#sec-8-4">8.4. 运算</a></li>
<li><a href="#sec-8-5">8.5. 确定化</a></li>
<li><a href="#sec-8-6">8.6. 最小化</a></li>
<li><a href="#sec-8-7">8.7. Weight Pushing</a></li>
<li><a href="#sec-8-8">8.8. Epsilon消除</a></li>
<li><a href="#sec-8-9">8.9. linux fst 程序编译</a></li>
<li><a href="#sec-8-10">8.10. 数据结构</a></li>
<li><a href="#sec-8-11">8.11. 半环</a></li>
<li><a href="#sec-8-12">8.12. openfst</a></li>
</ul>
</li>
<li><a href="#sec-9">9. Google C++ Style Guide</a></li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> keynotes</h2>
<div class="outline-text-2" id="text-1">
<pre class="example">
1. train_cmd在cmd.sh中定义，训练方式选择
2. 所有日志记录文件保存exp目录下
3. utils/parse_option.sh
   + config参数及文件是否存在
4. ark, archive, data all in one file
5. rspecifier, wspecifier
6. $dir一般输出哈 
7. cmd=run.pl
8. timit中仅用到音素级标注.PHN, 并未用到词级.txt
</pre>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 问题</h2>
<div class="outline-text-2" id="text-2">
</div><ol class="org-ol"><li><a id="sec-2-0-0-1" name="sec-2-0-0-1"></a><span class="todo TODO">TODO</span> 使用kaldi搭建拨号系统<br  /></li>
<li><a id="sec-2-0-0-2" name="sec-2-0-0-2"></a><span class="todo TODO">TODO</span> SGMM<br  /></li>
<li><a id="sec-2-0-0-3" name="sec-2-0-0-3"></a><span class="done DONE">DONE</span> kaldi &amp; htk 在训练上的相同点&amp;不同点&amp;对应<br  /></li>
<li><a id="sec-2-0-0-4" name="sec-2-0-0-4"></a><span class="done DONE">DONE</span> 决策树在哪儿，viterbi对齐<br  /></li>
<li><a id="sec-2-0-0-5" name="sec-2-0-0-5"></a><span class="done DONE">DONE</span> 训练中LDA &amp; MLLT &amp; MMI是必须的吗<br  /></li>
<li><a id="sec-2-0-0-6" name="sec-2-0-0-6"></a><span class="done DONE">DONE</span> fst的具体使用方式<br  /></li>
<li><a id="sec-2-0-0-7" name="sec-2-0-0-7"></a><span class="done DONE">DONE</span> wfst已经生成，如何解码，和htk的区别<br  /></li>
<li><a id="sec-2-0-0-8" name="sec-2-0-0-8"></a><span class="done DONE">DONE</span> for (fst::ArcIterator&lt;fst::Fst&lt;Arc&gt; &gt; aiter(fst_, state);<br  /><div class="outline-text-5" id="text-2-0-0-8">
<p>
!aiter.Done();
aiter.Next())
</p>
</div>
</li>
<li><a id="sec-2-0-0-9" name="sec-2-0-0-9"></a><span class="done DONE">DONE</span> std min max swap &#x2026;<br  /></li>
<li><a id="sec-2-0-0-10" name="sec-2-0-0-10"></a><span class="todo TODO">TODO</span> token gc引用计数原理<br  /></li>
<li><a id="sec-2-0-0-11" name="sec-2-0-0-11"></a><span class="done DONE">DONE</span> decodable-&gt;LogLikelihood(frame, arc.ilabel)<br  /></li>
<li><a id="sec-2-0-0-12" name="sec-2-0-0-12"></a><span class="done DONE">DONE</span> Tree-based State Tying for High Accuracy Acoustic Modeling<br  /></li>
<li><a id="sec-2-0-0-13" name="sec-2-0-0-13"></a>unsorted_map<br  /></li>
<li><a id="sec-2-0-0-14" name="sec-2-0-0-14"></a><span class="done DONE">DONE</span> 对齐<br  /></li>
<li><a id="sec-2-0-0-15" name="sec-2-0-0-15"></a><span class="todo TODO">TODO</span> 解码时有类似wdnet的东西限制搜索空间吗？<br  /></li>
<li><a id="sec-2-0-0-16" name="sec-2-0-0-16"></a><span class="done DONE">DONE</span> 如何加高斯，gmm split &amp; merge, htk中是怎么增加高斯的<br  /></li>
<li><a id="sec-2-0-0-17" name="sec-2-0-0-17"></a>split<br  /><div class="outline-text-5" id="text-2-0-0-17">
<p>
id = arg max w<sub>k</sub>
</p>

<p>
w<sub>n</sub>=w<sub>max</sub>/2, w<sub>n</sub>为新加入高斯权值
</p>

<p>
u<sub>n</sub> = u<sub>id</sub>, sigma<sub>n</sub>= sigma<sub>id</sub>
</p>

<p>
why?
</p>

<p>
且训练时每个模型的高斯数不一定相等，有意思哈！
</p>
</div>
</li>

<li><a id="sec-2-0-0-18" name="sec-2-0-0-18"></a><span class="done DONE">DONE</span> Kaldi中的并行JOB utils/run.pl<br  /><ol class="org-ol"><li><a id="sec-2-0-0-18-1" name="sec-2-0-0-18-1"></a>主要特点<br  /><div class="outline-text-6" id="text-2-0-0-18-1">
<ol class="org-ol">
<li>错误日志
</li>
<li>计算时间
</li>
</ol>
</div>
</li>
<li><a id="sec-2-0-0-18-2" name="sec-2-0-0-18-2"></a>示例<br  /><div class="outline-text-6" id="text-2-0-0-18-2">
<div class="org-src-container">

<pre class="src src-sh">$<span style="color: #bebebe; font-weight: bold;">cmd</span> <span style="color: #bebebe; font-weight: bold;">JOB</span>=1:$<span style="color: #bebebe; font-weight: bold;">nj</span> $<span style="color: #bebebe; font-weight: bold;">dir</span>/log/acc_tree.JOB.log <span style="color: #ff0000;">\</span>
    acc-tree-stats  --ci-phones=$<span style="color: #bebebe; font-weight: bold;">ciphonelist</span> $<span style="color: #bebebe; font-weight: bold;">alidir</span>/final.mdl <span style="color: #ff0000;">"$feats"</span> <span style="color: #ff0000;">\</span>
     <span style="color: #ff0000;">"ark:gunzip -c $alidir/ali.JOB.gz|"</span> $<span style="color: #bebebe; font-weight: bold;">dir</span>/JOB.treeacc || <span style="color: #40e0d0; font-weight: bold;">exit</span> 1;
<span style="color: #ee82ee;">#</span><span style="color: #ee82ee;">&#31561;&#20215;&#20110;&#22914;&#19979;shell</span>
<span style="color: #40e0d0; font-weight: bold;">for</span> ((<span style="color: #bebebe; font-weight: bold;">i</span>=1; i&lt;=$<span style="color: #bebebe; font-weight: bold;">JOB</span>; i++));
<span style="color: #40e0d0; font-weight: bold;">do</span>
{
   <span style="color: #ee82ee;">#</span><span style="color: #ee82ee;">my operate</span>
}&amp; <span style="color: #ee82ee;">#</span><span style="color: #ee82ee;">&#24182;&#34892;</span>
<span style="color: #40e0d0; font-weight: bold;">done</span>
<span style="color: #ffc0cb; font-size: 110%; font-weight: bold;">wait</span> <span style="color: #ee82ee;">#</span><span style="color: #ee82ee;">&#31561;&#24453;&#25152;&#26377;&#23376;&#36827;&#31243;&#32467;&#26463;</span>
</pre>
</div>
</div>
</li>
<li><a id="sec-2-0-0-18-3" name="sec-2-0-0-18-3"></a>run.pl源码<br  /><div class="outline-text-6" id="text-2-0-0-18-3">
<div class="org-src-container">

<pre class="src src-perl"><span style="color: #ee82ee;">#</span><span style="color: #ee82ee;">JOB</span>
<span style="color: #40e0d0; font-weight: bold;">if</span> ($<span style="color: #bebebe; font-weight: bold;">ARGV</span>[0] =~ m<span style="color: #ff0000;">/^([\w_][\w\d_]*)+=(\d+):(\d+)$/</span>) { <span style="color: #ee82ee;"># e.g. JOB=1:10</span>
    $<span style="color: #bebebe; font-weight: bold;">jobname</span> = $<span style="color: #bebebe; font-weight: bold;">1</span>;
    $<span style="color: #bebebe; font-weight: bold;">jobstart</span> = $<span style="color: #bebebe; font-weight: bold;">2</span>;
    $<span style="color: #bebebe; font-weight: bold;">jobend</span> = $<span style="color: #bebebe; font-weight: bold;">3</span>;
}
<span style="color: #ee82ee;">#</span><span style="color: #ee82ee;">&#21019;&#24314;&#23376;&#36827;&#31243;</span>
<span style="color: #40e0d0; font-weight: bold;">for</span> ($<span style="color: #bebebe; font-weight: bold;">jobid</span> = $<span style="color: #bebebe; font-weight: bold;">jobstart</span>; $<span style="color: #bebebe; font-weight: bold;">jobid</span> &lt;= $<span style="color: #bebebe; font-weight: bold;">jobend</span>; $<span style="color: #bebebe; font-weight: bold;">jobid</span>++) {
  $<span style="color: #bebebe; font-weight: bold;">childpid</span> = fork();
}
<span style="color: #ee82ee;">#</span><span style="color: #ee82ee;">&#31561;&#24453;&#23376;&#36827;&#31243;&#32467;&#26463;</span>
<span style="color: #40e0d0; font-weight: bold;">for</span> ($<span style="color: #bebebe; font-weight: bold;">jobid</span> = $<span style="color: #bebebe; font-weight: bold;">jobstart</span>; $<span style="color: #bebebe; font-weight: bold;">jobid</span> &lt;= $<span style="color: #bebebe; font-weight: bold;">jobend</span>; $<span style="color: #bebebe; font-weight: bold;">jobid</span>++) {
  $<span style="color: #bebebe; font-weight: bold;">r</span> = wait();
  <span style="color: #40e0d0; font-weight: bold;">if</span> ($<span style="color: #bebebe; font-weight: bold;">r</span> == -1) { <span style="color: #40e0d0; font-weight: bold;">die</span> <span style="color: #ff0000;">"Error waiting for child process"</span>; } <span style="color: #ee82ee;"># should never happen.</span>
  <span style="color: #40e0d0; font-weight: bold;">if</span> ($? != 0) { $<span style="color: #bebebe; font-weight: bold;">numfail</span>++; $<span style="color: #bebebe; font-weight: bold;">ret</span> = 1; } <span style="color: #ee82ee;"># The child process failed.</span>
}
</pre>
</div>
</div>
</li></ol>
</li></ol>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> kaldi timit</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 数据准备</h3>
<div class="outline-text-3" id="text-3-1">
</div><ol class="org-ol"><li><a id="sec-3-1-1" name="sec-3-1-1"></a>timit_data_prepare.sh<br  /><div class="outline-text-4" id="text-3-1-1">
<ul class="org-ul">
<li>wav.scp:文件列表
</li>
<li>uttids：文件id
</li>
<li>trans：抄本
</li>
<li>utt2spk:语音&#x2013;&gt;说话人
</li>
<li>duration calc, mean, min, max
</li>
</ul>
</div>
</li>

<li><a id="sec-3-1-2" name="sec-3-1-2"></a>timit_prepare_dict.sh<br  /><div class="outline-text-4" id="text-3-1-2">
<ul class="org-ul">
<li>phone
</li>
<li>lm：音素级bigram，build-lm.sh compile-lm
</li>
</ul>
</div>
</li>
<li><a id="sec-3-1-3" name="sec-3-1-3"></a>utils/prepare_lang.sh<br  /><div class="outline-text-4" id="text-3-1-3">
<p>
与语言模型 &amp; fst相关，代码太长，暂且不看
</p>
<ul class="org-ul">
<li>sets.txt音素 sets.int 整数
</li>
<li>roots.txt "shared split aa" roots.int
</li>
<li>silence.txt nonsilence.txt context_indep.txt extra_questions.txt
</li>
<li>disambig.txt: 辅助符号
</li>
<li>phones.txt(silence.txt nosilence.txt disambig.txt)
</li>
<li>words.txt（esp 0, #0)  phones.txt(增加silence和#0,#1）
</li>
<li>align_lexicon.txt 
</li>
<li>fstcompile &#x2013;isymbols=$dir/phones.txt &#x2013;osymbols=$dir/words.txt
</li>
<li>为什么构造这样一个L.fst 0.693147180559945(log 0.5)
</li>
<li>生成的未见phones.txt word.txt L.fst L_disambig.fst
</li>
</ul>
</div>
</li>
<li><a id="sec-3-1-4" name="sec-3-1-4"></a>timit_format_data.sh<br  /><div class="outline-text-4" id="text-3-1-4">
<ul class="org-ul">
<li>将data lang数据分类规整到data\train test文件夹下
</li>
<li>例如原train.text修改为data/train/text文件
</li>
<li>准备了G.fst
</li>
</ul>
</div>
</li></ol>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 特征提取</h3>
<div class="outline-text-3" id="text-3-2">
</div><ol class="org-ol"><li><a id="sec-3-2-1" name="sec-3-2-1"></a>make_mfcc.sh<br  /><div class="outline-text-4" id="text-3-2-1">
<ol class="org-ol">
<li>conf/mfcc.conf: &#x2013;user-energy=false
</li>
<li>.parse_option.sh 得看看
</li>
<li>分割scp题特征，并行提特征ark，再连接特征列表至feats.scp
</li>
<li>log文件夹exp
</li>
</ol>
</div>
</li>

<li><a id="sec-3-2-2" name="sec-3-2-2"></a>compute_cmvn_stats.sh<br  /><div class="outline-text-4" id="text-3-2-2">
<ol class="org-ol">
<li>生成文件目录同mfcc
</li>
<li>cmvn使用到spk2utt，做什么用？
</li>
<li>cmvn是对每一个说话人做的
</li>
<li>compute-cmvn-stats: ????
</li>
</ol>
</div>
</li></ol>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> MonoPhone Training &amp; Decoding</h3>
<div class="outline-text-3" id="text-3-3">
</div><ol class="org-ol"><li><a id="sec-3-3-1" name="sec-3-3-1"></a>steps/train_mono.sh<br  /><div class="outline-text-4" id="text-3-3-1">
<ol class="org-ol">
<li>totgauss=1000
</li>
<li>compile-train-graphs 
</li>
<li>stage=-4, |-3|-2|-1
</li>
<li>feat-to-dim: 获得特征维度39
</li>
<li>gmm-init-mono 输出模型0.mdl和tree单音素树
</li>
<li>计算特征全局均值方差
</li>
<li>所有单音素表示成为一棵树
</li>
<li>data/lang/topo 初始hmm模型参数, left-right-hmm
</li>
<li>compile-train-graph 为每个训练语句构造一个解码的fst
</li>
<li>align-equal-compiled:对特征等分对齐进行初始化
</li>
<li>gmm-est: 根据对齐结果对模型进行更新，每个状态的高斯数不等
</li>
</ol>
<p>
10.gmm-align-compiled: 在fst上识别，输出对齐 
</p>
<ol class="org-ol">
<li>loop: gmm-align-compiled gmm-acc-stats-ali gmm-est
</li>
<li>add-deltas, 使用2阶和3阶差分mfcc，此时39
</li>
<li>compute-cmvn-stats计算cmvn, apply-cmvn对特征文件使用cmvn
</li>
</ol>
</div>
<ol class="org-ol"><li><a id="sec-3-3-1-1" name="sec-3-3-1-1"></a>TrainingGraphCompiler<br  /><div class="outline-text-5" id="text-3-3-1-1">
<ul class="org-ul">
<li>CompileGraphFromText
</li>
<li>MakeLinearAcceptor: 为每个语句生成一个acceptor，(ilabel, olabel, 1), 其中label为抄本当前音素
</li>
<li>compose acceptor &amp; lex_fst
</li>
<li>make cfst ContextFst
</li>
<li>ctx2word_fst
</li>
<li>trans2word_fst
</li>
</ul>
</div>
</li></ol>
</li>
<li><a id="sec-3-3-2" name="sec-3-3-2"></a>utils/mkgraph.sh<br  /><ol class="org-ol"><li><a id="sec-3-3-2-1" name="sec-3-3-2-1"></a>fst操作<br  /><div class="outline-text-5" id="text-3-3-2-1">
<ol class="org-ol">
<li>fsttablecompose: compose
</li>
<li>fstminmizeencode: min
</li>
<li>fstdeterminizestart: det
</li>
<li>fstcomposecontext: context expend
</li>
<li>fstisstochastic: ????
</li>
<li>make-h-transducer: 生成HMM的fst,Ha.fst
</li>
<li>主要实现：H*det(C*det(L * G))
</li>
<li>add-self-loops: 可能是hmm自身跳转
</li>
</ol>
</div>
</li></ol>
</li>
<li><a id="sec-3-3-3" name="sec-3-3-3"></a>steps/decode.sh<br  /><div class="outline-text-4" id="text-3-3-3">
<ol class="org-ol">
<li>feat_type: lda | delta
</li>
<li>mono input: exp/mono/graph(model) data/dev(source) 
</li>
<li>gmm-latgen-faster:解码
</li>
<li>local/score.sh
</li>
<li>JOB=1:$nj
</li>
<li>output:lat.n.gz
</li>
</ol>
</div>
</li></ol>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> tri1: Deltas + Delta-Deltas Training &amp; Decoding</h3>
<div class="outline-text-3" id="text-3-4">
</div><ol class="org-ol"><li><a id="sec-3-4-1" name="sec-3-4-1"></a>steps/align_si.sh<br  /><div class="outline-text-4" id="text-3-4-1">
<ol class="org-ol">
<li>output: mono_ali
</li>
<li>gmm-align-complied
</li>
<li>compile-train-graphs
</li>
</ol>
</div>
</li>
<li><a id="sec-3-4-2" name="sec-3-4-2"></a>steps/train_deltas.sh<br  /><div class="outline-text-4" id="text-3-4-2">
<ul class="org-ul">
<li>acc-tree-stats
</li>
</ul>
<p>
SplitToPhones()
end_points: 检测一个状态结束位置
AccumulateTreeStats
输出map&lt;EventType, ClusterableInterface&gt;，
假设为单音素&lt;{(-1,66), (0, 22)}, I&gt;的map结构
ClusterableInterface保存特征个数，并提供Add方法对特征进行累加，可以计算均值和方差。
</p>
<ul class="org-ul">
<li>sum-tree-stats: 统计三音素上下文特征
</li>
<li>cluster-phones：根据单音素聚类，生成所有可能的问题集, TreeCluster &amp; KMeans
</li>
<li>compile-questions:生成qst文件,为EventType设置问题集，key=-1问题集为[0 ] [0 1], key=0, 1, 2问题集为questions.txt
</li>
<li>build-tree: 建立决策树
</li>
<li>gmm-init-model
</li>
<li>gmm-mixup
</li>
</ul>
</div>
</li></ol>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> tri2 : LDA + MLLT Training &amp; Decoding</h3>
<div class="outline-text-3" id="text-3-5">
</div><ol class="org-ol"><li><a id="sec-3-5-1" name="sec-3-5-1"></a>steps/train_lda_mllt.sh<br  /><div class="outline-text-4" id="text-3-5-1">
<ol class="org-ol">
<li>特征 splice-feats, 前后7帧
</li>
<li>ali-to-post: make_pair&lt;alignment, 1.0&gt;, Convert alignments to viterbi style posteriors
</li>
</ol>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #9ac0cd;">void</span> <span style="color: #1e90ff; font-weight: bold;">AlignmentToPosterior</span>(<span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;int32&gt; &amp;<span style="color: #bebebe; font-weight: bold;">ali</span>,
                          <span style="color: #bebebe; font-weight: bold;">Posterior</span> *post) {
  post-&gt;clear();
  post-&gt;resize(ali.size());
  <span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">size_t</span> <span style="color: #bebebe; font-weight: bold;">i</span> = 0; i &lt; ali.size(); i++) {
    (*post)[i].resize(1);
    (*post)[i][0].first = ali[i];
    (*post)[i][0].second = 1.0;
  }
}
</pre>
</div>
<ol class="org-ol">
<li>weight-silence-post: 将post中silence的weight*silence_weight = 0.0
</li>
</ol>
<div class="org-src-container">

<pre class="src src-cpp">silence_scale=0.0
<span style="color: #9ac0cd;">void</span> WeightSilencePost(<span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">TransitionModel</span> &amp;<span style="color: #bebebe; font-weight: bold;">trans_model</span>,
                       <span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">ConstIntegerSet</span>&lt;int32&gt; &amp;<span style="color: #bebebe; font-weight: bold;">silence_set</span>,
                       <span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #bebebe; font-weight: bold;">silence_scale</span>,
                       Posterior *post) {
  <span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">size_t</span> <span style="color: #bebebe; font-weight: bold;">i</span> = 0; i &lt; post-&gt;size(); i++) {
    <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">pair</span>&lt;int32, <span style="color: #9ac0cd;">BaseFloat</span>&gt; &gt; <span style="color: #bebebe; font-weight: bold;">this_post</span>;
    this_post.reserve((*post)[i].size());
    <span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">size_t</span> <span style="color: #bebebe; font-weight: bold;">j</span> = 0; j &lt; (*post)[i].size(); j++) {
      <span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">tid</span> = (*post)[i][j].first,
          <span style="color: #bebebe; font-weight: bold;">phone</span> = trans_model.TransitionIdToPhone(tid);
      <span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #bebebe; font-weight: bold;">weight</span> = (*post)[i][j].second;
      <span style="color: #40e0d0; font-weight: bold;">if</span> (silence_set.count(phone) != 0) {  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">is a silence.</span>
        <span style="color: #40e0d0; font-weight: bold;">if</span> (silence_scale != 0.0)
          this_post.push_back(<span style="color: #ff6347; font-weight: bold;">std</span>::make_pair(tid, weight*silence_scale));
      } <span style="color: #40e0d0; font-weight: bold;">else</span> {
        this_post.push_back(<span style="color: #ff6347; font-weight: bold;">std</span>::make_pair(tid, weight));
      }
    }
    (*post)[i].swap(this_post);
  }
}
</pre>
</div>
<ol class="org-ol">
<li>acc-lda: 按照pdf id进行统计
</li>
</ol>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #9ac0cd;">Posterior</span> <span style="color: #bebebe; font-weight: bold;">pdf_post</span>;
ConvertPosteriorToPdfs(trans_model, post, &amp;pdf_post);
<span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">i</span> = 0; i &lt; feats.NumRows(); i++) {
  <span style="color: #9ac0cd;">SubVector</span>&lt;BaseFloat&gt; <span style="color: #bebebe; font-weight: bold;">feat</span>(<span style="color: #9ac0cd;">feats</span>, i);
  <span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">size_t</span> <span style="color: #bebebe; font-weight: bold;">j</span> = 0; j &lt; pdf_post[i].size(); j++) {
    <span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">pdf_id</span> = pdf_post[i][j].first;
    <span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #bebebe; font-weight: bold;">weight</span> = RandPrune(pdf_post[i][j].second, rand_prune);
    <span style="color: #40e0d0; font-weight: bold;">if</span> (weight != 0.0) {
      lda.Accumulate(feat, pdf_id, weight);
    }
  }
}
</pre>
</div>
<ol class="org-ol">
<li>est_lda
</li>
<li>dim=40
</li>
</ol>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #9ac0cd;">void</span> <span style="color: #ff6347; font-weight: bold;">LdaEstimate</span>::<span style="color: #1e90ff; font-weight: bold;">Estimate</span>(<span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">LdaEstimateOptions</span> &amp;<span style="color: #bebebe; font-weight: bold;">opts</span>,
                           <span style="color: #9ac0cd;">Matrix</span>&lt;BaseFloat&gt; *<span style="color: #bebebe; font-weight: bold;">m</span>,
                           <span style="color: #9ac0cd;">Matrix</span>&lt;BaseFloat&gt; *<span style="color: #bebebe; font-weight: bold;">mfull</span>) <span style="color: #40e0d0; font-weight: bold;">const</span> {
  <span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">target_dim</span> = opts.dim;
  KALDI_ASSERT(target_dim &gt; 0);
  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">between-class covar is of most rank C-1</span>
  KALDI_ASSERT(target_dim &lt;= Dim() &amp;&amp; (target_dim &lt; NumClasses() || opts.allow_large_dim));
  <span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">dim</span> = Dim();

  <span style="color: #9ac0cd;">double</span> <span style="color: #bebebe; font-weight: bold;">count</span>;
  <span style="color: #9ac0cd;">SpMatrix</span>&lt;<span style="color: #9ac0cd;">double</span>&gt; <span style="color: #bebebe; font-weight: bold;">total_covar</span>, <span style="color: #bebebe; font-weight: bold;">bc_covar</span>;
  <span style="color: #9ac0cd;">Vector</span>&lt;<span style="color: #9ac0cd;">double</span>&gt; <span style="color: #bebebe; font-weight: bold;">total_mean</span>;
  GetStats(&amp;total_covar, &amp;bc_covar, &amp;total_mean, &amp;count);

  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">within-class covariance</span>
  <span style="color: #9ac0cd;">SpMatrix</span>&lt;<span style="color: #9ac0cd;">double</span>&gt; <span style="color: #bebebe; font-weight: bold;">wc_covar</span>(total_covar);
  wc_covar.AddSp(-1.0, bc_covar);
  <span style="color: #9ac0cd;">TpMatrix</span>&lt;<span style="color: #9ac0cd;">double</span>&gt; <span style="color: #bebebe; font-weight: bold;">wc_covar_sqrt</span>(dim);
  <span style="color: #40e0d0; font-weight: bold;">try</span> {
    wc_covar_sqrt.Cholesky(wc_covar);
  } <span style="color: #40e0d0; font-weight: bold;">catch</span> (...) {
    <span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #bebebe; font-weight: bold;">smooth</span> = 1.0e-03 * wc_covar.Trace() / wc_covar.NumRows();
    KALDI_LOG &lt;&lt; <span style="color: #ff0000;">"Cholesky failed (possibly not +ve definite), so adding "</span> &lt;&lt; smooth
              &lt;&lt; <span style="color: #ff0000;">" to diagonal and trying again.\n"</span>;
    <span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">i</span> = 0; i &lt; wc_covar.NumRows(); i++)
      <span style="color: #bebebe; font-weight: bold;">wc_covar</span>(i, i) += smooth;
    wc_covar_sqrt.Cholesky(wc_covar);    
  }
  <span style="color: #9ac0cd;">Matrix</span>&lt;<span style="color: #9ac0cd;">double</span>&gt; <span style="color: #bebebe; font-weight: bold;">wc_covar_sqrt_mat</span>(wc_covar_sqrt);
  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">copy wc_covar_sqrt to Matrix, because it facilitates further use</span>
  wc_covar_sqrt_mat.Invert();

  <span style="color: #9ac0cd;">SpMatrix</span>&lt;<span style="color: #9ac0cd;">double</span>&gt; <span style="color: #bebebe; font-weight: bold;">tmp_sp</span>(dim);
  tmp_sp.AddMat2Sp(1.0, wc_covar_sqrt_mat, kNoTrans, bc_covar, 0.0);
  <span style="color: #9ac0cd;">Matrix</span>&lt;<span style="color: #9ac0cd;">double</span>&gt; <span style="color: #bebebe; font-weight: bold;">tmp_mat</span>(tmp_sp);

  <span style="color: #9ac0cd;">Matrix</span>&lt;<span style="color: #9ac0cd;">double</span>&gt; <span style="color: #bebebe; font-weight: bold;">svd_u</span>(dim, dim), <span style="color: #bebebe; font-weight: bold;">svd_vt</span>(dim, dim);
  <span style="color: #9ac0cd;">Vector</span>&lt;<span style="color: #9ac0cd;">double</span>&gt; <span style="color: #bebebe; font-weight: bold;">svd_d</span>(dim);
  tmp_mat.Svd(&amp;svd_d, &amp;svd_u, &amp;svd_vt);
  SortSvd(&amp;svd_d, &amp;svd_u);

  KALDI_LOG &lt;&lt; <span style="color: #ff0000;">"Data count is "</span> &lt;&lt; count;
  KALDI_LOG &lt;&lt; <span style="color: #ff0000;">"LDA singular values are "</span> &lt;&lt; svd_d;

  KALDI_LOG &lt;&lt; <span style="color: #ff0000;">"Sum of all singular values is "</span> &lt;&lt; svd_d.Sum();
  KALDI_LOG &lt;&lt; <span style="color: #ff0000;">"Sum of selected singular values is "</span> &lt;&lt;
      <span style="color: #9ac0cd;">SubVector</span>&lt;<span style="color: #9ac0cd;">double</span>&gt;(svd_d, 0, target_dim).Sum();

  <span style="color: #9ac0cd;">Matrix</span>&lt;<span style="color: #9ac0cd;">double</span>&gt; <span style="color: #bebebe; font-weight: bold;">lda_mat</span>(dim, dim);
  lda_mat.AddMatMat(1.0, svd_u, kTrans, wc_covar_sqrt_mat, kNoTrans, 0.0);

  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">finally, copy first target_dim rows to m</span>
  m-&gt;Resize(target_dim, dim);
  m-&gt;CopyFromMat(lda_mat.Range(0, target_dim, 0, dim));

  <span style="color: #40e0d0; font-weight: bold;">if</span> (mfull != <span style="color: #ff6347; font-weight: bold;">NULL</span>) {
    mfull-&gt;Resize(dim, dim);
    mfull-&gt;CopyFromMat(lda_mat);
  }

  <span style="color: #40e0d0; font-weight: bold;">if</span> (opts.within_class_factor != 1.0) { <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">This is not the normal code path;</span>
    <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">it's intended for use in neural net inputs.</span>
    <span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">i</span> = 0; i &lt; svd_d.Dim(); i++) {
      <span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #bebebe; font-weight: bold;">old_var</span> = 1.0 + svd_d(i), <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">the total variance of that dim..</span>
          <span style="color: #bebebe; font-weight: bold;">new_var</span> = opts.within_class_factor + svd_d(i), <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">the variance we want..</span>
          <span style="color: #bebebe; font-weight: bold;">scale</span> = sqrt(new_var / old_var);
      <span style="color: #40e0d0; font-weight: bold;">if</span> (i &lt; m-&gt;NumRows())
        m-&gt;Row(i).Scale(scale);
      <span style="color: #40e0d0; font-weight: bold;">if</span> (mfull != <span style="color: #ff6347; font-weight: bold;">NULL</span>)
        mfull-&gt;Row(i).Scale(scale);
    }
  }

  <span style="color: #40e0d0; font-weight: bold;">if</span> (opts.remove_offset) {
    AddMeanOffset(total_mean, m);
    <span style="color: #40e0d0; font-weight: bold;">if</span> (mfull != <span style="color: #ff6347; font-weight: bold;">NULL</span>)
      AddMeanOffset(total_mean, mfull);
  }  
}
</pre>
</div>
</div>
</li></ol>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> DNN Hybrid Training &amp; Decoding</h3>
<div class="outline-text-3" id="text-3-6">
</div><ol class="org-ol"><li><a id="sec-3-6-1" name="sec-3-6-1"></a>网络结构(输入、输出、隐层）<br  /><div class="outline-text-4" id="text-3-6-1">
<ul class="org-ul">
<li>num_epochs=15, numjobs_nnet = 16, hidden_layer_dim=300, minibatch_size=128, shuffle_buffer_size
</li>
<li>num_hidden_layers=3
</li>
<li>输入特征 lda, feat, get_lda, (egs空暂不考虑)
</li>
<li>输出的是什么 num_leaves，状态
</li>
<li>nnet.config
</li>
<li>hidden.config
</li>
</ul>
</div>
</li>
<li><a id="sec-3-6-2" name="sec-3-6-2"></a>get_lda.sh<br  /><div class="outline-text-4" id="text-3-6-2">
<ul class="org-ul">
<li>输出lda.mat
</li>
</ul>
</div>
</li>
<li><a id="sec-3-6-3" name="sec-3-6-3"></a>get_egs.sh<br  /><div class="outline-text-4" id="text-3-6-3">
<ol class="org-ol">
<li>transform_dir=$alidir
</li>
<li>shuffle_list, 随机从训练语句中抽取300
</li>
</ol>
<div class="org-src-container">

<pre class="src src-bash">awk '{print $1}' $data/utt2spk | utils/shuffle_list.pl | head -$num_utts_subset \
	&gt; $dir/valid_uttlist || exit 1;
</pre>
</div>
<ol class="org-ol">
<li>valid_uttlist, train_subset_uttlist 两个互补
</li>
<li>samples_per_iter
</li>
<li>num_frame:  1124823, samples_per_iter: 200000
</li>
<li>nnet-get-egs: 准备网络输入格式的数据，上下文特征,pdf标签
</li>
</ol>
</div>
</li>
<li><a id="sec-3-6-4" name="sec-3-6-4"></a>训练<br  /><ol class="org-ol"><li><a id="sec-3-6-4-1" name="sec-3-6-4-1"></a>问题<br  /><ol class="org-ol"><li><a id="sec-3-6-4-1-1" name="sec-3-6-4-1-1"></a><span class="todo TODO">TODO</span> shuffle是什么？<br  /></li>
<li><a id="sec-3-6-4-1-2" name="sec-3-6-4-1-2"></a><span class="todo TODO">TODO</span> 如何利用hmm初始化,feature is not equal dimension<br  /></li>
<li><a id="sec-3-6-4-1-3" name="sec-3-6-4-1-3"></a><span class="todo TODO">TODO</span> 如何使用nnet的priors_<br  /><div class="outline-text-6" id="text-3-6-4-1-3">
<p>
给网络加上先验，训练时并没有用，用于识别时。
</p>
</div>
</li>
<li><a id="sec-3-6-4-1-4" name="sec-3-6-4-1-4"></a><span class="todo TODO">TODO</span> dropout, bottleneck如何使用<br  /><div class="outline-text-6" id="text-3-6-4-1-4">
<p>
Dropout Component
</p>
</div>
</li></ol>
</li>
<li><a id="sec-3-6-4-2" name="sec-3-6-4-2"></a>数据结构<br  /><div class="outline-text-5" id="text-3-6-4-2">
<ul class="org-ul">
<li>Example
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #40e0d0; font-weight: bold;">struct</span> <span style="color: #9ac0cd;">NnetExample</span> {
<span style="color: #ee82ee;">/// </span><span style="color: #ee82ee;">The label(s) for this frame; in the normal case, this will be a vector of</span>
<span style="color: #ee82ee;">/// </span><span style="color: #ee82ee;">length one, containing (the pdf-id, 1.0)</span>
<span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">pair</span>&lt;int32, BaseFloat&gt; &gt; <span style="color: #bebebe; font-weight: bold;">labels</span>;
<span style="color: #ee82ee;">/// </span><span style="color: #ee82ee;">The input data-- typically with NumRows() more than</span>
<span style="color: #ee82ee;">/// </span><span style="color: #ee82ee;">labels.size(), it includes features to the left and</span>
<span style="color: #ee82ee;">/// </span><span style="color: #ee82ee;">right as needed for the temporal context of the network.</span>
<span style="color: #ee82ee;">/// </span><span style="color: #ee82ee;">(see the left_context variable).</span>
<span style="color: #9ac0cd;">CompressedMatrix</span> <span style="color: #bebebe; font-weight: bold;">input_frames</span>;
<span style="color: #ee82ee;">/// </span><span style="color: #ee82ee;">The number of frames of left context (we can work out the #frames</span>
<span style="color: #ee82ee;">/// </span><span style="color: #ee82ee;">of right context from input_frames.NumRows(), labels.size(), and this).</span>
<span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">left_context</span>;
<span style="color: #ee82ee;">/// </span><span style="color: #ee82ee;">The speaker-specific input, if any, or an empty vector if</span>
<span style="color: #ee82ee;">/// </span><span style="color: #ee82ee;">we're not using this features. We'll append this to each of the</span>
<span style="color: #9ac0cd;">Vector</span>&lt;BaseFloat&gt; <span style="color: #bebebe; font-weight: bold;">spk_info</span>; 
<span style="color: #ee82ee;">/// </span><span style="color: #ee82ee;">Set the label of this example to the specified pdf_id </span>
<span style="color: #ee82ee;">/// </span><span style="color: #ee82ee;">with the specified weight.</span>
<span style="color: #9ac0cd;">void</span> <span style="color: #1e90ff; font-weight: bold;">SetLabelSingle</span>(<span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">pdf_id</span>, <span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #bebebe; font-weight: bold;">weight</span> = 1.0);
<span style="color: #ee82ee;">/// </span><span style="color: #ee82ee;">Get the maximum weight label (pdf_id and weight) of this example. </span>
<span style="color: #9ac0cd;">int32</span> <span style="color: #1e90ff; font-weight: bold;">GetLabelSingle</span>(<span style="color: #9ac0cd;">BaseFloat</span> *<span style="color: #bebebe; font-weight: bold;">weight</span> = <span style="color: #ff6347; font-weight: bold;">NULL</span>);
};
</pre>
</div>
<ul class="org-ul">
<li>Component
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">nnet/nnet-activation.h</span>
<span style="color: #40e0d0; font-weight: bold;">class</span> <span style="color: #9ac0cd;">Softmax</span> : <span style="color: #40e0d0; font-weight: bold;">public</span> <span style="color: #9ac0cd;">Component</span>
<span style="color: #40e0d0; font-weight: bold;">class</span> <span style="color: #9ac0cd;">BlockSoftmax</span> : <span style="color: #40e0d0; font-weight: bold;">public</span> <span style="color: #9ac0cd;">Component</span>
<span style="color: #40e0d0; font-weight: bold;">class</span> <span style="color: #9ac0cd;">Sigmoid</span> : <span style="color: #40e0d0; font-weight: bold;">public</span> <span style="color: #9ac0cd;">Component</span>
<span style="color: #40e0d0; font-weight: bold;">class</span> <span style="color: #9ac0cd;">Tanh</span> : <span style="color: #40e0d0; font-weight: bold;">public</span> <span style="color: #9ac0cd;">Component</span> 
<span style="color: #40e0d0; font-weight: bold;">class</span> <span style="color: #9ac0cd;">Dropout</span> : <span style="color: #40e0d0; font-weight: bold;">public</span> <span style="color: #9ac0cd;">Component</span>
</pre>
</div>
<ul class="org-ul">
<li>NnetSimpleTrainer
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#37324;&#38754;&#27809;&#26377;prior_&#30340;&#20449;&#24687;, &#37027;&#20040;prior&#22312;&#37027;&#37324;&#29992;&#65311;</span>
<span style="color: #9ac0cd;">void</span> <span style="color: #ff6347; font-weight: bold;">NnetSimpleTrainer</span>::<span style="color: #1e90ff; font-weight: bold;">TrainOnExample</span>(<span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">NnetExample</span> &amp;<span style="color: #bebebe; font-weight: bold;">value</span>) {
buffer_.push_back(value);
<span style="color: #40e0d0; font-weight: bold;">if</span> (<span style="color: #40e0d0; font-weight: bold;">static_cast</span>&lt;int32&gt;(buffer_.size()) == config_.minibatch_size)
TrainOneMinibatch();
}
<span style="color: #9ac0cd;">void</span> <span style="color: #ff6347; font-weight: bold;">NnetSimpleTrainer</span>::<span style="color: #1e90ff; font-weight: bold;">TrainOneMinibatch</span>() {

KALDI_ASSERT(!buffer_.empty());
<span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">The following function is declared in nnet-update.h.</span>
logprob_this_phase_ += DoBackprop(*nnet_,
buffer_,
nnet_);
weight_this_phase_ += TotalNnetTrainingWeight(buffer_);
buffer_.clear();
minibatches_seen_this_phase_++;
<span style="color: #40e0d0; font-weight: bold;">if</span> (minibatches_seen_this_phase_ == config_.minibatches_per_phase) {
<span style="color: #9ac0cd;">bool</span> <span style="color: #bebebe; font-weight: bold;">first_time</span> = <span style="color: #ff6347; font-weight: bold;">false</span>;
BeginNewPhase(first_time);
}
}
</pre>
</div>
<ul class="org-ul">
<li>AmNnet
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">Amnet</span>
<span style="color: #40e0d0; font-weight: bold;">class</span> <span style="color: #9ac0cd;">AmNnet</span> {
  <span style="color: #9ac0cd;">Nnet</span> <span style="color: #bebebe; font-weight: bold;">nnet_</span>;
  <span style="color: #9ac0cd;">Vector</span>&lt;BaseFloat&gt; <span style="color: #bebebe; font-weight: bold;">priors_</span>; 
};
</pre>
</div>
</div>
</li>
<li><a id="sec-3-6-4-3" name="sec-3-6-4-3"></a>训练工具<br  /><div class="outline-text-5" id="text-3-6-4-3">
<ul class="org-ul">
<li>nnet-init: Initialize the neural network from a config file with a line for each component
</li>
<li>nnet-am-init: 好像只把nnet,tree, topo写到一个文件了
</li>
<li>nnet-get-egs: 生成examples(准备网络输入格式的数据，上下文特征,pdf标签)
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp">ProcessFile(feats, pdf_post, key, left_context, right_context, const_feat_dim,
keep_proportion, &amp;num_frames_written, &amp;example_writer)
<span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">i</span> = 0; i &lt; feats.NumRows(); i++) {
<span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">count</span> = GetCount(keep_proportion); <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">number of times</span>
<span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">we'll write this out (1 by default).</span>
<span style="color: #40e0d0; font-weight: bold;">if</span> (count &gt; 0) {
<span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">Set up "input_frames".</span>
<span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">j</span> = -left_context; j &lt;= right_context; j++) {
<span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">j2</span> = j + i;
<span style="color: #40e0d0; font-weight: bold;">if</span> (j2 &lt; 0) j2 = 0;
<span style="color: #40e0d0; font-weight: bold;">if</span> (j2 &gt;= feats.NumRows()) j2 = feats.NumRows() - 1;
<span style="color: #9ac0cd;">SubVector</span>&lt;BaseFloat&gt; <span style="color: #bebebe; font-weight: bold;">src</span>(feats.Row(j2), 0, basic_feat_dim),
<span style="color: #bebebe; font-weight: bold;">dest</span>(input_frames, j + left_context);
dest.CopyFromVec(src);
}
eg.labels = pdf_post[i];
eg.input_frames = input_frames;
<span style="color: #40e0d0; font-weight: bold;">if</span> (const_feat_dim &gt; 0) {
<span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">we'll normally reach here if we're using online-estimated iVectors.</span>
<span style="color: #9ac0cd;">SubVector</span>&lt;BaseFloat&gt; <span style="color: #bebebe; font-weight: bold;">const_part</span>(feats.Row(i),
basic_feat_dim, const_feat_dim);
eg.spk_info.CopyFromVec(const_part);
}
<span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">ostringstream</span> <span style="color: #bebebe; font-weight: bold;">os</span>;
os &lt;&lt; utt_id &lt;&lt; <span style="color: #ff0000;">"-"</span> &lt;&lt; i;


<span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">string</span> <span style="color: #bebebe; font-weight: bold;">key</span> = os.str(); <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">key is &lt;utt_id&gt;-&lt;frame_id&gt;</span>


<span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">c</span> = 0; c &lt; count; c++)
example_writer-&gt;Write(key, eg);
}
}
</pre>
</div>
<ul class="org-ul">
<li>nnet-shuffle-egs: from the input to output, but randomly shuffle the order
</li>
<li>nnet-subset-egs: Creates a random subset of the input examples, of a specified size
</li>
<li>nnet-train-transitions
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #9ac0cd;">void</span> <span style="color: #1e90ff; font-weight: bold;">SetPriors</span>(<span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">TransitionModel</span> &amp;<span style="color: #bebebe; font-weight: bold;">tmodel</span>,
               <span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">Vector</span>&lt;<span style="color: #9ac0cd;">double</span>&gt; &amp;<span style="color: #bebebe; font-weight: bold;">transition_accs</span>,
               <span style="color: #9ac0cd;">double</span> <span style="color: #bebebe; font-weight: bold;">prior_floor</span>,
               <span style="color: #9ac0cd;">AmNnet</span> *<span style="color: #bebebe; font-weight: bold;">am_nnet</span>) {
  KALDI_ASSERT(tmodel.NumPdfs() == am_nnet-&gt;NumPdfs());
  <span style="color: #9ac0cd;">Vector</span>&lt;BaseFloat&gt; <span style="color: #bebebe; font-weight: bold;">pdf_counts</span>(tmodel.NumPdfs());
  KALDI_ASSERT(transition_accs(0) == 0.0); <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">There is</span>
  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">no zero transition-id.</span>
  <span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">tid</span> = 1; tid &lt; transition_accs.Dim(); tid++) {
    <span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">pdf</span> = tmodel.TransitionIdToPdf(tid);
    pdf_counts(pdf) += transition_accs(tid);
  }
  <span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #bebebe; font-weight: bold;">sum</span> = pdf_counts.Sum();
  KALDI_ASSERT(sum != 0.0);
  KALDI_ASSERT(prior_floor &gt; 0.0 &amp;&amp; prior_floor &lt; 1.0);
  <span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#24402;&#19968;&#21270;</span>
  pdf_counts.Scale(1.0 / sum);
  pdf_counts.ApplyFloor(prior_floor);
  pdf_counts.Scale(1.0 / pdf_counts.Sum()); <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">normalize again.</span>
  am_nnet-&gt;SetPriors(pdf_counts);
}
</pre>
</div>
<ul class="org-ul">
<li>nnet-train-simple
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#40664;&#35748;minibatch(1024)&#65292;&#36798;&#21040;minibatch-size&#26102;&#22788;&#29702;</span>
<span style="color: #9ac0cd;">NnetSimpleTrainer</span> <span style="color: #1e90ff; font-weight: bold;">trainer</span>(train_config,&amp;(am_nnet.GetNnet())); 
<span style="color: #9ac0cd;">SequentialNnetExampleReader</span> <span style="color: #1e90ff; font-weight: bold;">example_reader</span>(examples_rspecifier); 
<span style="color: #40e0d0; font-weight: bold;">for</span> (; !example_reader.Done(); example_reader.Next(), num_examples++) 
    trainer.TrainOnExample(example_reader.Value()); <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">It all happens here!</span>
</pre>
</div>
<ul class="org-ul">
<li>nnet-train-parallel
</li>
</ul>
</div>
</li>
<li><a id="sec-3-6-4-4" name="sec-3-6-4-4"></a>解码<br  /><ol class="org-ol"><li><a id="sec-3-6-4-4-1" name="sec-3-6-4-4-1"></a>nnet2/decode.sh<br  /><div class="outline-text-6" id="text-3-6-4-4-1">
<ul class="org-ul">
<li>nnet-latgen-faste
</li>
</ul>
</div>
</li></ol>
</li></ol>
</li></ol>
</div>
<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7"><span class="section-number-3">3.7</span> Getting Results</h3>
<div class="outline-text-3" id="text-3-7">
<p>
运行RESULTS文件， RESULTS中含有统计识别率脚本和标准测试结果
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> kaldi doc</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> kaldi tutorial</h3>
<div class="outline-text-3" id="text-4-1">
</div><ol class="org-ol"><li><a id="sec-4-1-1" name="sec-4-1-1"></a>Reading and modifying the code<br  /><div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>kaldi中使用-O0,调试可以使用gdb调试
</li>
<li>可以在Makefile TESTFILES中添加自己的test，然后make test
</li>
</ul>
</div>
</li></ol>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Kaldi I/O mechanisms</h3>
<div class="outline-text-3" id="text-4-2">
<ol class="org-ol">
<li>io
</li>
</ol>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #40e0d0; font-weight: bold;">class</span> <span style="color: #9ac0cd;">SomeKaldiClass</span> {
 <span style="color: #40e0d0; font-weight: bold;">public</span>:
   <span style="color: #9ac0cd;">void</span> <span style="color: #1e90ff; font-weight: bold;">Read</span>(<span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">istream</span> &amp;<span style="color: #bebebe; font-weight: bold;">is</span>, <span style="color: #9ac0cd;">bool</span> <span style="color: #bebebe; font-weight: bold;">binary</span>);
   <span style="color: #9ac0cd;">void</span> <span style="color: #1e90ff; font-weight: bold;">Write</span>(<span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">ostream</span> &amp;<span style="color: #bebebe; font-weight: bold;">os</span>, <span style="color: #9ac0cd;">bool</span> <span style="color: #bebebe; font-weight: bold;">binary</span>) <span style="color: #40e0d0; font-weight: bold;">const</span>;
};
<span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">read &amp; write</span>
{ <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">input.</span>
  <span style="color: #9ac0cd;">bool</span> <span style="color: #bebebe; font-weight: bold;">binary_in</span>;
  <span style="color: #9ac0cd;">Input</span> <span style="color: #bebebe; font-weight: bold;">ki</span>(some_rxfilename, &amp;binary_in);
  my_object.Read(ki.Stream(), binary_in);
  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">you can have more than one object in a file:</span>
  my_other_object.Read(ki.Stream(), binary_in);
}
<span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">output.  note, "binary" is probably a command-line option.</span>
{
  <span style="color: #9ac0cd;">Output</span> <span style="color: #bebebe; font-weight: bold;">ko</span>(some_wxfilename, binary);
  my_object.Write(ko.Stream(), binary); 
}
</pre>
</div>
<ol class="org-ol">
<li>binary vs text: binary start '\0B'
</li>
<li></li>
</ol>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> The Kaldi Matrix library</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>包装库 BLAS &amp; LAPACK
</li>
<li>Vector 向量
</li>
<li>Matrix 矩阵
</li>
<li>一些操作
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #9ac0cd;">Vector</span>&lt;<span style="color: #9ac0cd;">float</span>&gt; <span style="color: #1e90ff; font-weight: bold;">v</span>(10), <span style="color: #1e90ff; font-weight: bold;">w</span>(9);
<span style="color: #40e0d0; font-weight: bold;">for</span>(<span style="color: #9ac0cd;">int</span> <span style="color: #bebebe; font-weight: bold;">i</span>=0; i &lt; 9; i++) {
   v(i) = i; 
   w(i) = i+1;
}
<span style="color: #9ac0cd;">Matrix</span>&lt;<span style="color: #9ac0cd;">float</span>&gt; <span style="color: #1e90ff; font-weight: bold;">M</span>(10,9);
M.AddVecVec(1.0, v, w);
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> The build process(how Kaldi is compiled)</h3>
<div class="outline-text-3" id="text-4-4">
</div><ol class="org-ol"><li><a id="sec-4-4-1" name="sec-4-4-1"></a>kaldi.mk<br  /><div class="outline-text-4" id="text-4-4-1">
<ul class="org-ul">
<li>默认编译选项：-g -O0 -DKALDI_PARANOID
</li>
</ul>
</div>
</li>
<li><a id="sec-4-4-2" name="sec-4-4-2"></a>Makefile<br  /><div class="outline-text-4" id="text-4-4-2">
<ul class="org-ul">
<li>make test
</li>
<li></li>
</ul>
</div>
</li></ol>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> Parsing command-line Options</h3>
<div class="outline-text-3" id="text-4-5">
</div><ol class="org-ol"><li><a id="sec-4-5-1" name="sec-4-5-1"></a>parse-option(util, ParseOption类)<br  /><div class="outline-text-4" id="text-4-5-1">
<ul class="org-ul">
<li>Read()
</li>
</ul>
</div>
</li></ol>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> Kaldi logging and error-reporting</h3>
<div class="outline-text-3" id="text-4-6">
</div><ol class="org-ol"><li><a id="sec-4-6-1" name="sec-4-6-1"></a>kaldi log(base/kaldi-error.h)<br  /><div class="outline-text-4" id="text-4-6-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #40e0d0; font-weight: bold;">class</span> <span style="color: #9ac0cd;">KaldiLogMessage</span> {
 <span style="color: #40e0d0; font-weight: bold;">public</span>:
  <span style="color: #40e0d0; font-weight: bold;">inline</span> <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">ostream</span> &amp;<span style="color: #1e90ff; font-weight: bold;">stream</span>() { <span style="color: #40e0d0; font-weight: bold;">return</span> ss; }
  <span style="color: #1e90ff; font-weight: bold;">KaldiLogMessage</span>(<span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">char</span> *<span style="color: #bebebe; font-weight: bold;">func</span>, <span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">char</span> *<span style="color: #bebebe; font-weight: bold;">file</span>, <span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">line</span>);
  ~<span style="color: #1e90ff; font-weight: bold;">KaldiLogMessage</span>() { fprintf(stderr, <span style="color: #ff0000;">"%s\n"</span>, ss.str().c_str()); }
 <span style="color: #40e0d0; font-weight: bold;">private</span>:
  <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">ostringstream</span> <span style="color: #bebebe; font-weight: bold;">ss</span>;
};

<span style="color: #ff6347; font-weight: bold;">#define</span> <span style="color: #bebebe; font-weight: bold;">KALDI_LOG</span> <span style="color: #ff6347; font-weight: bold;">kaldi</span>::<span style="color: #1e90ff; font-weight: bold;">KaldiLogMessage</span>(__func__, __FILE__, __LINE__).stream()

<span style="color: #ff6347; font-weight: bold;">KaldiLogMessage</span>::<span style="color: #1e90ff; font-weight: bold;">KaldiLogMessage</span>(<span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">char</span> *<span style="color: #bebebe; font-weight: bold;">func</span>, <span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">char</span> *<span style="color: #bebebe; font-weight: bold;">file</span>,
                                 <span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">line</span>) {
  <span style="color: #40e0d0; font-weight: bold;">this</span>-&gt;stream() &lt;&lt; <span style="color: #ff0000;">"LOG ("</span> &lt;&lt; GetProgramName() &lt;&lt; func &lt;&lt; <span style="color: #ff0000;">"():"</span>
                 &lt;&lt; GetShortFileName(file) &lt;&lt; <span style="color: #ff0000;">':'</span> &lt;&lt; line &lt;&lt; <span style="color: #ff0000;">") "</span>;
}
</pre>
</div>
</div>
</li></ol>
</div>
<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7"><span class="section-number-3">4.7</span> Decoders used in the Kaldi toolkit</h3>
<div class="outline-text-3" id="text-4-7">
</div><ol class="org-ol"><li><a id="sec-4-7-1" name="sec-4-7-1"></a>DecodableInterface<br  /><div class="outline-text-4" id="text-4-7-1">
<p>
virtual BaseFloat LogLikelihood(int32 frame, int32 index);
virtual bool IsLastFrame(int32 frame);
virtual int32 NumIndices();
</p>
</div>
</li>

<li><a id="sec-4-7-2" name="sec-4-7-2"></a>SimpleDecoder<br  /><div class="outline-text-4" id="text-4-7-2">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #40e0d0; font-weight: bold;">class</span> <span style="color: #9ac0cd;">Token</span> {
   <span style="color: #40e0d0; font-weight: bold;">public</span>:
    <span style="color: #9ac0cd;">Arc</span> <span style="color: #bebebe; font-weight: bold;">arc_</span>;
    <span style="color: #9ac0cd;">Token</span> *<span style="color: #bebebe; font-weight: bold;">prev_</span>;
    <span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">ref_count_</span>;
    <span style="color: #9ac0cd;">Weight</span> <span style="color: #bebebe; font-weight: bold;">weight_</span>;
    ...
};

<span style="color: #9ac0cd;">bool</span> <span style="color: #ff6347; font-weight: bold;">LatticeFasterDecoder</span>::<span style="color: #1e90ff; font-weight: bold;">Decode</span>(<span style="color: #9ac0cd;">DecodableInterface</span> *<span style="color: #bebebe; font-weight: bold;">decodable</span>) {
    <span style="color: #40e0d0; font-weight: bold;">for</span>(<span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">frame</span> = 0; !decodable.IsLastFrame(frame-1); frame++) {
        ClearToks(prev_toks_);
        <span style="color: #ff6347; font-weight: bold;">std</span>::swap(cur_toks_, prev_toks_);
        ProcessEmitting(decodable, frame);
        ProcessNonemitting();
        PruneToks(cur_toks_, beam_);
     }
}

<span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">Outputs an FST corresponding to the raw, state-level</span>
<span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">tracebacks.</span>
<span style="color: #9ac0cd;">bool</span> <span style="color: #ff6347; font-weight: bold;">LatticeFasterDecoder</span>::<span style="color: #1e90ff; font-weight: bold;">GetRawLattice</span>(<span style="color: #ff6347; font-weight: bold;">fst</span>::<span style="color: #9ac0cd;">MutableFst</span>&lt;LatticeArc&gt; *<span style="color: #bebebe; font-weight: bold;">ofst</span>) <span style="color: #40e0d0; font-weight: bold;">const</span> {
  <span style="color: #40e0d0; font-weight: bold;">typedef</span> <span style="color: #9ac0cd;">LatticeArc</span> <span style="color: #9ac0cd;">Arc</span>;
  <span style="color: #40e0d0; font-weight: bold;">typedef</span> <span style="color: #ff6347; font-weight: bold;">Arc</span>::<span style="color: #9ac0cd;">StateId</span> <span style="color: #9ac0cd;">StateId</span>;
  <span style="color: #40e0d0; font-weight: bold;">typedef</span> <span style="color: #ff6347; font-weight: bold;">Arc</span>::<span style="color: #9ac0cd;">Weight</span> <span style="color: #9ac0cd;">Weight</span>;
  <span style="color: #40e0d0; font-weight: bold;">typedef</span> <span style="color: #ff6347; font-weight: bold;">Arc</span>::<span style="color: #9ac0cd;">Label</span> <span style="color: #9ac0cd;">Label</span>;
  ofst-&gt;DeleteStates();
  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">num-frames plus one (since frames are one-based, and we have</span>
  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">an extra frame for the start-state).</span>
  <span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">num_frames</span> = active_toks_.size() - 1;
  KALDI_ASSERT(num_frames &gt; 0);
  <span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#29983;&#25104;token&#21040;id&#30340;&#26144;&#23556;&#65292; &#27599;&#19968;&#24103;&#19978;&#37117;&#26377;active token list&#65292;&#39034;&#24207;&#35775;&#38382;&#32534;&#21495;</span>
  <span style="color: #9ac0cd;">unordered_map</span>&lt;<span style="color: #9ac0cd;">Token</span>*, <span style="color: #9ac0cd;">StateId</span>&gt; <span style="color: #bebebe; font-weight: bold;">tok_map</span>(num_toks_/2 + 3); <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">bucket count</span>
  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">First create all states.</span>
  <span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">f</span> = 0; f &lt;= num_frames; f++) {
    <span style="color: #40e0d0; font-weight: bold;">if</span> (active_toks_[f].toks == <span style="color: #ff6347; font-weight: bold;">NULL</span>) {
      KALDI_WARN &lt;&lt; <span style="color: #ff0000;">"GetRawLattice: no tokens active on frame "</span> &lt;&lt; f
                 &lt;&lt; <span style="color: #ff0000;">": not producing lattice.\n"</span>;
      <span style="color: #40e0d0; font-weight: bold;">return</span> <span style="color: #ff6347; font-weight: bold;">false</span>;
    }
    <span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">Token</span> *<span style="color: #bebebe; font-weight: bold;">tok</span> = active_toks_[f].toks; tok != <span style="color: #ff6347; font-weight: bold;">NULL</span>; tok = tok-&gt;next)
      tok_map[tok] = ofst-&gt;AddState();
  }
  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">Now create all arcs&#65292;&#25353;&#29031;token&#20043;&#38388;&#36339;&#36716;&#20851;&#31995;&#21152;&#19978;&#24359;Arc&#65292;&#26377;&#27809;&#26377;&#36229;&#32423;&#31616;&#21333;&#21834;&#65292;fst&#23601;&#26159;&#22909;</span>
  <span style="color: #9ac0cd;">StateId</span> <span style="color: #bebebe; font-weight: bold;">cur_state</span> = 0; <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">we rely on the fact that we numbered these</span>
  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">consecutively (AddState() returns the numbers in order..)</span>
  <span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">f</span> = 0; f &lt;= num_frames; f++) {
    <span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">Token</span> *<span style="color: #bebebe; font-weight: bold;">tok</span> = active_toks_[f].toks; tok != <span style="color: #ff6347; font-weight: bold;">NULL</span>; tok = tok-&gt;next,
             cur_state++) {
      <span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">ForwardLink</span> *<span style="color: #bebebe; font-weight: bold;">l</span> = tok-&gt;links;
           l != <span style="color: #ff6347; font-weight: bold;">NULL</span>;
           l = l-&gt;next) {
        <span style="color: #ff6347; font-weight: bold;">unordered_map</span>&lt;<span style="color: #9ac0cd;">Token</span>*, <span style="color: #9ac0cd;">StateId</span>&gt;::<span style="color: #9ac0cd;">const_iterator</span> <span style="color: #bebebe; font-weight: bold;">iter</span> =
            tok_map.find(l-&gt;next_tok);
        <span style="color: #9ac0cd;">StateId</span> <span style="color: #bebebe; font-weight: bold;">nextstate</span> = iter-&gt;second;
        KALDI_ASSERT(iter != tok_map.end());
        <span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #bebebe; font-weight: bold;">cost_offset</span> = 0.0;
        <span style="color: #40e0d0; font-weight: bold;">if</span> (l-&gt;ilabel != 0) { <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">emitting..</span>
          KALDI_ASSERT(f &gt;= 0 &amp;&amp; f &lt; cost_offsets_.size());
          cost_offset = cost_offsets_[f];
        }
        <span style="color: #9ac0cd;">Arc</span> <span style="color: #bebebe; font-weight: bold;">arc</span>(l-&gt;ilabel, l-&gt;olabel,
                Weight(l-&gt;graph_cost, l-&gt;acoustic_cost - cost_offset),
                nextstate);
        ofst-&gt;AddArc(cur_state, arc);
      }
      <span style="color: #40e0d0; font-weight: bold;">if</span> (f == num_frames) {
        <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #ff6347; font-weight: bold;">map</span>&lt;<span style="color: #9ac0cd;">Token</span>*, <span style="color: #9ac0cd;">BaseFloat</span>&gt;::<span style="color: #9ac0cd;">const_iterator</span> <span style="color: #bebebe; font-weight: bold;">iter</span> =
            final_costs_.find(tok);
        <span style="color: #40e0d0; font-weight: bold;">if</span> (iter != final_costs_.end())
          ofst-&gt;SetFinal(cur_state, LatticeWeight(iter-&gt;second, 0));
      }
    }
  }
  KALDI_ASSERT(cur_state == ofst-&gt;NumStates());
  <span style="color: #40e0d0; font-weight: bold;">return</span> (cur_state != 0);
}

<span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#20808;&#35745;&#31639;raw lattice&#65292;&#28982;&#21518;&#29983;&#25104;&#26368;&#30701;&#36335;&#24452;&#30340;lattice</span>
<span style="color: #9ac0cd;">bool</span> <span style="color: #ff6347; font-weight: bold;">LatticeFasterDecoder</span>::<span style="color: #1e90ff; font-weight: bold;">GetBestPath</span>(<span style="color: #ff6347; font-weight: bold;">fst</span>::<span style="color: #9ac0cd;">MutableFst</span>&lt;<span style="color: #9ac0cd;">LatticeArc</span>&gt; *<span style="color: #bebebe; font-weight: bold;">ofst</span>) <span style="color: #40e0d0; font-weight: bold;">const</span> {
  <span style="color: #ff6347; font-weight: bold;">fst</span>::<span style="color: #9ac0cd;">VectorFst</span>&lt;<span style="color: #9ac0cd;">LatticeArc</span>&gt; <span style="color: #bebebe; font-weight: bold;">fst</span>;
  <span style="color: #40e0d0; font-weight: bold;">if</span> (!GetRawLattice(&amp;fst)) <span style="color: #40e0d0; font-weight: bold;">return</span> <span style="color: #ff6347; font-weight: bold;">false</span>;
  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">std::cout &lt;&lt; "Raw lattice is:\n";</span>
  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">fst::FstPrinter&lt;LatticeArc&gt; fstprinter(fst, NULL, NULL, NULL, false, true);</span>
  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">fstprinter.Print(&amp;std::cout, "standard output");</span>
  ShortestPath(fst, ofst);
  <span style="color: #40e0d0; font-weight: bold;">return</span> <span style="color: #ff6347; font-weight: bold;">true</span>;
}
<span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#30001;&#26368;&#30701;&#36335;&#24452;&#24471;&#21040;&#30340;fst&#65292;&#20854;ilabel&#23601;&#26159;alignment&#65292; &#20854;olabel&#23601;&#26159;words</span>
<span style="color: #9ac0cd;">bool</span> <span style="color: #1e90ff; font-weight: bold;">GetLinearSymbolSequence</span>(<span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">Fst</span>&lt;<span style="color: #9ac0cd;">Arc</span>&gt; &amp;<span style="color: #bebebe; font-weight: bold;">fst</span>,
                             <span style="color: #9ac0cd;">vector</span>&lt;I&gt; *<span style="color: #bebebe; font-weight: bold;">isymbols_out</span>,
                             <span style="color: #9ac0cd;">vector</span>&lt;I&gt; *<span style="color: #bebebe; font-weight: bold;">osymbols_out</span>,
                             <span style="color: #40e0d0; font-weight: bold;">typename</span> <span style="color: #ff6347; font-weight: bold;">Arc</span>::<span style="color: #9ac0cd;">Weight</span> *<span style="color: #bebebe; font-weight: bold;">tot_weight_out</span>) {
  <span style="color: #40e0d0; font-weight: bold;">typedef</span> <span style="color: #40e0d0; font-weight: bold;">typename</span> <span style="color: #ff6347; font-weight: bold;">Arc</span>::<span style="color: #9ac0cd;">Label</span> <span style="color: #9ac0cd;">Label</span>;
  <span style="color: #40e0d0; font-weight: bold;">typedef</span> <span style="color: #40e0d0; font-weight: bold;">typename</span> <span style="color: #ff6347; font-weight: bold;">Arc</span>::<span style="color: #9ac0cd;">StateId</span> <span style="color: #9ac0cd;">StateId</span>;
  <span style="color: #40e0d0; font-weight: bold;">typedef</span> <span style="color: #40e0d0; font-weight: bold;">typename</span> <span style="color: #ff6347; font-weight: bold;">Arc</span>::<span style="color: #9ac0cd;">Weight</span> <span style="color: #9ac0cd;">Weight</span>;

  <span style="color: #9ac0cd;">Weight</span> <span style="color: #bebebe; font-weight: bold;">tot_weight</span> = <span style="color: #ff6347; font-weight: bold;">Weight</span>::One();
  <span style="color: #9ac0cd;">vector</span>&lt;I&gt; <span style="color: #bebebe; font-weight: bold;">ilabel_seq</span>;
  <span style="color: #9ac0cd;">vector</span>&lt;I&gt; <span style="color: #bebebe; font-weight: bold;">olabel_seq</span>;

  <span style="color: #9ac0cd;">StateId</span> <span style="color: #bebebe; font-weight: bold;">cur_state</span> = fst.Start();
  <span style="color: #40e0d0; font-weight: bold;">if</span> (cur_state == kNoStateId) {  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">empty sequence.</span>
    <span style="color: #40e0d0; font-weight: bold;">if</span> (isymbols_out != <span style="color: #ff6347; font-weight: bold;">NULL</span>) isymbols_out-&gt;clear();
    <span style="color: #40e0d0; font-weight: bold;">if</span> (osymbols_out != <span style="color: #ff6347; font-weight: bold;">NULL</span>) osymbols_out-&gt;clear();
    <span style="color: #40e0d0; font-weight: bold;">if</span> (tot_weight_out != <span style="color: #ff6347; font-weight: bold;">NULL</span>) *tot_weight_out = <span style="color: #ff6347; font-weight: bold;">Weight</span>::Zero();
    <span style="color: #40e0d0; font-weight: bold;">return</span> <span style="color: #ff6347; font-weight: bold;">true</span>;
  }
  <span style="color: #40e0d0; font-weight: bold;">while</span> (1) {
    <span style="color: #9ac0cd;">Weight</span> <span style="color: #bebebe; font-weight: bold;">w</span> = fst.Final(cur_state);
    <span style="color: #40e0d0; font-weight: bold;">if</span> (w != <span style="color: #ff6347; font-weight: bold;">Weight</span>::Zero()) {  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">is final..</span>
      tot_weight = Times(w, tot_weight);
      <span style="color: #40e0d0; font-weight: bold;">if</span> (fst.NumArcs(cur_state) != 0) <span style="color: #40e0d0; font-weight: bold;">return</span> <span style="color: #ff6347; font-weight: bold;">false</span>;
      <span style="color: #40e0d0; font-weight: bold;">if</span> (isymbols_out != <span style="color: #ff6347; font-weight: bold;">NULL</span>) *isymbols_out = ilabel_seq;
      <span style="color: #40e0d0; font-weight: bold;">if</span> (osymbols_out != <span style="color: #ff6347; font-weight: bold;">NULL</span>) *osymbols_out = olabel_seq;
      <span style="color: #40e0d0; font-weight: bold;">if</span> (tot_weight_out != <span style="color: #ff6347; font-weight: bold;">NULL</span>) *tot_weight_out = tot_weight;
      <span style="color: #40e0d0; font-weight: bold;">return</span> <span style="color: #ff6347; font-weight: bold;">true</span>;
    } <span style="color: #40e0d0; font-weight: bold;">else</span> {
      <span style="color: #40e0d0; font-weight: bold;">if</span> (fst.NumArcs(cur_state) != 1) <span style="color: #40e0d0; font-weight: bold;">return</span> <span style="color: #ff6347; font-weight: bold;">false</span>; <span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#20160;&#20040;&#24847;&#24605;&#65292;&#22240;&#20026;&#36825;&#26159;&#26368;&#30701;&#36335;&#24452;&#30340;lattice</span>

      <span style="color: #9ac0cd;">ArcIterator</span>&lt;<span style="color: #9ac0cd;">Fst</span>&lt;<span style="color: #9ac0cd;">Arc</span>&gt; &gt; <span style="color: #bebebe; font-weight: bold;">iter</span>(fst, cur_state);  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">get the only arc.</span>
      <span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">Arc</span> &amp;<span style="color: #bebebe; font-weight: bold;">arc</span> = iter.Value();
      tot_weight = Times(arc.weight, tot_weight);
      <span style="color: #40e0d0; font-weight: bold;">if</span> (arc.ilabel != 0) ilabel_seq.push_back(arc.ilabel);
      <span style="color: #40e0d0; font-weight: bold;">if</span> (arc.olabel != 0) olabel_seq.push_back(arc.olabel);
      cur_state = arc.nextstate;
    }
  }
}
</pre>
</div>
<ol class="org-ol">
<li>同htk的两轮传播，词内传播和词间传播
</li>
<li>Token中ref_count_, 引用计数，类似htk中collected path, new path, old path
</li>
<li>garbage collected
</li>
<li>ProcessNonemitting: 空弧跳转, 队列实现，htk中递归实现
</li>
<li>ProcessEmitting:
</li>
<li>在解码处理上算法简单化，数据结构更加抽象
</li>
<li>代码看起来很清晰哈
</li>
</ol>
</div>
</li></ol>
</div>

<div id="outline-container-sec-4-8" class="outline-3">
<h3 id="sec-4-8"><span class="section-number-3">4.8</span> HMM topology and transition modeling</h3>
<div class="outline-text-3" id="text-4-8">
</div><ol class="org-ol"><li><a id="sec-4-8-1" name="sec-4-8-1"></a>HMM topology<br  /><div class="outline-text-4" id="text-4-8-1">
<pre class="example">
&lt;Topology&gt;
&lt;TopologyEntry&gt;
&lt;ForPhones&gt; 1 2 3 4 5 6 7 8 &lt;/ForPhones&gt;
&lt;State&gt; 0 &lt;PdfClass&gt; 0
&lt;Transition&gt; 0 0.5
&lt;Transition&gt; 1 0.5
&lt;/State&gt; 
&lt;State&gt; 1 &lt;PdfClass&gt; 1 
&lt;Transition&gt; 1 0.5
&lt;Transition&gt; 2 0.5
&lt;/State&gt;  
&lt;State&gt; 2 &lt;PdfClass&gt; 2
&lt;Transition&gt; 2 0.5
&lt;Transition&gt; 3 0.5
&lt;/State&gt;   
&lt;State&gt; 3
&lt;/State&gt;   
&lt;/TopologyEntry&gt;
&lt;/Topology&gt;
</pre>
<ul class="org-ul">
<li>pdfclass index
</li>
<li>状态3无pdf
</li>
<li>code
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #40e0d0; font-weight: bold;">struct</span> <span style="color: #9ac0cd;">HmmState</span> {
    <span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">pdf_class</span>;
    <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">pair</span>&lt;<span style="color: #9ac0cd;">int32</span>, BaseFloat&gt; &gt; <span style="color: #bebebe; font-weight: bold;">transitions</span>;
};
<span style="color: #40e0d0; font-weight: bold;">typedef</span> <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #9ac0cd;">HmmState</span>&gt; <span style="color: #9ac0cd;">TopologyEntry</span>;
<span style="color: #40e0d0; font-weight: bold;">class</span> <span style="color: #9ac0cd;">HmmTopology</span>{
  <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #9ac0cd;">int32</span>&gt; <span style="color: #bebebe; font-weight: bold;">phones_</span>;  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">&#25490;&#24207;&#30340;&#38899;&#32032;topo&#38598;&#21512;</span>
  <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #9ac0cd;">int32</span>&gt; <span style="color: #bebebe; font-weight: bold;">phone2idx_</span>;  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">&#38899;&#32032;&#21040;hmm topo&#32467;&#26500;&#30340;&#26144;&#23556;</span>
  <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #9ac0cd;">TopologyEntry</span>&gt; <span style="color: #bebebe; font-weight: bold;">entries_</span>; <span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">topo</span>
};
</pre>
</div>
</div>
</li>

<li><a id="sec-4-8-2" name="sec-4-8-2"></a>Pdf-classes<br  /></li>
<li><a id="sec-4-8-3" name="sec-4-8-3"></a>Transition models (the TransitionModel object)<br  /><div class="outline-text-4" id="text-4-8-3">
<pre class="example">
//             (phone, HMM-state, pdf-id) -&gt; transition-state
//   (transition-state, transition-index) -&gt; transition-id
 The most "natural" FST-based setups would have what we call pdf-ids on
 the input labels. However, bearing in mind that given our tree-building
 algorithms it will not always be possible to map uniquely from a pdf-id
 to a phone, this would make it hard to map from an input-label sequence
 to a phone sequence, and this is inconvenient for a number of reasons;
 it would also make it hard in general to train the transition probabilities
 using the information in the FST alone. For this reason we put identifiers
 called transition-ids on the input labels of the FST, and these can be mapped
 to the pdf-id but also to the phone and to a particular transition in a
 prototype HMM (as given in the HmmTopology object).
</pre>
<p>
why???
</p>
<ul class="org-ul">
<li>将HMM和GMMS(am-diag-gmm)连接起来
</li>
<li>The most "natural" FST-based setups would have what we call pdf-ids on the input labels.
</li>
</ul>
</div>

<ol class="org-ol"><li><a id="sec-4-8-3-0-1" name="sec-4-8-3-0-1"></a>Integer identifiers used by TransitionModel<br  /><div class="outline-text-6" id="text-4-8-3-0-1">
<ol class="org-ol">
<li>phone: 1-based
</li>
<li>hmm-state: 0-based
</li>
<li>transition-state: 1-based
</li>
<li>transition-index 0-based
</li>
<li>transition-id: 1-based
</li>
</ol>
</div>
</li>
<li><a id="sec-4-8-3-0-2" name="sec-4-8-3-0-2"></a>transition-id as input label<br  /></li>
<li><a id="sec-4-8-3-0-3" name="sec-4-8-3-0-3"></a>Alignments in Kaldi<br  /><div class="outline-text-6" id="text-4-8-3-0-3">
<ul class="org-ul">
<li>vector&lt;int32&gt;, which contains a sequence of transition-ids
</li>
</ul>
</div>
</li></ol>
</li></ol>
</div>
<div id="outline-container-sec-4-9" class="outline-3">
<h3 id="sec-4-9"><span class="section-number-3">4.9</span> How decision trees are used in Kaldi</h3>
<div class="outline-text-3" id="text-4-9">
<pre class="example">
we have a number of ways we can split the data by asking about, say, the left phone, 
the right phone, the central phone, the state we're in, and so on.
</pre>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="right" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="left">Name in code</td>
<td class="left">Name in command-line arguments</td>
<td class="right">Value (triphone)</td>
<td class="right">Value (monophone)</td>
</tr>

<tr>
<td class="left">N</td>
<td class="left">–context-width=?</td>
<td class="right">3</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">P</td>
<td class="left">–central-position=?</td>
<td class="right">1</td>
<td class="right">0</td>
</tr>
</tbody>
</table>
<pre class="example">
vector&lt;int32&gt; ctx_window = { 12, 15, 21 }; 三音素树 12-15+21， 0代表没有音素
kPdfClass=-1,一个音素生成TableEventMap(kPdfClass, map)
一个音素的所有状态生成一个table，每个状态生成一个ConstEventMap,id作为key
</pre>
</div>
</div>

<div id="outline-container-sec-4-10" class="outline-3">
<h3 id="sec-4-10"><span class="section-number-3">4.10</span> Decision tree internals</h3>
<div class="outline-text-3" id="text-4-10">
<ul class="org-ul">
<li>An event is just a set of (key,value) pairs, with no key repeated
</li>
</ul>
</div>
<ol class="org-ol"><li><a id="sec-4-10-1" name="sec-4-10-1"></a>数据结构<br  /><ol class="org-ol"><li><a id="sec-4-10-1-0-1" name="sec-4-10-1-0-1"></a>EventMap<br  /><div class="outline-text-6" id="text-4-10-1-0-1">
<ul class="org-ul">
<li>EventKeyType: int
</li>
<li>EventValueType: int
</li>
<li>EventAnswerType: int
</li>
<li>typedef std::vector&lt;std::pair&lt;EventKeyType,EventValueType&gt; &gt; EventType; 
</li>
<li>ConstantEventMap: 叶子节点
</li>
</ul>
<p>
answer_: 节点id，mono-tree中就是hmm-state的编号
</p>
<ul class="org-ul">
<li>TableEventMap:
</li>
</ul>
<pre class="example">
EventKeyType key_: key, -1时子树为叶节点， P时为hmm_sets
std::vector&lt;EventMap*&gt; table_: 各个子树
Lookup: 二分查找，event中查找key，返回id
MultiMap: 空查找所有，否则查找ans
MaxResult: 共多少个节点，返回最大节点编号
</pre>
</div>
</li>
<li><a id="sec-4-10-1-0-2" name="sec-4-10-1-0-2"></a>ContextDependency<br  /><div class="outline-text-6" id="text-4-10-1-0-2">
<ul class="org-ul">
<li>gmm-init-mono中如何构建一颗树
</li>
<li>GetPdfInfo: 返回每个pdf对应的音素状态
</li>
<li>to_pdf_
</li>
</ul>
</div>
</li>
<li><a id="sec-4-10-1-0-3" name="sec-4-10-1-0-3"></a>TransitionModel<br  /><div class="outline-text-6" id="text-4-10-1-0-3">
<ul class="org-ul">
<li>state2id_
</li>
<li>id2state_
</li>
<li>triples_
</li>
<li>ComputeTriples: 计算triples_
</li>
<li>ConputeDerived: 计算state2id_, id2state_
</li>
<li>InitializeProbs: 计算trans_id的log prob
</li>
<li>exp/mono/tree 格式： CE TE SE
</li>
</ul>
</div>
</li></ol>
</li>

<li><a id="sec-4-10-2" name="sec-4-10-2"></a>Clusterable<br  /><div class="outline-text-4" id="text-4-10-2">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #40e0d0; font-weight: bold;">class</span> <span style="color: #9ac0cd;">GaussClusterable</span>: <span style="color: #40e0d0; font-weight: bold;">public</span> <span style="color: #9ac0cd;">Clusterable</span> {
<span style="color: #40e0d0; font-weight: bold;">public</span>:
<span style="color: #40e0d0; font-weight: bold;">virtual</span> <span style="color: #9ac0cd;">void</span> <span style="color: #1e90ff; font-weight: bold;">Add</span>(<span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">Clusterable</span> &amp;<span style="color: #bebebe; font-weight: bold;">other_in</span>);
<span style="color: #40e0d0; font-weight: bold;">virtual</span> <span style="color: #9ac0cd;">void</span> <span style="color: #1e90ff; font-weight: bold;">Sub</span>(<span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">Clusterable</span> &amp;<span style="color: #bebebe; font-weight: bold;">other_in</span>);
<span style="color: #40e0d0; font-weight: bold;">virtual</span> <span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #1e90ff; font-weight: bold;">Normalizer</span>() <span style="color: #40e0d0; font-weight: bold;">const</span> { <span style="color: #40e0d0; font-weight: bold;">return</span> count_; }
<span style="color: #40e0d0; font-weight: bold;">virtual</span> <span style="color: #9ac0cd;">Clusterable</span> *<span style="color: #1e90ff; font-weight: bold;">Copy</span>() <span style="color: #40e0d0; font-weight: bold;">const</span>;
<span style="color: #9ac0cd;">double</span> <span style="color: #bebebe; font-weight: bold;">count_</span>;
<span style="color: #9ac0cd;">Matrix</span>&lt;<span style="color: #9ac0cd;">double</span>&gt; <span style="color: #bebebe; font-weight: bold;">stats_</span>; <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">two rows: sum, then sum-squared.</span>
<span style="color: #9ac0cd;">double</span> <span style="color: #bebebe; font-weight: bold;">var_floor_</span>; <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">should be common for all objects created.</span>
</pre>
</div>
</div>
</li>

<li><a id="sec-4-10-3" name="sec-4-10-3"></a>计算似然和似然增益<br  /><div class="outline-text-4" id="text-4-10-3">

<div class="figure">
<p><img src="/img/kaldi/tree_objf.png" alt="tree_objf.png" width="80%" />
</p>
</div>

<div class="figure">
<p><img src="/img/kaldi/tree_1.png" alt="tree_1.png" width="80%" />
</p>
</div>

<div class="figure">
<p><img src="/img/kaldi/tree_2.png" alt="tree_2.png" width="80%" />
</p>
</div>
</div>
</li>
<li><a id="sec-4-10-4" name="sec-4-10-4"></a>tools &amp; core code<br  /><ol class="org-ol"><li><a id="sec-4-10-4-0-1" name="sec-4-10-4-0-1"></a>acc-tree-stats<br  /><div class="outline-text-6" id="text-4-10-4-0-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">int</span> <span style="color: #bebebe; font-weight: bold;">i</span> = -N; <span style="color: #9ac0cd;">i</span> &lt; <span style="color: #40e0d0; font-weight: bold;">static_cast</span>&lt;<span style="color: #9ac0cd;">int</span>&gt;(split_alignment.size()); i++) {
  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">consider window starting at i, only if i+P is within</span>
  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">list of phones.</span>
  <span style="color: #40e0d0; font-weight: bold;">if</span> (i + P &gt;= 0 &amp;&amp; i + <span style="color: #9ac0cd;">P</span> &lt; <span style="color: #40e0d0; font-weight: bold;">static_cast</span>&lt;<span style="color: #9ac0cd;">int</span>&gt;(split_alignment.size())) {
    <span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">central_phone</span> =
        MapPhone(phone_map,
                 trans_model.TransitionIdToPhone(split_alignment[i+P][0]));
    <span style="color: #9ac0cd;">bool</span> <span style="color: #bebebe; font-weight: bold;">is_ctx_dep</span> = ! <span style="color: #ff6347; font-weight: bold;">std</span>::binary_search(ci_phones.begin(),
                                           ci_phones.end(),
                                           central_phone);
    <span style="color: #9ac0cd;">EventType</span> <span style="color: #bebebe; font-weight: bold;">evec</span>;
    <span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">int</span> <span style="color: #bebebe; font-weight: bold;">j</span> = 0; j &lt; N; j++) {
      <span style="color: #9ac0cd;">int</span> <span style="color: #bebebe; font-weight: bold;">phone</span>;
      <span style="color: #40e0d0; font-weight: bold;">if</span> (i + j &gt;= 0 &amp;&amp; i + <span style="color: #9ac0cd;">j</span> &lt; <span style="color: #40e0d0; font-weight: bold;">static_cast</span>&lt;<span style="color: #9ac0cd;">int</span>&gt;(split_alignment.size()))
        phone =
            MapPhone(phone_map,
                     trans_model.TransitionIdToPhone(split_alignment[i+j][0]));
      <span style="color: #40e0d0; font-weight: bold;">else</span>
        phone = 0;  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">ContextDependency class uses 0 to mean "out of window";</span>
      <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">we also set the phone arbitrarily to 0</span>

      <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">Don't add stuff to the event that we don't "allow" to be asked, due</span>
      <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">to the central phone being context-independent: check "is_ctx_dep".</span>
      <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">Why not just set the value to zero in this</span>
      <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">case?  It's for safety.  By omitting the key from the event, we</span>
      <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">ensure that there is no way a question can ever be asked that might</span>
      <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">give an inconsistent answer in tree-training versus graph-building.</span>
      <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">[setting it to zero would have the same effect given the "normal"</span>
      <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">recipe but might be less robust to changes in tree-building recipe].</span>
      <span style="color: #40e0d0; font-weight: bold;">if</span> (is_ctx_dep || j == P)
        evec.push_back(<span style="color: #ff6347; font-weight: bold;">std</span>::make_pair(<span style="color: #40e0d0; font-weight: bold;">static_cast</span>&lt;EventKeyType&gt;(j), <span style="color: #40e0d0; font-weight: bold;">static_cast</span>&lt;EventValueType&gt;(phone)));
    }
    <span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">int</span> <span style="color: #bebebe; font-weight: bold;">j</span> = 0; <span style="color: #9ac0cd;">j</span> &lt; <span style="color: #40e0d0; font-weight: bold;">static_cast</span>&lt;<span style="color: #9ac0cd;">int</span>&gt;(split_alignment[i+P].size());j++) {
      <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">for central phone of this window...</span>
      <span style="color: #9ac0cd;">EventType</span> <span style="color: #bebebe; font-weight: bold;">evec_more</span>(evec);
      <span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">pdf_class</span> = trans_model.TransitionIdToPdfClass(split_alignment[i+P][j]);
      <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">pdf_class will normally by 0, 1 or 2 for 3-state HMM.</span>
      <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">pair</span>&lt;EventKeyType, EventValueType&gt; <span style="color: #bebebe; font-weight: bold;">pr</span>(kPdfClass, pdf_class);
      evec_more.push_back(pr);
      <span style="color: #ff6347; font-weight: bold;">std</span>::sort(evec_more.begin(), evec_more.end());  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">these must be sorted!</span>
      <span style="color: #40e0d0; font-weight: bold;">if</span> (stats-&gt;count(evec_more) == 0)
        (*stats)[evec_more] = <span style="color: #40e0d0; font-weight: bold;">new</span> <span style="color: #9ac0cd;">GaussClusterable</span>(dim, var_floor);

      <span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #bebebe; font-weight: bold;">weight</span> = 1.0;
      (*stats)[evec_more]-&gt;AddStats(features.Row(cur_pos), weight);
      cur_pos++;
    }
  }
}
</pre>
</div>
</div>
</li>
<li><a id="sec-4-10-4-0-2" name="sec-4-10-4-0-2"></a>cluster-phones<br  /><div class="outline-text-6" id="text-4-10-4-0-2">
<div class="org-src-container">

<pre class="src src-cpp">  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">split by phone,&#26681;&#25454;&#20013;&#38388;&#38899;&#32032;&#20998;&#31867;&#65292;&#24182;&#32479;&#35745;</span>
  SplitStatsByKey(retained_stats, P, &amp;split_stats);
  <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #9ac0cd;">Clusterable</span>*&gt; <span style="color: #bebebe; font-weight: bold;">summed_stats</span>;  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">summed up by phone.</span>
  SumStatsVec(split_stats, &amp;summed_stats);
  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">&#26641;&#32858;&#31867;</span>
  <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;int32&gt; <span style="color: #bebebe; font-weight: bold;">assignments</span>;  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">assignment of phones to clusters. dim == summed_stats.size().</span>
  <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;int32&gt; <span style="color: #bebebe; font-weight: bold;">clust_assignments</span>;  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">Parent of each cluster.  Dim == #clusters.</span>
  <span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">num_leaves</span>;  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">number of leaf-level clusters.</span>
  TreeCluster(summed_stats_per_set,
              summed_stats_per_set.size(),  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">max-#clust is all of the points.</span>
              <span style="color: #ff6347; font-weight: bold;">NULL</span>,  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">don't need the clusters out.</span>
              &amp;assignments,
              &amp;clust_assignments,
              &amp;num_leaves,
              topts);
  <span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#35843;&#29992;</span>
  <span style="color: #9ac0cd;">TreeClusterer</span> <span style="color: #1e90ff; font-weight: bold;">tc</span>(points, max_clust, cfg);
  <span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #bebebe; font-weight: bold;">ans</span> = tc.Cluster(clusters_out, assignments_out, clust_assignments_out, num_leaves_out);
  <span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#31867;TreeCluster</span>
<span style="color: #40e0d0; font-weight: bold;">class</span> <span style="color: #9ac0cd;">TreeClusterer</span> {
  <span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#26641;&#32858;&#31867;</span>
  <span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #1e90ff; font-weight: bold;">Cluster</span>(<span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #9ac0cd;">Clusterable</span>*&gt; *<span style="color: #bebebe; font-weight: bold;">clusters_out</span>,
                    <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #9ac0cd;">int32</span>&gt; *<span style="color: #bebebe; font-weight: bold;">assignments_out</span>,
                    <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #9ac0cd;">int32</span>&gt; *<span style="color: #bebebe; font-weight: bold;">clust_assignments_out</span>,
                    <span style="color: #bebebe; font-weight: bold;">int32</span> *num_leaves_out) {
    <span style="color: #40e0d0; font-weight: bold;">while</span> (<span style="color: #40e0d0; font-weight: bold;">static_cast</span>&lt;int32&gt;(leaf_nodes_.size()) &lt; max_clust_ &amp;&amp; !queue_.empty()) {
      <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">pair</span>&lt;<span style="color: #9ac0cd;">BaseFloat</span>, <span style="color: #9ac0cd;">Node</span>*&gt; <span style="color: #bebebe; font-weight: bold;">pr</span> = queue_.top();
      queue_.pop();
      ans_ += pr.first;
      DoSplit(pr.second);
    }
    CreateOutput(clusters_out, assignments_out, clust_assignments_out,
                 num_leaves_out);
    <span style="color: #40e0d0; font-weight: bold;">return</span> ans_;
  }
  <span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#23545;&#19968;&#20010;&#33410;&#28857;&#36827;&#34892;&#20998;&#21106;</span>
  <span style="color: #9ac0cd;">void</span> <span style="color: #1e90ff; font-weight: bold;">DoSplit</span>(<span style="color: #9ac0cd;">Node</span> *<span style="color: #bebebe; font-weight: bold;">node</span>) {}
  <span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#23558;&#19968;&#20010;&#33410;&#28857;&#36827;&#34892;kmeans&#32858;&#31867;, &#27492;&#22788;kmeans&#32858;&#31867;&#27604;&#36739;&#29305;&#27530;&#65292;&#20026;&#20445;&#35777;&#32467;&#26524;&#36739;&#20248;&#65292;&#36827;&#34892;&#20102;&#22810;&#27425;&#19981;&#21516;&#21021;&#22987;&#21270;&#65292;&#24182;&#36873;&#25321;&#25928;&#26524;&#22909;&#30340;&#12290;</span>
  <span style="color: #9ac0cd;">void</span> <span style="color: #1e90ff; font-weight: bold;">FindBestSplit</span>(<span style="color: #9ac0cd;">Node</span> *<span style="color: #bebebe; font-weight: bold;">node</span>) {
    <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">takes a leaf node that has just been set up, and does ClusterKMeans with k = cfg_branch_factor.</span>
    KALDI_ASSERT(node-&gt;is_leaf);
    <span style="color: #40e0d0; font-weight: bold;">if</span> (node-&gt;leaf.points.size() == 0) {
      KALDI_WARN &lt;&lt; <span style="color: #ff0000;">"Warning: tree clustering: leaf with no data\n"</span>;
      node-&gt;leaf.best_split = 0; <span style="color: #40e0d0; font-weight: bold;">return</span>;
    }
    <span style="color: #40e0d0; font-weight: bold;">if</span> (node-&gt;leaf.points.size()&lt;=1) { node-&gt;leaf.best_split = 0; <span style="color: #40e0d0; font-weight: bold;">return</span>; }
    <span style="color: #40e0d0; font-weight: bold;">else</span> {
      <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">use kmeans.</span>
      <span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #bebebe; font-weight: bold;">impr</span> = ClusterKMeans(node-&gt;leaf.points,
                                     cfg_.branch_factor,
                                     &amp;node-&gt;leaf.clusters,
                                     &amp;node-&gt;leaf.assignments,
                                     cfg_.kmeans_cfg);
      node-&gt;leaf.best_split = impr;
      <span style="color: #40e0d0; font-weight: bold;">if</span> (impr &gt; cfg_.thresh)
        queue_.push(<span style="color: #ff6347; font-weight: bold;">std</span>::make_pair(impr, node));
    }
  }
}
</pre>
</div>
</div>
</li>
<li><a id="sec-4-10-4-0-3" name="sec-4-10-4-0-3"></a>compile-questions<br  /><div class="outline-text-6" id="text-4-10-4-0-3">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #9ac0cd;">Questions</span> <span style="color: #bebebe; font-weight: bold;">qo</span>;
<span style="color: #9ac0cd;">QuestionsForKey</span> <span style="color: #1e90ff; font-weight: bold;">phone_opts</span>(num_iters_refine);
<span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">the questions-options corresponding to keys 0, 1, .. N-1 which</span>
<span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">represent the phonetic context positions (including the central phone).</span>
phone_opts.initial_questions = questions;
<span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#23545;&#27599;&#20010;&#20301;&#32622;&#24314;&#31435;&#38382;&#39064;&#38598;</span>
<span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">n</span> = 0; n &lt; N; n++) {
  KALDI_LOG &lt;&lt; <span style="color: #ff0000;">"Setting questions for phonetic-context position "</span>&lt;&lt; n;
  qo.SetQuestionsOf(n, phone_opts);
}
<span style="color: #9ac0cd;">QuestionsForKey</span> <span style="color: #1e90ff; font-weight: bold;">pdfclass_opts</span>(num_iters_refine);
<span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #9ac0cd;">int32</span>&gt; &gt; <span style="color: #1e90ff; font-weight: bold;">pdfclass_questions</span>(max_num_pdfclasses-1);
<span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#23545;kPdfClass=-1&#38382;&#39064;&#38598;[ [0], [0, 1] ]</span>
<span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">i</span> = 0; i &lt; max_num_pdfclasses - 1; i++)
  <span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">j</span> = 0; j &lt;= i; j++)
    pdfclass_questions[i].push_back(j);
<span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">E.g. if max_num_pdfclasses == 3,  pdfclass_questions is now [ [0], [0, 1] ].</span>
pdfclass_opts.initial_questions = pdfclass_questions;
KALDI_LOG &lt;&lt; <span style="color: #ff0000;">"Setting questions for hmm-position [hmm-position ranges from 0 to "</span>&lt;&lt; (max_num_pdfclasses-1) &lt;&lt;<span style="color: #ff0000;">"]"</span>;
qo.SetQuestionsOf(kPdfClass, pdfclass_opts);
</pre>
</div>
</div>
</li>

<li><a id="sec-4-10-4-0-4" name="sec-4-10-4-0-4"></a>build-tree<br  /><div class="outline-text-6" id="text-4-10-4-0-4">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #9ac0cd;">EventMap</span> *<span style="color: #1e90ff; font-weight: bold;">SplitDecisionTree</span>(<span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">EventMap</span> &amp;<span style="color: #bebebe; font-weight: bold;">input_map</span>,
                            <span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">BuildTreeStatsType</span> &amp;<span style="color: #bebebe; font-weight: bold;">stats</span>,
                            <span style="color: #9ac0cd;">Questions</span> &amp;<span style="color: #bebebe; font-weight: bold;">q_opts</span>,
                            <span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #bebebe; font-weight: bold;">thresh</span>,
                            <span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">max_leaves</span>,  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">max_leaves&lt;=0 -&gt; no maximum.</span>
                            <span style="color: #9ac0cd;">int32</span> *<span style="color: #bebebe; font-weight: bold;">num_leaves</span>,
                            <span style="color: #9ac0cd;">BaseFloat</span> *<span style="color: #bebebe; font-weight: bold;">obj_impr_out</span>,
                            <span style="color: #9ac0cd;">BaseFloat</span> *<span style="color: #bebebe; font-weight: bold;">smallest_split_change_out</span>) {
  {  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">Do the splitting.</span>
    <span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">count</span> = 0;
    <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">priority_queue</span>&lt;<span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">pair</span>&lt;<span style="color: #9ac0cd;">BaseFloat</span>, <span style="color: #9ac0cd;">size_t</span>&gt; &gt; <span style="color: #bebebe; font-weight: bold;">queue</span>;  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">use size_t because logically these</span>
    <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">are just indexes into the array, not leaf-ids (after splitting they are no longer leaf id's).</span>
    <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">Initialize queue.</span>
    <span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">size_t</span> <span style="color: #bebebe; font-weight: bold;">i</span> = 0; i &lt; builders.size(); i++)
      queue.push(<span style="color: #ff6347; font-weight: bold;">std</span>::make_pair(builders[i]-&gt;BestSplit(), i));
    <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">Note-- queue's size never changes from now.  All the alternatives leaves to split are</span>
    <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">inside the "DecisionTreeSplitter*" objects, in a tree structure.</span>
    <span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#27492;&#22788;&#20026;&#37325;&#28857;&#65292;&#20248;&#20808;&#38431;&#21015;&#30340;&#20351;&#29992;&#65292;&#21450;&#20915;&#31574;&#26641;&#32456;&#27490;&#30340;&#20004;&#20010;&#26465;&#20214;</span>
    <span style="color: #40e0d0; font-weight: bold;">while</span> (queue.top().first &gt; thresh
          &amp;&amp; (max_leaves&lt;=0 || *num_leaves &lt; max_leaves)) {
      smallest_split_change = <span style="color: #ff6347; font-weight: bold;">std</span>::min(smallest_split_change, queue.top().first);
      <span style="color: #9ac0cd;">size_t</span> <span style="color: #bebebe; font-weight: bold;">i</span> = queue.top().second;
      like_impr += queue.top().first;
      builders[i]-&gt;DoSplit(num_leaves);
      queue.pop();
      queue.push(<span style="color: #ff6347; font-weight: bold;">std</span>::make_pair(builders[i]-&gt;BestSplit(), i));
      count++;
    }
    KALDI_LOG &lt;&lt; <span style="color: #ff0000;">"DoDecisionTreeSplit: split "</span>&lt;&lt; count &lt;&lt; <span style="color: #ff0000;">" times, #leaves now "</span> &lt;&lt; (*num_leaves);
  }
  ...
}
&#23547;&#25214;&#26368;&#20248;&#38382;&#39064;&#38598;&#31867;
<span style="color: #40e0d0; font-weight: bold;">class</span> <span style="color: #9ac0cd;">DecisionTreeSplitter</span> {
  <span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#36820;&#22238;&#26368;&#20248;&#30340;&#19968;&#20010;&#20998;&#21106;&#22686;&#30410;</span>
  <span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #1e90ff; font-weight: bold;">BestSplit</span>() { <span style="color: #40e0d0; font-weight: bold;">return</span> best_split_impr_; } <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">returns objf improvement (&gt;=0) of best possible split.</span>
  <span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#26500;&#36896;&#20989;&#25968;&#20013;&#21363;&#20174;&#38382;&#39064;&#38598;&#20013;&#23547;&#25214;&#26368;&#20248;&#38382;&#39064;</span>
  <span style="color: #1e90ff; font-weight: bold;">DecisionTreeSplitter</span>(<span style="color: #9ac0cd;">EventAnswerType</span> <span style="color: #bebebe; font-weight: bold;">leaf</span>, <span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">BuildTreeStatsType</span> &amp;<span style="color: #bebebe; font-weight: bold;">stats</span>,
                      <span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">Questions</span> &amp;<span style="color: #bebebe; font-weight: bold;">q_opts</span>): q_opts_(q_opts), yes_(<span style="color: #ff6347; font-weight: bold;">NULL</span>), no_(<span style="color: #ff6347; font-weight: bold;">NULL</span>), <span style="color: #9ac0cd;">leaf_</span>(<span style="color: #bebebe; font-weight: bold;">leaf</span>), <span style="color: #9ac0cd;">stats_</span>(<span style="color: #bebebe; font-weight: bold;">stats</span>) {
    <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">not, this must work when stats is empty too. [just gives zero improvement, non-splittable].</span>
    FindBestSplit();
  }
   <span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#22312;all_keys&#20013;&#25214;&#26368;&#20248;</span>
  <span style="color: #9ac0cd;">void</span> <span style="color: #1e90ff; font-weight: bold;">FindBestSplit</span>() {}
};

<span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #1e90ff; font-weight: bold;">ComputeInitialSplit</span>(<span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #9ac0cd;">Clusterable</span>*&gt; &amp;<span style="color: #bebebe; font-weight: bold;">summed_stats</span>,
                              <span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">Questions</span> &amp;<span style="color: #bebebe; font-weight: bold;">q_opts</span>, <span style="color: #bebebe; font-weight: bold;">EventKeyType</span> key,
                              <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;EventValueType&gt; *<span style="color: #bebebe; font-weight: bold;">yes_set</span>) {
  ...
  <span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;EventValueType&gt; &gt; &amp;<span style="color: #bebebe; font-weight: bold;">questions_of_this_key</span> = key_opts.initial_questions;

  <span style="color: #9ac0cd;">int32</span> <span style="color: #bebebe; font-weight: bold;">best_idx</span> = -1;
  <span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #bebebe; font-weight: bold;">best_objf_change</span> = 0;
  <span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#22312;&#38382;&#39064;&#38598;&#20013;&#23547;&#25214;&#20284;&#28982;&#22686;&#30410;&#26368;&#22823;&#30340;&#38382;&#39064;</span>
  <span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">size_t</span> <span style="color: #bebebe; font-weight: bold;">i</span> = 0; i &lt; questions_of_this_key.size(); i++) {
    <span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;EventValueType&gt; &amp;<span style="color: #bebebe; font-weight: bold;">yes_set</span> = questions_of_this_key[i];
    <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #9ac0cd;">int32</span>&gt; <span style="color: #bebebe; font-weight: bold;">assignments</span>(summed_stats.size(), 0);  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">0 is index of "no".</span>
    <span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #9ac0cd;">Clusterable</span>*&gt; <span style="color: #bebebe; font-weight: bold;">clusters</span>(2);  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">no and yes clusters.</span>
    <span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #ff6347; font-weight: bold;">std</span>::<span style="color: #ff6347; font-weight: bold;">vector</span>&lt;EventValueType&gt;::<span style="color: #9ac0cd;">const_iterator</span> <span style="color: #bebebe; font-weight: bold;">iter</span> = yes_set.begin(); iter != yes_set.end(); iter++) {
      KALDI_ASSERT(*iter&gt;=0);
      <span style="color: #40e0d0; font-weight: bold;">if</span> (*iter &lt; (<span style="color: #9ac0cd;">EventValueType</span>)assignments.size()) assignments[*iter] = 1;
    }
    <span style="color: #ff6347; font-weight: bold;">kaldi</span>::AddToClustersOptimized(summed_stats, assignments, *total, &amp;clusters);
    <span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #bebebe; font-weight: bold;">this_objf</span> = SumClusterableObjf(clusters);

    <span style="color: #40e0d0; font-weight: bold;">if</span> (this_objf &lt; unsplit_objf- 0.001*<span style="color: #ff6347; font-weight: bold;">std</span>::abs(unsplit_objf)) {  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">got worse; should never happen.</span>
      <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">of course small differences can be caused by roundoff.</span>
      KALDI_WARN &lt;&lt; <span style="color: #ff0000;">"Objective function got worse when building tree: "</span>&lt;&lt; this_objf &lt;&lt; <span style="color: #ff0000;">" &lt; "</span> &lt;&lt; unsplit_objf;
      KALDI_ASSERT(!(this_objf &lt; unsplit_objf - 0.01*(200 + <span style="color: #ff6347; font-weight: bold;">std</span>::abs(unsplit_objf))));  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">do assert on more stringent check.</span>
    }

    <span style="color: #9ac0cd;">BaseFloat</span> <span style="color: #bebebe; font-weight: bold;">this_objf_change</span> = this_objf - unsplit_objf;
    <span style="color: #40e0d0; font-weight: bold;">if</span> (this_objf_change &gt; best_objf_change) {
      best_objf_change = this_objf_change;
      best_idx = i;
    }
    DeletePointers(&amp;clusters);
  }
  <span style="color: #40e0d0; font-weight: bold;">delete</span> total;
  <span style="color: #40e0d0; font-weight: bold;">if</span> (best_idx != -1)
    *yes_set = questions_of_this_key[best_idx];
  <span style="color: #40e0d0; font-weight: bold;">return</span> best_objf_change;
}
</pre>
</div>
</div>
</li></ol>
</li></ol>
</div>
<div id="outline-container-sec-4-11" class="outline-3">
<h3 id="sec-4-11"><span class="section-number-3">4.11</span> Decoding graph construction in Kaldi</h3>
</div>
<div id="outline-container-sec-4-12" class="outline-3">
<h3 id="sec-4-12"><span class="section-number-3">4.12</span> Decoding-graph creation recipe(training time)</h3>
<div class="outline-text-3" id="text-4-12">
<pre class="example">
compile-train-graphs: 为每个语句训练一个wfst,即H*C*L*G，其中G为根据每条语句
生成的一个acceptor，利用这个fst在这个语句mfcc特征上进行解码，然后反向得到对齐
信息。
gmm-align-compiled：
具体步骤可参考：Internals of graph creation
</pre>
</div>
</div>

<div id="outline-container-sec-4-13" class="outline-3">
<h3 id="sec-4-13"><span class="section-number-3">4.13</span> Other kaldi utilities</h3>
<div class="outline-text-3" id="text-4-13">
</div><ol class="org-ol"><li><a id="sec-4-13-1" name="sec-4-13-1"></a>hash-list(util/hash-list.h)<br  /></li>
<li><a id="sec-4-13-2" name="sec-4-13-2"></a>kaldi-table(util/kaldi-table)<br  /><div class="outline-text-4" id="text-4-13-2">
<p>
实现w和r的参数解析
make valgrind
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-4-14" class="outline-3">
<h3 id="sec-4-14"><span class="section-number-3">4.14</span> Clustering mechanisms in Kaldi</h3>
<div class="outline-text-3" id="text-4-14">
<ul class="org-ul">
<li>Clusterable接口
</li>
<li>Clustering algorithms
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-15" class="outline-3">
<h3 id="sec-4-15"><span class="section-number-3">4.15</span> Acoustic modeling code</h3>
<div class="outline-text-3" id="text-4-15">
<ul class="org-ul">
<li>DiagGmmNormal
</li>
<li>DiagGmm 一个对角混合高斯模型
</li>
</ul>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #9ac0cd;">Vector</span>&lt;BaseFloat&gt; <span style="color: #bebebe; font-weight: bold;">weights_</span>;        <span style="color: #ee82ee;">///</span><span style="color: #ee82ee;">&lt; weights (not log).</span>
<span style="color: #9ac0cd;">Matrix</span>&lt;BaseFloat&gt; <span style="color: #bebebe; font-weight: bold;">inv_vars_</span>;       <span style="color: #ee82ee;">///</span><span style="color: #ee82ee;">&lt; Inverted (diagonal) variances</span>
<span style="color: #9ac0cd;">Matrix</span>&lt;BaseFloat&gt; <span style="color: #bebebe; font-weight: bold;">means_invvars_</span>;  <span style="color: #ee82ee;">///</span><span style="color: #ee82ee;">&lt; Means times inverted variance</span>
</pre>
</div>
<p>
Merge &amp; MergeKMeans ???
</p>
<ul class="org-ul">
<li>AmDiagGmm
</li>
<li>std::vector&lt;DiagGmm*&gt; densities_;
</li>
<li>num_pdfs个混合高斯模型
</li>
<li>pdf_index混合高斯索引
</li>
<li>LogLikelihood(pdf_index): 返回某个高斯的对数似然 
</li>
<li>You can think of AmDiagGmm as a vector of type DiagGmm
</li>
<li>FullGmm: Full-covariance GMMs
</li>
<li>AmSgmm: Subspace Gaussian Mixture Models (SGMMs)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-16" class="outline-3">
<h3 id="sec-4-16"><span class="section-number-3">4.16</span> Deep Neural Networks in Kaldi</h3>
<div class="outline-text-3" id="text-4-16">
</div><ol class="org-ol"><li><a id="sec-4-16-1" name="sec-4-16-1"></a>两种不同实现<br  /><div class="outline-text-4" id="text-4-16-1">
<ul class="org-ul">
<li>Karel's:效果好，不并行，使用预训练和交叉验证集。
</li>
<li>Dan's: 并行，无预训练，使用固定训练轮数
</li>
</ul>
</div>
</li>
<li><a id="sec-4-16-2" name="sec-4-16-2"></a>Dan's DNN implementation<br  /></li></ol>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 训练方式</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> lda(Linear Discriminant Analysis)</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>降维，且降维后使S_b 类间距要大,类内距离S_w 要小，等价于求WS_b W/WS_w W, 经推导最终
</li>
</ul>
<p>
等价于求S_w 的逆乘S_b 的特征值和特征向量。
</p>
<ul class="org-ul">
<li>经典HMM状态内帧间独立性的假设使得帧间相关的信息在HMM模型中没有得到很好的利用,而帧间
</li>
</ul>
<p>
线性判别分析相关信息对识别率的提高有很重要的作用。
</p>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> mllt(Maximum Likelihood Linear Transformation)</h3>
<div class="outline-text-3" id="text-5-2">
<p>
目前的语音识别系统大多都采用隐马尔可夫模型(Hidden Markov Model, HMM),但在实际应用中为了减少存
储空间和降低计算量,通常会假设输入HMM的协方差矩阵仅为对角线上有值(其他元素均为 0)。这样,通过PCA和LDA
得到的协方差矩阵不符合应用 HMM 的假设,造成失真从而影响识别率。本文引进最大似然线性转换(Maximum
Likelihood Linear Transformation, MLLT)改进PCA和LDA。与PCA和LDA相似,MLLT也是通过求取一个变换矩阵来
变换矢量空间, MLLT不会对数据进行降维,但可使变换后模式样本的协方差矩阵对角化。这样,通过MLLT后得到的
协方差矩阵就可以满足应用 HMM 的假设了。
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> sat</h3>
<div class="outline-text-3" id="text-5-3">
<p>
自适应
</p>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> sgmm(subspace gmm)</h3>
<div class="outline-text-3" id="text-5-4">
<p>
这个是什么原理，不懂哈
</p>
</div>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> mmi</h3>
<div class="outline-text-3" id="text-5-5">
<p>
Maximum Mutual Information(MMI)
</p>

<p>
Minimum Phone Error(MPE)
Minimum Word Error(MWE)
</p>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> kaldi中的数据文件及其作用</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> 数据准备(其中大部分文件均需要排序)</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>train_wav.scp test_wav.scp dev_wav.scp(data/local/data)
</li>
</ul>
<pre class="example">
作用: 数据文件列表
格式: FBMJ0_SI815 /home/robin1001/kaldi/kaldi-trunk/egs/timit/s5/../../../tools/sph2pipe_v2.5/sph2pipe -f wav /home/robin1001/data/timit/TIMIT/TRAIN/DR4/FBMJ0/SI815.WAV |
</pre>
<ul class="org-ul">
<li>train.text test.text dev.text(data/local/data)
</li>
</ul>
<pre class="example">
作用: 抄本, 注意sil扩展
格式: FAEM0_SI1392 sil ax s uw m f ao r ix vcl z ae m cl p uh l ax s n vcl d f iy l vcl s sil
</pre>
<ul class="org-ul">
<li>train.uttid test.uttid (data/local/data)
</li>
</ul>
<pre class="example">
作用: 文件唯一标识符
格式: 
FAEM0_SI1392
FAEM0_SI2022
</pre>
<ul class="org-ul">
<li>train.utt2spk train.spk2utt(data/local/data)
</li>
</ul>
<pre class="example">
作用: 说话人信息到uttid
使用: 1. 计算cmvn时, compute-cmvn-stats使用spk2uut
格式: 
utt2spk: FAEM0 FAEM0_SI1392 FAEM0_SI2022 FAEM0_SI762 FAEM0_SX132 FAEM0_SX222 FAEM0_SX312 FAEM0_SX402 FAEM0_SX42
spk2utt: FAEM0_SI1392 FAEM0
</pre>
<ul class="org-ul">
<li>train.spk2gender(data/local/data)
</li>
</ul>
<pre class="example">
作用: 说话人到性别信息
使用: 没有看到
格式: 
FAEM0 f
FAJW0 f
</pre>
<ul class="org-ul">
<li>train_dur.ark(data/local/data)
</li>
</ul>
<pre class="example">
作用: 训练数据时长信息
使用: 没有看到
格式: 
FAEM0_SI1392 4.761625 
FAEM0_SI2022 2.252812
</pre>
<ul class="org-ul">
<li>train.stm(data/local/data)
</li>
</ul>
<pre class="example">
作用: 扩展形式的超本，加入说话人，性别，时长信息
使用: 这是啥？
格式: 
;; LABEL "O" "Overall" "Overall"
;; LABEL "F" "Female" "Female speakers"
;; LABEL "M" "Male" "Male speakers"
FAEM0_SI1392 1 FAEM0 0.0 4.761625 &lt;O,M&gt;  sil ax s uw m f ae n vcl d f iy l vcl s sil
</pre>
<ul class="org-ul">
<li>train.glm(data/local/data)
</li>
</ul>
<pre class="example">
作用: 这是啥？
格式: 所有内容都在这儿
;; empty.glm
  [FAKE]     =&gt;  %HESITATION     / [ ] __ [ ] ;; hesitation token
</pre>
<p>
<b>以上内容在format_data时会被分类整理在data/train, data/test, data/dev目录下,整理时名称可能会有改变</b>
</p>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 字典准备</h3>
<div class="outline-text-3" id="text-6-2">
<ul class="org-ul">
<li>silence_phones.txt nonsilence_phones.txt(data/local/dict)
</li>
</ul>
<pre class="example">
使用: prepare_lang时使用，作为输入
格式
sil
----------------
aa
bb
</pre>
<ul class="org-ul">
<li>phones.txt(data/local/dict)
</li>
</ul>
<pre class="example">
使用: prepare_lang时使用
格式:
aa
ae
...
sil
...
zh
</pre>
<ul class="org-ul">
<li>lexicon.txt(data/local/dict)
</li>
</ul>
<pre class="example">
作用: 词典
格式: 此处因为timit是音素级的抄本，所以lexicon长这样
aa	aa
ae	ae
ah	ah
</pre>
<ul class="org-ul">
<li>extra_questions.txt(data/local/dict)
</li>
</ul>
<pre class="example">
作用: 初始的问题集，分为sil和其他两类
使用: cat $lang/phones/extra_questions.int &gt;&gt; $dir/questions.int
格式: 
sil 
aa ae ah ao aw ax ay b ch cl d dh dx eh el en epi er ey f g hh ih ix iy jh k l m n ng ow oy p r s sh t th uh uw v vcl w y z zh
</pre>
<ul class="org-ul">
<li>lm_train.text(data/local/data)
</li>
</ul>
<pre class="example">
作用: 格式化抄本，添加语言模型的&lt;s&gt;&amp;&lt;/s&gt;
格式: 
&lt;s&gt; sil w ah dx aw f ix cl d uh sh iy vcl d r ay v f ao sil &lt;/s&gt;
&lt;s&gt; sil f ih l s epi m ao l hh ow l ix n vcl b ow l w ih th cl k l ey sil &lt;/s&gt;
使用: 去除uutid，作为build-lm.sh输入
</pre>
<ul class="org-ul">
<li>lm_phone_bg.arpa.gz(data/local/nist_lm)
</li>
</ul>
<pre class="example">
作用:编译并压缩后的语言模型
格式：
\data\
ngram  1=        51
ngram  2=      1694 

\1-grams:
-4.8574 &lt;s&gt; -2.96614
-1.24019    sil -2.27704
-1.56815    ax  -2.02608
...
\2-grams:
-0.000442966    &lt;s&gt; sil
-3.37261    sil sil
-1.83346    sil ax
-1.62848    sil s
-3.71728    sil uw
使用: format_data生成G.fst
</pre>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> lang(此处有个中间文件utils/apply_map.pl phone_map）</h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>sets.txt sets.int(data/lang/phones)
</li>
</ul>
<pre class="example">
使用: 1. shared_phones_opt=set.int, gmm-init-mono
格式: 
sil
aa
ae
...
------------
1
2
3
...
</pre>
<ul class="org-ul">
<li>root.txt (data/lang/phones)
</li>
</ul>
<pre class="example">
作用: 
格式:
shared split sil
shared split aa
shared split ae
-----------------
shared split 1
shared split 2
shared split 3
</pre>
<ul class="org-ul">
<li>silence.txt,nonsilence.txt, silence.int, nonsilence.int(data/lang/phones)
</li>
</ul>
<pre class="example">
作用: 
格式: 估计你都猜到了，不粘了
silence.csl
1
nonsilencs.csl
2:3:4:5:6:7:8:9:10:11:12:13:14:15:16:17:18:19:20:21:22:23:24:25:26:27:28:29:30:31:32:33:34:35:36:37:38:39:40:41:42:43:44:45:46:47:48
</pre>
<ul class="org-ul">
<li>disambig.txt(data/lang/phones)
</li>
</ul>
<pre class="example">
作用: fst的两个辅助消歧符号
格式: 
#0
#1
</pre>
<ul class="org-ul">
<li>phones.txt(data/lang/phones.txt)
</li>
</ul>
<pre class="example">
作用: openfst形式isymbol-map
格式: 
&lt;eps&gt; 0
sil 1
aa 2
ae 3
...
#0 49
#1 50
</pre>
<ul class="org-ul">
<li>word_boundary.txt(没有用到)
</li>
<li>words.txt
</li>
</ul>
<pre class="example">
作用: openfst形式isymbol-map
使用: 解码时--word-symbol-table=words.txt
格式: 
&lt;eps&gt; 0
aa 1
ae 2
ah 3
...
#0 49
</pre>
<ul class="org-ul">
<li>align_lexicon.txt
</li>
</ul>
<pre class="example">
作用: 
格式: 
&lt;eps&gt; &lt;eps&gt; sil
aa aa aa
ae ae ae
...
zh zh zh
</pre>
<ul class="org-ul">
<li>lexiconp.txt(data/local/dict)
</li>
</ul>
<pre class="example">
作用: 
格式: 
aa	1.0	aa
ae	1.0	ae
ah	1.0	ah
</pre>
<ul class="org-ul">
<li>oov.txt oov.int(data/lang)
</li>
</ul>
<pre class="example">
作用: 1. compile-train-graphs作为输入
      2. 
sil
------------
38
</pre>
<ul class="org-ul">
<li>L.fst L.disambig.fst(data/lang)
</li>
</ul>
<div class="org-src-container">

<pre class="src src-sh">utils/make_lexicon_fst.pl --pron-probs $<span style="color: #bebebe; font-weight: bold;">tmpdir</span>/lexiconp.txt $<span style="color: #bebebe; font-weight: bold;">sil_prob</span> $<span style="color: #bebebe; font-weight: bold;">silphone</span> | <span style="color: #ff0000;">\</span>
  fstcompile --isymbols=$<span style="color: #bebebe; font-weight: bold;">dir</span>/phones.txt --osymbols=$<span style="color: #bebebe; font-weight: bold;">dir</span>/words.txt <span style="color: #ff0000;">\</span>
  --keep_isymbols=false --keep_osymbols=false | <span style="color: #ff0000;">\</span>
   fstarcsort --sort_type=olabel &gt; $<span style="color: #bebebe; font-weight: bold;">dir</span>/L.fst || <span style="color: #40e0d0; font-weight: bold;">exit</span> 1;
</pre>
</div>
<pre class="example">
使用: 1. compile-train-graph，为训练语句编译fst, 如exp/x/fsts.JOB.gz
      2. 解码时生成HCLG.fst, 使用的是L.disambig.fst
fst状态转换
0	1	&lt;eps&gt;	&lt;eps&gt;	0.693147180559945
0	1	sil	&lt;eps&gt;	0.693147180559945
2	1	sil	&lt;eps&gt;
1	1	aa	aa	0.693147180559945
1	2	aa	aa	0.693147180559945
1	1	ae	ae	0.693147180559945
1	2	ae	ae	0.693147180559945
1	1	ah	ah	0.693147180559945
1	2	ah	ah	0.693147180559945
1	1	ao	ao	0.693147180559945
1	2	ao	ao	0.693147180559945
1	1	aw	aw	0.693147180559945
1	2	aw	aw	0.693147180559945
1	1	ax	ax	0.693147180559945
1	2	ax	ax	0.693147180559945
1	1	ay	ay	0.693147180559945
1	2	ay	ay	0.693147180559945
1	1	b	b	0.693147180559945
...
1	1	zh	zh	0.693147180559945
1	2	zh	zh	0.693147180559945
1	0
</pre>
<ul class="org-ul">
<li>topo(data/lang)
</li>
</ul>
<pre class="example">
作用: HMM集合及其拓扑结构
使用: 1. 训练过程中模型的初始化，如gmm-init-mono
      2. 获取问题集compile-questions
格式:
&lt;Topology&gt;
&lt;TopologyEntry&gt;
&lt;ForPhones&gt;
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48
&lt;/ForPhones&gt;
&lt;State&gt; 0 &lt;PdfClass&gt; 0 &lt;Transition&gt; 0 0.75 &lt;Transition&gt; 1 0.25 &lt;/State&gt;
&lt;State&gt; 1 &lt;PdfClass&gt; 1 &lt;Transition&gt; 1 0.75 &lt;Transition&gt; 2 0.25 &lt;/State&gt;
&lt;State&gt; 2 &lt;PdfClass&gt; 2 &lt;Transition&gt; 2 0.75 &lt;Transition&gt; 3 0.25 &lt;/State&gt;
&lt;State&gt; 3 &lt;/State&gt;
&lt;/TopologyEntry&gt;
&lt;TopologyEntry&gt;
&lt;ForPhones&gt;
1
&lt;/ForPhones&gt;
&lt;State&gt; 0 &lt;PdfClass&gt; 0 &lt;Transition&gt; 0 0.5 &lt;Transition&gt; 1 0.5 &lt;/State&gt;
&lt;State&gt; 1 &lt;PdfClass&gt; 1 &lt;Transition&gt; 1 0.5 &lt;Transition&gt; 2 0.5 &lt;/State&gt;
&lt;State&gt; 2 &lt;PdfClass&gt; 2 &lt;Transition&gt; 2 0.75 &lt;Transition&gt; 3 0.25 &lt;/State&gt;
&lt;State&gt; 3 &lt;/State&gt;
&lt;/TopologyEntry&gt;
&lt;/Topology&gt;
</pre>
</div>
</div>
<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> format_data</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>format
</li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="right">id</td>
<td class="left">src</td>
<td class="left">dest</td>
</tr>

<tr>
<td class="right">1</td>
<td class="left">train_wav.scp</td>
<td class="left">train/wav.scp</td>
</tr>

<tr>
<td class="right">2</td>
<td class="left">train.text</td>
<td class="left">train/text</td>
</tr>

<tr>
<td class="right">3</td>
<td class="left">train.spk2utt</td>
<td class="left">train/spk2uut</td>
</tr>

<tr>
<td class="right">4</td>
<td class="left">train.spk2gen</td>
<td class="left">train/spk2gender</td>
</tr>

<tr>
<td class="right">5</td>
<td class="left">train.stm</td>
<td class="left">train/stm</td>
</tr>

<tr>
<td class="right">6</td>
<td class="left">train.glm</td>
<td class="left">train/glm</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>G.fst
</li>
</ul>
<pre class="example">
格式:
0   1   &lt;s&gt; &lt;s&gt;
1   2   &lt;eps&gt;   &lt;eps&gt;   6.82978964
1   3   sil sil 0.00101996691
2   3   sil sil 2.85564303
2   4   ax  ax  3.61079884
2   5   s   s   3.14913034
2   6   uw  uw  4.3006072
2   7   m   m   3.69825077
2   8   f   f   4.17426443
2   9   ao  ao  4.34617519
2   10  r   r   3.42624664
2   11  ix  ix  2.97240686
2   12  vcl vcl 2.99313045
2   13  z   z   3.66624475
2   14  ae  ae  4.14011717
2   15  cl  cl  2.44272041
2   16  p   p   4.01870155
</pre>
</div>
</div>
<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> 特征提取</h3>
<div class="outline-text-3" id="text-6-5">
<ul class="org-ul">
<li>raw_mfcc_train.1.scp raw_mfcc_train.1.ark(mfcc)
</li>
</ul>
<pre class="example">
格式: scp
FADG0_SI1279 /home/robin1001/kaldi/kaldi-trunk/egs/timit/s5/mfcc/raw_mfcc_dev.1.ark:13
FADG0_SI1909 /home/robin1001/kaldi/kaldi-trunk/egs/timit/s5/mfcc/raw_mfcc_dev.1.ark:2491
</pre>
<ul class="org-ul">
<li>feats.scp(data/{train, test, dev})
</li>
</ul>
<pre class="example">
作用: 由并行提到特征文件合成所有的特征列表
</pre>
<ul class="org-ul">
<li>cmvn_train.scp cmvn_train.ark
</li>
</ul>
<div class="org-src-container">

<pre class="src src-sh">compute-cmvn-stats --spk2utt=ark:$<span style="color: #bebebe; font-weight: bold;">data</span>/spk2utt scp:$<span style="color: #bebebe; font-weight: bold;">data</span>/feats.scp ark,scp:$<span style="color: #bebebe; font-weight: bold;">cmvndir</span>/cmvn_$<span style="color: #bebebe; font-weight: bold;">name</span>.ark,$<span style="color: #bebebe; font-weight: bold;">cmvndir</span>/cmvn_$<span style="color: #bebebe; font-weight: bold;">name</span>.scp
</pre>
</div>
<pre class="example">
作用: 统计每个说话人的cmvn信息
格式:
FAPB0 /home/robin1001/kaldi/kaldi-trunk/egs/timit/s5/mfcc/cmvn_train.ark:986
FBAS0 /home/robin1001/kaldi/kaldi-trunk/egs/timit/s5/mfcc/cmvn_train.ark:1231
</pre>
</div>
</div>
<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6"><span class="section-number-3">6.6</span> 决策树</h3>
<div class="outline-text-3" id="text-6-6">
<ul class="org-ul">
<li>question.int question.txt
</li>
</ul>
<pre class="example">
sil 
sil b ch cl d dh dx epi f g hh jh k p s sh t th v vcl z zh 
sil ch f s sh z 
aa 
aa ae ah ao aw ax ay eh el en er ey ih ix iy l m n ng ow oy r uh uw w y 
aa ae ao aw ay eh ey ih iy ow y 
aa ae ao aw ay ow 
aa ao 
aa ao ow 
ae 
ae aw 
ae aw ay 
ah 
ah ax el en er ix l m n ng oy r uh uw w 
ah ax er ix oy r uh uw 
ah ax ix uh 
ah ax ix uh uw 
ah ax uh
</pre>
</div>
</div>
<div id="outline-container-sec-6-7" class="outline-3">
<h3 id="sec-6-7"><span class="section-number-3">6.7</span> 训练</h3>
<div class="outline-text-3" id="text-6-7">
<ul class="org-ul">
<li>x.mdl find.mdl(exp/x/)
</li>
</ul>
<pre class="example">
格式:
&lt;TransitionModel&gt; 
&lt;Topology&gt; 
&lt;TopologyEntry&gt; 
&lt;ForPhones&gt; 
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 
&lt;/ForPhones&gt; 
&lt;State&gt; 0 &lt;PdfClass&gt; 0 &lt;Transition&gt; 0 0.75 &lt;Transition&gt; 1 0.25 &lt;/State&gt; 
&lt;State&gt; 1 &lt;PdfClass&gt; 1 &lt;Transition&gt; 1 0.75 &lt;Transition&gt; 2 0.25 &lt;/State&gt; 
&lt;State&gt; 2 &lt;PdfClass&gt; 2 &lt;Transition&gt; 2 0.75 &lt;Transition&gt; 3 0.25 &lt;/State&gt; 
&lt;State&gt; 3 &lt;/State&gt; 
&lt;/TopologyEntry&gt; 
&lt;TopologyEntry&gt; 
&lt;ForPhones&gt; 
1 
&lt;/ForPhones&gt; 
&lt;State&gt; 0 &lt;PdfClass&gt; 0 &lt;Transition&gt; 0 0.5 &lt;Transition&gt; 1 0.5 &lt;/State&gt; 
&lt;State&gt; 1 &lt;PdfClass&gt; 1 &lt;Transition&gt; 1 0.5 &lt;Transition&gt; 2 0.5 &lt;/State&gt; 
&lt;State&gt; 2 &lt;PdfClass&gt; 2 &lt;Transition&gt; 2 0.75 &lt;Transition&gt; 3 0.25 &lt;/State&gt; 
&lt;State&gt; 3 &lt;/State&gt; 
&lt;/TopologyEntry&gt; 
&lt;/Topology&gt; 
&lt;Triples&gt; 1967 
1 0 0 
1 1 51 
1 2 48 
2 0 1 
2 0 169 
2 0 286 
...
&lt;/LogProbs&gt; 
&lt;/TransitionModel&gt; 
&lt;DIMENSION&gt; 39 &lt;NUMPDFS&gt; 1921 &lt;DiagGMM&gt; 
&lt;GCONSTS&gt;  [ -95.17706 -81.32135 -151.1496 -92.49072 -76.49657 -73.69149 -125.8088 -83.51283 -104.7302 -87.7104 -85.27476 -84.29331 -74.78059 -115.8744 -80.226
36 -93.32332 -95.39783 -128.1057 -80.69289 -94.86904 -77.14107 -125.0487 -85.18453 -80.24683 -80.09453 -115.6893 ]
&lt;WEIGHTS&gt;  [ 0.0376287 0.03753155 0.03834436 0.04315818 0.05027013 0.04145537 0.03278675 0.04632599 0.04273623 0.03133279 0.04082224 0.04645732 0.03122336 0.02
904686 0.03832259 0.04545283 0.04021866 0.041621 0.04777169 0.03450852 0.04088681 0.03478571 0.03945986 0.03233045 0.0284235 0.02709854 ]
&lt;MEANS_INVVARS&gt;  [
  -0.2801608 -0.07388612 0.05452524 -0.0001664911 0.1077678 0.09175234 0.08498141 0.09413936 0.020672 0.02511335 0.006077958 -0.0216168 0.008959025 -0.5031475 
-0.41583 -0.2404581 -0.1
...
</pre>
<ul class="org-ul">
<li>tree(exp/x)
</li>
</ul>
<pre class="example">
作用: 三音素决策树
格式:
ContextDependency 3 1 ToPdf TE 1 49 ( NULL SE -1 [ 0 1 ]
{ SE -1 [ 0 ]
{ CE 0 CE 51 } 
CE 48 } 
SE -1 [ 0 ]
{ SE 0 [ 1 9 10 11 12 13 14 18 21 22 23 27 28 35 37 38 39 40 43 44 47 48 ]
{ SE 0 [ 1 ]
{ CE 1 SE 2 [ 19 34 36 ]
{ SE 0 [ 21 ]
{ CE 1268 SE 0 [ 9 12 13 23 35 ]
{ SE 0 [ 9 12 13 ]
</pre>
<ul class="org-ul">
<li>exp/x/fsts.JOB.gz
</li>
</ul>
<pre class="example">
作用: 为每个训练语句由L.fst编译fst
</pre>
<ul class="org-ul">
<li>exp/x/i.JOB.acc
</li>
</ul>
<pre class="example">
作用: 对齐信息
格式:
trn_adg04_sr249 285 283 283 283 283 283 283 283 283 291 292 292 292 292 292 292
290 300 299 266 265 265 265 268 267 270 269 269 269 14 16 18 230 229 232 231 234
146 145 145 145 148 147 150 149 149 149 149 149 104 103 106 108 107 107 107 194
196 195 195 198 197 32 31 34 33 36 35 44 43 43 43 46 45 48 128 130 129 129 132
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> reading tools</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>gmm-copy &#x2013;binary=false exp/mono/0.mdl - | less
</li>
<li>copy-tree &#x2013;binary=false exp/mono/tree - | less
</li>
<li>show-alignments data/lang/phones.txt exp/mono/0.mdl ark:exp/mono/cur.ali | less
</li>
<li>show-transitions data/lang/phones.txt exp/mono/0.mdl
</li>
<li>sum-tree-stats &#x2013;binary=false - exp/tri1/treeacc | less
</li>
<li>scripts/int2sym.pl data/lang/phones.txt &lt; exp/tri1/questions.int
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> fst</h2>
<div class="outline-text-2" id="text-8">
<p>
Created by:robin1001 <span class="timestamp-wrapper"><span class="timestamp">&lt;2014-08-27 三&gt;</span></span>
</p>
</div>
<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> 定义</h3>
<div class="outline-text-3" id="text-8-1">
<ul class="org-ul">
<li>P(Q1, Q2): Q1到Q2的所有路径
</li>
<li>P(Q1, x, Q2): 接受x的Q1-&gt;Q2 | A
</li>
<li>P(Q1, x, y, Q2): 接受x,输出y的Q1-&gt;Q2 | T
</li>
<li>[A](x): 接受x的所有路径 | A
</li>
<li>[T](x, y) 接受x,输出y的所有路径 | T
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> 空转移</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>算法插入
</li>
<li>一对多的映射（比如&#x2026;)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> A &amp; T</h3>
<div class="outline-text-3" id="text-8-3">
<p>
在Acceptor中使input和output相同即可模拟transducer
</p>
</div>
</div>

<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> 运算</h3>
<div class="outline-text-3" id="text-8-4">
<ul class="org-ul">
<li>union: 或运算
</li>
<li>concate: 连接
</li>
<li>closure: 闭包
</li>
<li>reverse: 反转
</li>
<li>inverse: 逆，input和output对调
</li>
<li>project: T-&gt;A
</li>
<li>composition: 组合，将不同层次的信息组合起来
</li>
<li>含epsilon和不含epsilon两种模型
</li>
<li>组合算法
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5"><span class="section-number-3">8.5</span> 确定化</h3>
<div class="outline-text-3" id="text-8-5">
</div><ol class="org-ol"><li><a id="sec-8-5-1" name="sec-8-5-1"></a>何为确定化<br  /><div class="outline-text-4" id="text-8-5-1">
<ol class="org-ol">
<li>单一初始状态
</li>
<li>一个状态不存在input相同的两条出弧
</li>
<li>openfst和ATT FSM将epsilon作为一个正常的symbol
</li>
</ol>
</div>
</li>

<li><a id="sec-8-5-2" name="sec-8-5-2"></a>确定化算法<br  /><div class="outline-text-4" id="text-8-5-2">
<ul class="org-ul">
<li>算法简单理解：合并公共前缀
</li>
</ul>
</div>
</li></ol>
</div>

<div id="outline-container-sec-8-6" class="outline-3">
<h3 id="sec-8-6"><span class="section-number-3">8.6</span> 最小化</h3>
<div class="outline-text-3" id="text-8-6">
<ul class="org-ul">
<li>算法简单理解：合并公共后缀
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-8-7" class="outline-3">
<h3 id="sec-8-7"><span class="section-number-3">8.7</span> Weight Pushing</h3>
<div class="outline-text-3" id="text-8-7">
<ul class="org-ul">
<li>权重可以向init states | final states移动
</li>
<li>应用：arc权重的归一化
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-8-8" class="outline-3">
<h3 id="sec-8-8"><span class="section-number-3">8.8</span> Epsilon消除</h3>
</div>
<div id="outline-container-sec-8-9" class="outline-3">
<h3 id="sec-8-9"><span class="section-number-3">8.9</span> linux fst 程序编译</h3>
<div class="outline-text-3" id="text-8-9">
<p>
g++ -O0 fst.cpp -o fst -I/home/robin1001/kaldi/kaldi-trunk/tools/openfst/include -L/home/robin1001/kaldi/kaldi-trunk/tools/openfst/lib -lfst -Wl,-rpath,/home/robin1001/kaldi/kaldi-trunk/tools/openfst/lib
-Wl,rpath=&lt;your_lib_dir&gt;，使得execute记住链接库的位置
</p>
</div>
</div>
<div id="outline-container-sec-8-10" class="outline-3">
<h3 id="sec-8-10"><span class="section-number-3">8.10</span> 数据结构</h3>
<div class="outline-text-3" id="text-8-10">
</div><ol class="org-ol"><li><a id="sec-8-10-1" name="sec-8-10-1"></a>StdArc<br  /><div class="outline-text-4" id="text-8-10-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #40e0d0; font-weight: bold;">struct</span> <span style="color: #9ac0cd;">StdArc</span> {
 <span style="color: #40e0d0; font-weight: bold;">typedef</span> <span style="color: #9ac0cd;">int</span> <span style="color: #9ac0cd;">Label</span>;
 <span style="color: #40e0d0; font-weight: bold;">typedef</span> <span style="color: #9ac0cd;">TropicalWeight</span> <span style="color: #9ac0cd;">Weight</span>;  <span style="color: #ee82ee;">// </span><span style="color: #ee82ee;">see "FST Weights" below </span>
 <span style="color: #40e0d0; font-weight: bold;">typedef</span> <span style="color: #9ac0cd;">int</span> <span style="color: #9ac0cd;">StateId</span>; 

 <span style="color: #9ac0cd;">Label</span> <span style="color: #bebebe; font-weight: bold;">ilabel</span>;
 <span style="color: #9ac0cd;">Label</span> <span style="color: #bebebe; font-weight: bold;">olabel</span>;
 <span style="color: #9ac0cd;">Weight</span> <span style="color: #bebebe; font-weight: bold;">weight</span>;
 <span style="color: #9ac0cd;">StateId</span> <span style="color: #bebebe; font-weight: bold;">nextstate</span>;
};
<span style="color: #40e0d0; font-weight: bold;">for</span> (<span style="color: #9ac0cd;">ArcIterator</span>&lt;StdFst&gt; <span style="color: #bebebe; font-weight: bold;">aiter</span>(fst, i); !aiter.Done(); aiter.Next())
  <span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">StdArc</span> &amp;<span style="color: #bebebe; font-weight: bold;">arc</span> = aiter.Value();
<span style="color: #9ac0cd;">Matcher</span>&lt;StdFst&gt; <span style="color: #1e90ff; font-weight: bold;">matcher</span>(fst, MATCH_INPUT);
matcher.SetState(i);
<span style="color: #40e0d0; font-weight: bold;">if</span> (matcher.Find(l)) 
  <span style="color: #40e0d0; font-weight: bold;">for</span> (; !matcher.Done(); matcher.Next())
     <span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">StdArc</span> &amp;<span style="color: #bebebe; font-weight: bold;">arc</span> = matcher.Value();
</pre>
</div>
</div>
</li>
<li><a id="sec-8-10-2" name="sec-8-10-2"></a>fst<br  /><div class="outline-text-4" id="text-8-10-2">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#25277;&#35937;&#31867;</span>
<span style="color: #9ac0cd;">Fst</span>&lt;Arc&gt;
<span style="color: #9ac0cd;">ExpandedFst</span>&lt;Arc&gt;: +NumStates();
<span style="color: #9ac0cd;">MutableFst</span>&lt;Arc&gt;: &#21487;&#21464;&#30340;fst&#65292;&#22914;AddStates(), SetStart()

<span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">&#23454;&#29616;</span>
<span style="color: #9ac0cd;">VectorFst</span>&lt;Arc&gt;: <span style="color: #40e0d0; font-weight: bold;">mutable</span> fst
<span style="color: #9ac0cd;">ConstFst</span>&lt;Arc&gt;:  immutable fst
<span style="color: #9ac0cd;">ComposeFst</span>&lt;Arc&gt;

<span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">StdArc</span>
ilabel, olabel, weight(Weight), <span style="color: #9ac0cd;">nextstate</span>

<span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">Weight</span>
<span style="color: #bebebe; font-weight: bold;">TropicalWeight</span>, LogWeight, ProductWeight

<span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">Fst</span>
<span style="color: #9ac0cd;">Start</span>(), Final(), Read(), etc ...

<span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">Mutable Fst</span>
<span style="color: #9ac0cd;">SetStart</span>(), SetFinal(), AddState(), AddArc()

<span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">StateIterator</span>
Done(), Value(), Next(), Reset()

<span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">ArcIterator</span>
Done(), Value(), Next(), Reset()

<span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">FstImple: public Fst</span>
type_, isymbols_, osymbols_, <span style="color: #9ac0cd;">ref_count_</span>

<span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">SymbolTable Impl: &#21253;&#35013;SymbolTable</span>
<span style="color: #bebebe; font-weight: bold;">map</span>&lt;<span style="color: #9ac0cd;">int64</span>, <span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">char</span>*&gt; key_map_;
<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #40e0d0; font-weight: bold;">const</span> <span style="color: #9ac0cd;">char</span> *&gt; <span style="color: #bebebe; font-weight: bold;">symbols_</span>;

<span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">VectorState</span>
final, <span style="color: #9ac0cd;">Vector</span>&lt;A&gt; <span style="color: #bebebe; font-weight: bold;">arcs</span>, niepsilon, <span style="color: #9ac0cd;">noepsilon</span>

<span style="color: #ee82ee;">//</span><span style="color: #ee82ee;">VectorFstBaseImpl: &#36825;&#20010;&#31867;&#26159;VectorFst&#30340;&#19968;&#31995;&#21015;&#23454;&#29616;</span>
<span style="color: #bebebe; font-weight: bold;">state_</span>;
<span style="color: #9ac0cd;">vector</span>&lt;<span style="color: #9ac0cd;">State</span> *&gt;<span style="color: #bebebe; font-weight: bold;">states</span>;
<span style="color: #9ac0cd;">StateId</span> <span style="color: #1e90ff; font-weight: bold;">AddState</span>() { states.push_back(<span style="color: #40e0d0; font-weight: bold;">new</span> <span style="color: #9ac0cd;">State</span>())
etc ...
</pre>
</div>
</div>
</li></ol>
</div>

<div id="outline-container-sec-8-11" class="outline-3">
<h3 id="sec-8-11"><span class="section-number-3">8.11</span> 半环</h3>
<div class="outline-text-3" id="text-8-11">
</div><ol class="org-ol"><li><a id="sec-8-11-1" name="sec-8-11-1"></a>幺半群<br  /><div class="outline-text-4" id="text-8-11-1">
<p>
三元组&lt;A, *, 1&gt;, 其中：
</p>
<ol class="org-ol">
<li>1为恒等元素，1*a=a*1
</li>
<li>a*b=b*a
</li>
</ol>
</div>
</li>
<li><a id="sec-8-11-2" name="sec-8-11-2"></a>半环<br  /><div class="outline-text-4" id="text-8-11-2">
<p>
五元组 &lt;A, +, *, 0, 1&gt;, 其中
</p>
<ol class="org-ol">
<li>&lt;A, +, 0&gt; 为交换幺半群
</li>
<li>&lt;A, *, 1&gt; 为幺半群
</li>
<li>a*(b+c) = a*b+a*c
</li>
<li>0*a = a*0 = 0
</li>
</ol>
</div>
</li>
<li><a id="sec-8-11-3" name="sec-8-11-3"></a>Moore &amp; Mealy<br  /><div class="outline-text-4" id="text-8-11-3">
<ul class="org-ul">
<li>Morre机：每个状态产生输出
</li>
<li>Mealy机：每个移动产生输出
</li>
</ul>
</div>
</li></ol>
</div>
<div id="outline-container-sec-8-12" class="outline-3">
<h3 id="sec-8-12"><span class="section-number-3">8.12</span> openfst</h3>
<div class="outline-text-3" id="text-8-12">
<p>
fstcompile &#x2013;isymbols=isyms.txt &#x2013;osymbols=osyms.txt text.fst binary.fst
fstdraw &#x2013;isymbols=isyms.txt &#x2013;osymbols=osyms.txt binary.fst binary.dot
dot -Tps binary.dot &gt;binary.ps
</p>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Google C++ Style Guide</h2>
<div class="outline-text-2" id="text-9">
<ol class="org-ol">
<li>函数超过10行时不要使用內联
</li>
<li>-inl.h內联函数实现文件 | 定义函数模板
</li>
<li>输入：const型，输出参数：指针
</li>
<li>最好给纯接口类加上Interface后缀
</li>
<li>名称为foo_的变量其访问函数为foo()，而其修改器(mutator)则为set_foo()，访问器常在头文件中定义为内联函数。
</li>
<li>请按下面的规则次序来定义类：公共成员位于私有成员前；方法位于数据成员前(变量)等等。
</li>
<li>scoped_ptr | shared_ptr
</li>
<li>使用cpplint.py来检测风格错误
</li>
<li>类型转换(Casting),需要类型转换时请使用static_cast&lt;&gt;()
</li>
<li>类成员以下划线结束 int val_;
</li>
<li>禁止使用异常
</li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: robin1001</p>
<p class="date">Created: 2014-11-26 三 22:00</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.4.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
